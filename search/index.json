[{"content":"Pointer  許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分    指標是一個變數，其值為記憶體位置    宣告：int32_t *p  p 是一個指標 指向的記憶體區塊被視為整數   初始化：int32_t *p = NULL address operator \u0026amp;：返回其變數的記憶體位置  如果想要印出記憶體位置，你可以使用%p   indirection operator *：也被稱為dereferencing operator，返回指向對象的值    void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別  傳參數至函式  在C語言中，argument passing 稱為 call-by-value  電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行   這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。  陣列與指標  在大部分的情況下，我們可以把array視為第一個元素的指標  現在你應該明白為什麼陣列的值會在函式中被修改   為了避免模棱兩可(搞混)，我較喜歡\u0026amp;(array[0])而不是array、\u0026amp;array 然而你不能寫出 array = \u0026amp;a int32_t    int16_t    int8_t    ptr++  移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用   事實上，array[n] = *(ptr + n)  Endian Issue   \n函式指標  指標不過是一個記憶體位址。 當我們宣告某種類型的指標時，這意味著電腦將將訪問記憶體並根據給定的類型解釋存儲在該位址的值。 您是否知道函式也存儲在記憶體中？ 使用函式指標時，返回的型別和參數應該要和實際的定義相同。  Really??為什麼在編譯時不會產生errors? 這是個檢查definition的好習慣。   回呼函式 (Callback function) 你可以用陣列來儲存函式指標 void (*f[3])(int32_t) = {f1, f2, f3};    使用了函式指標的例子  Menu Driven Driver 1struct file_operations scull_fops = { 2 .owner = THIS_MODULE , 3 .llseek = scull_llseek , 4 .read = scull_read , 5 .write = scull_write , 6 .ioctl = scull_ioctl , 7 .open = scull_open , 8 .release = scull_release , 9};  Firewall  1static unsigned int hook_func( 2 const struct nf_hook_ops *ops , 3 struct sk_buff *skb , 4 const struct net_device *in , 5 const struct net_device *out , 6 int (*okfn)( struct sk_buff *) 7)   記憶體管理  記憶體管理  分配記憶體當你宣告一個變數 垃圾回收 ( GC )   為什麼許多現代的程式語言不支援記憶體管理  軟體工程師是人類 人是不可被信任的   然而，如果軟體工程師知道他們在做什麼，那麼他們可以更有效率的管理記憶體 如果不考慮記憶體，請使用陣列 如果你想陣列的大小可以被動態的改變，那麼去讀 C++ 並學習如何使用 container   malloc 1#include \u0026lt;stdlib.h\u0026gt;2ptr = malloc( sizeof(int) * size);  malloc() 分配 size bytes 並回傳一個指向所分配的記憶體的指標 記憶體沒有初始化 若要初始化，請使用 memset  1#include \u0026lt;string.h\u0026gt;2memset(ptr, 0, sizeof(int) * size); calloc 1#include \u0026lt;stdlib.h\u0026gt;2ptr = calloc(size, sizeof(int));  在現代的 C 中，你應該使用 calloc 第一個參數：多少個區塊你想去分配? 第二個參數：每個區塊的大小。 記憶體被初始化成 0  free   \n free(ptr)：釋放 ptr 指向的記憶體空間，該記憶體空間必須是由之前使用 malloc()、calloc()、realloc() 所回傳的。 此外，若已經 free(ptr)，再次使用會發生未定義行為。  Double Pointer   \n 使用場景：  在函式中分配記憶體  1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdint.h\u0026gt;3#include \u0026lt;stdlib.h\u0026gt;4void table(int32_t **pp, int32_t n){ 5 *pp = (int32_t *)calloc(n * n, sizeof(int32_t)); 6 for(int32_t i=1; i\u0026lt;=n; ++i){ 7 for(int32_t j=1; j\u0026lt;=n; ++j){ 8 *(*pp + (i-1) * n + (j-1)) = i * j; 9 } 10 } 11} 12int main(){ 13 int32_t number = 0; 14 scanf(\u0026#34;%d\u0026#34;, number); 15 int32_t *ptr = NULL; 16 table(\u0026amp;ptr, number); 17 return 0; 18}  分配一個二維陣列  1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdint.h\u0026gt;3#include \u0026lt;stdlib.h\u0026gt;4int main() { 5 size_t size_row = 0, size_column = 0; 6 printf(\u0026#34;Please enter two integers for row and column: \u0026#34;); 7 scanf( \u0026#34;%lu %lu\u0026#34;, \u0026amp;size_row, \u0026amp;size_column ); 8 int32_t **ptr = NULL; 9 ptr = (int32_t **)calloc( sizeof( int32_t * ), size_row ); 10 for( size_t i = 0 ; i \u0026lt; size_row ; i++ ) { 11 *( ptr + i ) = (int32_t *)calloc( sizeof( int32_t ), size_column ); 12 for( size_t j = 0 ; j \u0026lt; size_column ; j++ ) { 13 *( *( ptr + i ) + j ) = ( i + 1 ) * ( j + 1 ); 14 } 15 } 16 for( size_t i = 0 ; i \u0026lt; size_row ; i++ ) { 17 for( size_t j = 0 ; j \u0026lt; size_column; j++ ) { 18 printf( \u0026#34;%4d \u0026#34;, *( *( ptr + i ) + j ) ); 19 } 20 printf( \u0026#34;\\n\u0026#34; ); 21 } 22 return 0; 23}    小工具 cdecl  安裝：sudo apt install cdecl 使用：cdecl -\u0026gt; explain int ***a;  資源查看  top / htop vmstat ( 較輕量化 )  vmstat -n 1 ( -n 1 為一秒輸出一次 )    ","date":"2020-12-23T19:38:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-08/","title":"程式設計(一)-08：Pointer"},{"content":"第一個 Hugo Blog  由於秉持著「人生總折騰」的道理，我來轉移 Blog 了(誤///)，好啦，其實是單純希望有個穩定且又能全天候供應的 Blog 而已，由於我的隊友兩人分別使用了 Hexo 及 Hugo ，因此一開始讓我有點難抉擇，但最終我還是選擇了 Hugo 。\n 至於第二個選擇的難關就是主題了，挑了好久都沒看到順眼的，差點就要聽吳文元說的沒有喜歡的就自己寫呀(怕///)，最終還是挑到了一個稍微滿意的主題 Stack。\n 至於架設的過程到目前為止還算是蠻順利的，希望之後也不會遇到什麼大坑。\n","date":"2020-12-18T01:16:06+08:00","permalink":"https://blog.smallten.tk/p/first-hugo-blog/","title":"First Hugo Blog"},{"content":"蓄水池抽樣法 (Reservoir Sampling)  從 N 個樣本中，隨機抽取 K 個樣本，其中 N 非常大(不能將所有數據都放進記憶體或是一個未知數)，而每個被抽出來的機率要相等。  定理 該算法保證每個元素以 \\( k \\over n \\) 的機率被選入蓄水池中。\n證明  第 i 個元素進入蓄水池的機率為 \\( k \\over i \\)，蓄水池內每個元素被替換的機率為\\( 1 \\over k \\) 因此在第 i 輪第 j 個元素被替換的機率為 \\( {k \\over i}\\times{1 \\over k} = {1 \\over i} \\)，接下來用 M.I. (數學歸納法)來證明，當 n 次循環結束時每個元素進入蓄水池的機率為 \\( k \\over n \\) 假設在 (i-1) 次迭代後，任意一個元素進入 蓄水池的概率為 \\( k \\over i-1 \\)。由上面的結論，在第 i 次迭代時，該元素被替換的概率為 \\( 1 \\over i \\)， 那麼其不被替換的概率則為 \\( 1 - {1 \\over i} = {i - 1 \\over i} \\) 故在第 i 次迭代後，該元素在蓄水池內的概率為 \\( {k \\over i-1} \\times {i-1 \\over i} = {k \\over i} \\)，歸納結束。 因此當循環結束時，每個元素進入蓄水池的概率為 \\( k \\over n \\)，命題得證。  例題  Leetcode 382.Linked List Random Node 解法： Cpp  1class Solution { 2 ListNode *p; 3public: 4 Solution(ListNode* head) { 5 p = head; 6 } 7 int getRandom() { 8 int ans = p-\u0026gt;val; 9 ListNode *t = p-\u0026gt;next; 10 for(int i=2; t; ++i){ 11 if(rand()%i == 0) ans = t-\u0026gt;val; 12 t = t-\u0026gt;next; 13 } 14 return ans; 15 } 16}; ","date":"2020-12-08T16:02:25+08:00","permalink":"https://blog.smallten.tk/p/algorithm-01/","title":"演算法-01：蓄水池抽樣法"},{"content":"Array  陣列是一種可以儲存大量相同型別資料的方法。 連續的記憶體位置。 永遠從0開始  int32_t a[10] -\u0026gt; a[0] ~ a[9]   計數變數 i 的型別可以宣告為 size_t，它是一個無號的整數型別。 初始化  int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0};   存取陣列元素使用 variable[index] 專業說明：電腦將找到第一個元素的地址，然後根據索引移動記憶體位置以訪問數據。 事實上一維陣列可以處理所有情況，至於多維陣列只是給人類方便閱讀的。   define  是遇處理指令，不是C的詞(statement) 我們可以使用 #define 去做巨集(MACRO)  當開發時MACRO有些像function，然而對電腦而言他們是不同的。 當遇到MACRO，編譯器將簡單的依定義替換掉程式碼。 函式擁有自己的標記。    基本排序 氣泡排序法 1for(int i = 0; i \u0026lt; n; ++i) { 2 for(int j = i; j \u0026lt; n; ++j) { 3 if(a[j] \u0026lt; a[i]) { 4 a[i] = a[i] ^ a[j]; 5 a[j] = a[i] ^ a[j]; 6 a[i] = a[i] ^ a[j]; 7 } 8 } 9} qsort 1#include \u0026lt;stdlib.c\u0026gt;2int cmp(const void *a, const void *b) { 3 return (*(int*)a - *(int*)b); 4} 5qsort(a, n, sizeof(int), cmp); 傳陣列至函式 1int f(int [][n], int); 2 3f(a, 10); 4 5int f(int a[][n], int size){ 6 7}  除了第一個[]外，剩下的都必須要給大小。(電腦才能計算偏移量) 為甚麼要給size? 因為傳過去的只是陣列的記憶體起始位置而已。 在函式中依然會改到本身的值。  const  constant read-only  可變長度陣列  Variable Length Array 雖然有些編譯器支援了以下寫法(C99之後)，但有些依然不支援  1int n = 5; 2int a[n] = {0};  但你應該使用 malloc  準確來說，你應該使用 calloc，而不是 `malloc。   我的建議：當考試的時候不要使用這功能( a[n] )，因為你不知道編譯器的版本。  ","date":"2020-12-07T19:38:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-07/","title":"程式設計(一)-07：Array"},{"content":"Makefile for 程設一 1CC = gcc 2CFLAGS = -Wall -Wextra -O2 -std=c11 3LDFLAGS = -lm 4TARGETS = main01 main02 5main01_OBJ = main01.o func01.o 6main02_OBJ = main02.o func02.o 7 8.PHONY = all clean 9 10all: $(TARGETS) 11 12.SECONDEXPANSION: 13$(TARGETS): $$($$@_OBJ) 14\t$(CC) $^ -o $@ $(LDFLAGS) 15 16%.o: $@.c 17 18clean: 19\t-$(RM) $(TARGETS) $(foreach targ,$(TARGETS),$(foreach obj, $($(targ)_OBJ), $(obj))) ","date":"2020-12-02T21:45:51+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-06/","title":"程式設計(一)-06：Makefile"},{"content":"Function 函式 double  double 是一種浮點數型別，就像是 float 就如同它的名字，它使用的記憶體大小為 float 的兩倍 建議: 當你需要浮點數的話，一律使用 double    到目前為止我們最常使用到的函式為 printf 我們稱這些函式為 C standard functions (C標準函式) 所有的函式都被儲存在libraries中  如果你想要讀書，你需要知道書在哪，然後去圖書館借書 如果你想要使用函式，你需要知道函式在哪，然後include library去使用函式 例如: stdio.h \u0026lt;-\u0026gt; printf   使用 math.h 時，需下編譯參數 -lm    永不重新發明輪子 在開發前請先搜尋   1//原型宣告 2Return-Value-Type Function-Name (parameter-Type-list); 3 4Return-Value-Type Function-Name (parameter-list){ 5 Statements 6}  使用原型宣告並將自訂函式置於main function之後的好處?  不用管function之間的先後順序。     void  沒有型別 在這裡，代表不需要回傳值  標頭檔 (Header Files)  甚麼是header file?  是一個包含函式的原型宣告(prototypes)和其他定義(definitions)的檔案   為甚麼我們需要header file?  抽象層 有時我們想保護我們的實作(implementation)     1#ifndef 2#define 3... 4#endif  如同我所說，軟體工程師是懶惰的  1#pragma once 如何編譯多個檔案 1#static 2gcc -c library.c -o library.o 3gcc main.c library.o -o main 4 5#dynamic 6gcc -shared test.o -o libtest.so 7gcc main.c -o main -L. -ltest 8#執行 9LD_LIBRARY_PATH=. ./main Link  Static link: Static linking is the process of copying all library modules used in the program into the final executable image. Dynamic link: In dynamic linking the names of the external libraries (shared libraries) are placed in the final executable file while the actual linking takes place at run time when both executable file and libraries are placed in the memory. .a 是一堆 .o 包在一起  Random 1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;time.h\u0026gt;3 4srand(time(0)); 5n = rand % 6 //n: 0 ~ 5  有安全要求時，請勿使用 random()  Global, Static, Extern Variable global  變數的生命週期為整個程式。 也可被extern所存取到。  static  變數只會在程式開始之前分配和初始化一次。 在程式終止之前，儲存空間都不會被釋放。 加上 static 後， extern便無法存取了。  extern  使用外部的變數。  遞迴 Recursive  遞迴定義如下  遞迴: 參見「遞迴」。   什麼?這個定義什麼也沒有說啊!好吧，改一下:  遞迴: 如果你還是沒明白遞迴是什麼意思的話，參見「遞迴」。    1Return-Value-Type Function-Name ( parameter-list ) { 2 if ( Base case ) { 3 Return pre-defined value. 4 } 5 else { 6 Call itself with parameter modification. 7 } 8}  所有能使用遞迴表達的敘述，皆能以迴圈的方式編寫。 To iterate is human, to recurse, divine. — L. Peter Deutsch 遞迴只應天上有，人間該當用迴圈 我的觀點:  如果你找到關係式，遞迴是簡單的。 時常用在虛擬碼(pseudo-code)中。 性能效率可能比迭代差。    ","date":"2020-11-21T21:48:47+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-05/","title":"程式設計(一)-05：Function"},{"content":"Loop - `while` - `for` - `do while`  While Loop 1while(條件){ 2 執行區塊 3}  %.200f 會發生什麼事? -\u0026gt; 精度不夠沒有意義 while(1) -\u0026gt; 無窮迴圈  For Loop 1for(初始化; 條件; 執行後操作){ 2 執行區塊 3}  i++ -\u0026gt; Use the current value of i. -\u0026gt; i = i + 1 ++i -\u0026gt; i = i + 1 -\u0026gt; Use the new value of i. {} -\u0026gt; 變數生命週期範圍 %4d ( %# ) -\u0026gt; 給最小的位數去顯示 在 ANSI C, 變數只能被宣告在函式的開頭，而 Modern C 沒有任何限制  Do While Loop 1do{ 2 執行區塊 3}while(條件)  三種不同類型的迴圈毫無疑問的都可以互相轉換  除了 do while 至少會執行一次   大多數來說，如果你知道要執行幾次迴圈的話，會使用 for break：離開當前的區段 continue：跳過剩餘的敘述，直接執行下一次迭代 無窮迴圈不是個好東西? -\u0026gt; 不，或許你會需要他，例如：Web server   1#include \u0026lt;unistd.h\u0026gt;2sleep(sec); ","date":"2020-10-18T20:33:18+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-04/","title":"程式設計(一)-04：Loop"},{"content":"Condition Control 簡介  我們想要讓電腦去做基礎的判斷  if switch    If 1if (condition1) { 2 statements; 3} 4else if (condition2){ 5 ... 6} 7else { 8 ... 9}  如果條件不是錯誤，那麼將會執行大括號裡的敘述  簡而言之，false 被定義為 0   \u0026gt; -\u0026gt; 大於 \u0026lt; -\u0026gt; 小於 \u0026gt;= -\u0026gt; 大於等於 \u0026lt;= -\u0026gt; 小於等於 == -\u0026gt; 等於 != -\u0026gt; 不等於 \u0026amp;\u0026amp; -\u0026gt; and || -\u0026gt; or  Boolean  在 Cpp 裡，有個型別稱為 bool  它只有兩個值：true, false 那麼 bool 使用的記憶體大小為何能?( 1 bit or 1 byte ??)   在 ANSI C 裡，沒有一個型別為boolean的 從 C99 開始，有一個標頭檔可以使用，stdbool.h  Switch  你可以使用 if-else 來做每個條件判斷，但是有時候可能會寫一個巨大的巢狀程式，因此將介紹另一個方法 switch  1switch (){ 2 case 1: 3 ... 4 break; 5 ... 6 default: 7 ... 8}  break：從此處結束  那麼如果不使用 break 呢??   default：如果沒有 case 符合，執行這段  浮點數比較 1#include \u0026lt;stdio.h\u0026gt;2int main() { 3 float a = 0.3; 4 if (a == 0.3) printf(\u0026#34;if01\\n\u0026#34;); 5 else printf(\u0026#34;else01\\n\u0026#34;); 6 if (a == 0.3f) printf(\u0026#34;if02\\n\u0026#34;); 7 else printf(\u0026#34;else02\\n\u0026#34;); 8 return 0; 9}  結果： else01 if02 請使用 sizeof() 查看發生了什麼!(IEEE 754) 結論：浮點數的比較是相當危險的!!  ","date":"2020-10-15T20:53:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-03/","title":"程式設計(一)-03：Condition Control"},{"content":"Arithmetic 1#include \u0026lt;stdio.h\u0026gt;2int main(){ 3 int a = 1, b = 2, sum = 0; 4 sum = a + b; 5 printf(\u0026#34;%d\u0026#34;, sum); 6 return 0; 7}  變數  每個變數都必須有它的型別 在使用變數前必須先宣告它   在C裡面， = 意思為”指定”，而不是”相等”，指派右邊的數值給左邊的變數 一個好習慣，總是初始化變數 C Spec:  C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero.      In C99: a == (a / b) * b + a % b printf 是一個函式去印出格式化字串  %d -\u0026gt; 有號十進位整數 %f -\u0026gt; 十進位浮點數 %u -\u0026gt; 無號十進位整數 當然不只這些   小技巧  1a += b -\u0026gt; a = a + b 2a -= b -\u0026gt; a = a - b 3a *= b -\u0026gt; a = a * b 4a /= b -\u0026gt; a = a / b 5a %= b -\u0026gt; a = a % b   查看記憶體使用大小： sizeof()，回傳單位為 byte ( printf(\u0026quot;%lu\u0026quot;, sizeof()); ) #include \u0026lt;stdint.h\u0026gt;  int8_t: 8-bit signed interger int16_t: 16-bit signed interger int32_t: 32-bit signed interger int64_t: 64-bit signed interger uint8_t: 8-bit unsigned interger uint16_t: 16-bit unsigned interger uint32_t: 32-bit unsigned interger uint64_t: 64-bit unsigned interger      輸入：scanf(\u0026quot;%d\u0026quot;, \u0026amp;a);  至於為甚麼需要 \u0026amp;，之後會在指標的章節介紹到 scanf 是否有回傳值? ( man 3 scanf )      最後也最重要的技能：RTFM and STFG  ","date":"2020-10-15T11:19:09+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-02/","title":"程式設計(一)-02：Arithmetic"},{"content":"簡介  這篇將帶你下載m3u8檔並分析出ts的檔案，再透過多線程來加速下載，之後再由FFmpeg合併成mp4。\nPython 下載m3u8 1m3u8Url = \u0026#39;https://.../index.m3u8\u0026#39; 2 3def downloadM3u8(url): 4 r = requests.get(url) 5 with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;wb\u0026#39;) as f: 6 f.write(r.content) 分析m3u8  這部份請依照你所取得的m3u8檔進行分析，並將完整的ts檔的url放進tsList即可。  1tsList = [] 2tsCnt = 0 3 4def analyzeM3u8(): 5 tsList.clear() 6 tempUrl = m3u8Url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; 7 with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;r\u0026#39;) as f: 8 text = f.read() 9 textList = text.split(\u0026#39;\\n\u0026#39;) 10 while textList[-1] != \u0026#39;#EXT-X-ENDLIST\u0026#39;: 11 textList.pop(-1) 12 for i in textList: 13 if i[0] != \u0026#39;#\u0026#39;: 14 tsList.append(tempUrl + i) 15 global tsCnt 16 tsCnt = len(tsList) 下載ts檔 1q = queue.Queue() 2 3def downloadts(): 4 global tsList 5 while q.qsize() \u0026gt; 0: 6 num = q.get() 7 r = requests.get(tsList[num]) 8 with open(\u0026#39;./ts/\u0026#39; + str(num+1) + \u0026#39;.ts\u0026#39;, \u0026#39;wb\u0026#39;) as f: 9 f.write(r.content) 10 11if __name__ == \u0026#34;__main__\u0026#34;: 12 if not os.path.isdir(\u0026#39;./ts/\u0026#39;): 13 os.mkdir(\u0026#39;./ts/\u0026#39;) 14 for i in range(tsCnt): 15 q.put(i) 16 thList = [] 17 for i in range(tsCnt): 18 th = threading.Thread(target=downloadts) 19 th.start() 20 thList.append(th) 21 for th in thList: 22 th.join() 23 print(\u0026#39;下載ts完成\u0026#39;) 合併ts成mp4 1def merge(tsCnt, output): 2 for i in range(tsCnt): 3 with open(\u0026#39;./ts/ts.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: 4 f.write(\u0026#39;file \u0026#39; + str(i+1) + \u0026#39;.ts\\n\u0026#39;) 5 command = \u0026#39;ffmpeg -y -f concat -i %s-bsf:a aac_adtstoasc -c copy %s\u0026#39; % (\u0026#39;./ts/ts.txt\u0026#39;, output) 6 os.system(command) 7 print(\u0026#39;合併成功\u0026#39;) 移除無用檔案 1def remove(): 2 shutil.rmtree(\u0026#39;./ts/\u0026#39;) 3 os.remove(\u0026#39;./index.m3u8\u0026#39;)  完整程式碼 1# -*- coding: UTF-8 -*- 2import requests, os, threading, queue, shutil 3 4m3u8Url = \u0026#39;https://.../index.m3u8\u0026#39; 5tsList = [] 6tsCnt = 0 7q = queue.Queue() 8 9def downloadM3u8(url): 10 r = requests.get(url) 11 with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;wb\u0026#39;) as f: 12 f.write(r.content) 13 14def analyzeM3u8(): 15 tsList.clear() 16 tempUrl = m3u8Url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; 17 with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;r\u0026#39;) as f: 18 text = f.read() 19 textList = text.split(\u0026#39;\\n\u0026#39;) 20 while textList[-1] != \u0026#39;#EXT-X-ENDLIST\u0026#39;: 21 textList.pop(-1) 22 for i in textList: 23 if i[0] != \u0026#39;#\u0026#39;: 24 tsList.append(tempUrl + i) 25 global tsCnt 26 tsCnt = len(tsList) 27 28def downloadts(): 29 global tsList 30 while q.qsize() \u0026gt; 0: 31 num = q.get() 32 r = requests.get(tsList[num]) 33 with open(\u0026#39;./ts/\u0026#39; + str(num+1) + \u0026#39;.ts\u0026#39;, \u0026#39;wb\u0026#39;) as f: 34 f.write(r.content) 35 36def merge(tsCnt, output): 37 for i in range(tsCnt): 38 with open(\u0026#39;./ts/ts.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: 39 f.write(\u0026#39;file \u0026#39; + str(i+1) + \u0026#39;.ts\\n\u0026#39;) 40 command = \u0026#39;ffmpeg -y -f concat -i %s-bsf:a aac_adtstoasc -c copy %s\u0026#39; % (\u0026#39;./ts/ts.txt\u0026#39;, output) 41 os.system(command) 42 print(\u0026#39;合併成功\u0026#39;) 43 44def remove(): 45 shutil.rmtree(\u0026#39;./ts/\u0026#39;) 46 os.remove(\u0026#39;./index.m3u8\u0026#39;) 47 48if __name__ == \u0026#34;__main__\u0026#34;: 49 downloadM3u8(m3u8Url) 50 analyzeM3u8() 51 print(\u0026#39;m3u8下載且分析完畢\u0026#39;) 52 if not os.path.isdir(\u0026#39;./ts/\u0026#39;): 53 os.mkdir(\u0026#39;./ts/\u0026#39;) 54 for i in range(tsCnt): 55 q.put(i) 56 thList = [] 57 for i in range(tsCnt): 58 th = threading.Thread(target=downloadts) 59 th.start() 60 thList.append(th) 61 for th in thList: 62 th.join() 63 print(\u0026#39;下載ts完成\u0026#39;) 64 merge(tsCnt, \u0026#39;./test.mp4\u0026#39;) 65 remove() ","date":"2020-10-04T16:36:35+08:00","permalink":"https://blog.smallten.tk/p/python-04/","title":"Python-04：多線程-ts下載並合併成mp4"},{"content":"簡介  現今你時常能在影音媒體網站看到 .m3u8 的檔案，以及許多 .ts 的分段媒體，本篇將教你如何簡單的下載成 .mp4 檔。 這篇並不詳加敘述 HLS 之類的觀念，若有興趣深入了解請自行查找資料。  FFmpeg  FFmpeg官網 下載安裝完後，若為 windows 用戶請將 %ffmpeg%\\bin 的路徑加入環境變數中，並於terminal中執行 ffmpeg -version 來查看是否成功加入。 下載檔案，直接在 terminal 輸入 ffmpeg -i m3u8URL -c copy filname.mp4，即可完成下載。(下面將提供Python的寫法)  Python 1# -*- coding: UTF-8 -*- 2import ffmpeg_streaming 3from ffmpeg_streaming import Formats 4 5url = \u0026#39;https://.../index.m3u8\u0026#39; 6filename = \u0026#39;test.mp4\u0026#39; 7 8def ffmpeg_download(input_path, output_path): 9 video = ffmpeg_streaming.input(input_path) 10 stream = video.stream2file(Formats.h264()) 11 stream.output(output_path) 12 13if __name__ == \u0026#34;__main__\u0026#34;: 14 ffmpeg_download(url, \u0026#39;./\u0026#39; + filename)  下一篇將教你如何直接從 m3u8 裡讀取目錄，並使用多線程下載 ts 並合併成 mp4  ","date":"2020-10-04T11:07:24+08:00","permalink":"https://blog.smallten.tk/p/python-03/","title":"Python-03：m3u8影片下載"},{"content":"Hello World 1#include \u0026lt;stdio.h\u0026gt;2//Your first code. 3int main(){ 4 printf(\u0026#34;Hello World\\n\u0026#34;); 5 return 0; 6}  main是每個C程式的進入點，我們稱它為main function(主函式) int 及 return 是C裡面的Keywords  int代表這個函式將會回傳一個整數 每個函式都應該有一個回傳值   每個敘述的結尾都應該要有 ; printf 是一個會顯示格式化字串的函式 \\n -\u0026gt; 換行 \\t -\u0026gt; tab \\\\ -\u0026gt; \\ \\\u0026quot; -\u0026gt; “ # 的那一行是C的預處理器並且不需要;結尾 stdio.h -\u0026gt; standard input / output header(標準輸出/輸入標頭檔) 註解 -\u0026gt; 是給開發者看的  //Your code -\u0026gt; 單行 /*Your code*/ -\u0026gt; 多行      使用編譯器將程式碼編譯成組合語言，再由組譯器組議成機械碼或可執行的二進制檔 IDE -\u0026gt; Integrated Development Environment，不是編譯器 gcc是最受歡迎的C編譯器之一(不完全對!!因為它不只做了編譯的動作…) 一些基本的Linux的操作指令  man -\u0026gt; 不會就問那個男人吧，男人不會就Google ls cd rm pwd   gcc main.c 一些參數  -o -v -g -Wall -Wextra -O2 or -Og    Makefile 1all: 2 gcc main.c -o main 3clean: 4 rm -rf main  make 將執行all下的指令 中間縮排應為Tab而不是Space make clean 預設可執行的檔名為 makefile，Makefile，GNUmakefile，若為其他可下 -f 的參數  ","date":"2020-10-04T11:00:48+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-01/","title":"程式設計(一)-01：Your first program"},{"content":"簡介  接續上一篇Python-01：爬蟲-圖片下載的內容，這篇文章將帶領大家使用多線程來加速圖片的下載  教學開始  首先我們先看個簡單的多線程範例  1import time, threading 2 3# 子執行緒的工作函數 4def job(): 5 for i in range(5): 6 print(\u0026#34;Child thread:\u0026#34;, i) 7 time.sleep(1) 8# 建立一個子執行緒 9t = threading.Thread(target = job) 10# 執行該子執行緒 11t.start() 12# 主執行緒繼續執行自己的工作 13for i in range(3): 14 print(\u0026#34;Main thread:\u0026#34;, i) 15 time.sleep(1) 16# 等待 t 這個子執行緒結束 17t.join() 18print(\u0026#34;Done.\u0026#34;) 1import time, threading 2 3# 子執行緒的工作函數 4def job(num): 5 print(\u0026#34;Thread\u0026#34;, num) 6 time.sleep(1) 7# 建立 5 個子執行緒 8threads = [] 9for i in range(5): 10 threads.append(threading.Thread(target = job, args = (i,))) 11 threads[i].start() 12# 主執行緒繼續執行自己的工作 13 14# 等待所有子執行緒結束 15for i in range(5): 16 threads[i].join() 17print(\u0026#34;Done.\u0026#34;)  接下來我們修改Python-01：爬蟲-圖片下載中下載圖片那部分的程式碼  1th_list = [] 2for i in range(img_count): 3 img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; 4 th = threading.Thread(target=download_img, args=(img, i)) 5 th.start() 6 th_list.append(th) 7for th in th_list: 8 th.join() 完整程式碼 1# -*- coding: UTF-8 -*- 2from selenium import webdriver 3from bs4 import BeautifulSoup 4import requests, threading 5 6def download_img(img, num): 7 r = requests.get(img) 8 with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: 9 f.write(r.content) 10 11if __name__ == \u0026#34;__main__\u0026#34;: 12 save_url = \u0026#39;./test/\u0026#39; 13 url = \u0026#39;https://www.ohmanhua.com/13621/1/1.html\u0026#39; 14 chop = webdriver.ChromeOptions() 15 chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) 16 browser = webdriver.Chrome(options = chop) 17 browser.implicitly_wait(10) 18 browser.get(url) 19 soup = BeautifulSoup(browser.page_source, \u0026#39;lxml\u0026#39;) 20 img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) 21 img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) 22 if img_url[0] == \u0026#39;/\u0026#39;: 23 img_url = \u0026#39;https:\u0026#39; + img_url 24 m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) 25 img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; 26 th_list = [] 27 for i in range(img_count): 28 img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; 29 th = threading.Thread(target=download_img, args=(img, i)) 30 th.start() 31 th_list.append(th) 32 for th in th_list: 33 th.join() 34 browser.quit() ","date":"2020-08-03T00:56:43+08:00","permalink":"https://blog.smallten.tk/p/python-02/","title":"Python-02：多線程-加速圖片下載"},{"content":"簡介  這一篇將帶領大家透過Python的爬蟲自動化的下載圖片  安裝  打開終端機，安裝下列套件  pip install requests pip install BeautifulSoup4 pip install lxml pip install selenium   至 Chrome Driver 下載當前電腦中Chrome所對應版本的Driver  教學開始  首先因為這次的主題為圖片下載，因此我們找了一個擁有大量圖片的漫畫網頁來進行教學。 由於這個網頁的圖片是由JavaScript加載的，因此一開始我們使用Selenium來開啟網頁 1from selenium import webdriver 2 3url = \u0026#39;https://www.ohmanhua.com/13621/1/1.html\u0026#39; 4#使用crx插件 5chop = webdriver.ChromeOptions() 6chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) 7browser = webdriver.Chrome(options = chop) 8browser.implicitly_wait(10) 9browser.get(url)  當然若不想顯示瀏覽器的視窗可以使用headless模式  1chop.add_argument(\u0026#39;--headless\u0026#39;) #規避google bug 2chop.add_argument(\u0026#39;--disable-gpu\u0026#39;)  接下來使用BeautifulSoup4來分析頁面，並取得圖片網址，和共幾張圖片  1img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) 2img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) 3if img_url[0] == \u0026#39;/\u0026#39;: 4 img_url = \u0026#39;https:\u0026#39; + img_url 5m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) 6img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39;  最後便是下載圖片和關閉瀏覽器  1def download_img(img, num): 2 r = requests.get(img) 3 with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: 4 f.write(r.content) 5 6for i in range(img_count): 7 img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; 8 download_img(img, i) 9browser.quit() 完整程式碼 1# -*- coding: UTF-8 -*- 2from selenium import webdriver 3from bs4 import BeautifulSoup 4import requests 5 6def download_img(img, num): 7 r = requests.get(img) 8 with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: 9 f.write(r.content) 10 11if __name__ == \u0026#34;__main__\u0026#34;: 12 save_url = \u0026#39;./download/\u0026#39; 13 url = \u0026#39;\u0026#39; 14 chop = webdriver.ChromeOptions() 15 chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) 16 browser = webdriver.Chrome(options = chop) 17 browser.implicitly_wait(10) 18 browser.get(url) 19 soup = BeautifulSoup(browser.page_source, \u0026#39;lxml\u0026#39;) 20 img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) 21 img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) 22 if img_url[0] == \u0026#39;/\u0026#39;: 23 img_url = \u0026#39;https:\u0026#39; + img_url 24 m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) 25 img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; 26 for i in range(img_count): 27 img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; 28 download_img(img, i) 29 browser.quit() ","date":"2020-08-03T00:39:24+08:00","permalink":"https://blog.smallten.tk/p/python-01/","title":"Python-01：爬蟲-圖片下載"},{"content":"簡介  這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作在Raspberry pi用Python讀取Arduino Serial的數值，並且製作一個簡易的UI實時顯示出數值。  硬體  上一小節的成品 Raspberry pi * 1  教學開始  打開Raspberry pi的Terminal，並輸入 ls /dev/tty* 將Arduino的Usb接上Raspberry pi 再次於Terminal中輸入 ls /dev/tty*，比較兩次的差異，即可知Arduino使用的序列埠為何(例如此時為/ dev/ttyACM0，請依照情況自行修改) 於Terminal中輸入 python3 -m pip install pyserial 將以下程式碼建立成一個python檔，再以python3執行即可  1# -*- coding: UTF-8 -*- 2import serial 3import tkinter as tk 4 5def getData(): 6 ser = serial.Serial(\u0026#39;/dev/ttyACM0\u0026#39;, 9600, timeout=1) 7 ser.flush() 8 while True: 9 flag = False 10 if ser.in_waiting\u0026gt;0: 11 arduinoData = ser.readline().decode(encoding=\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;).rstrip().split(\u0026#39;;\u0026#39;) 12 if len(arduinoData)!=4 or arduinoData==\u0026#39;\u0026#39;: 13 continue 14 for i in range(0,3): 15 if arduinoData[i]==\u0026#39;0\u0026#39;: 16 flag = True 17 break 18 if flag: 19 continue 20 else: 21 temperature_value[\u0026#39;text\u0026#39;] = arduinoData[0] + \u0026#39; 度C\u0026#39; 22 humidity_value[\u0026#39;text\u0026#39;] = arduinoData[1] + \u0026#39; %\u0026#39; 23 pmat25_value[\u0026#39;text\u0026#39;] = arduinoData[2] + \u0026#39; ug/m^3\u0026#39; 24 wind_value[\u0026#39;text\u0026#39;] = arduinoData[3] + \u0026#39; 級\u0026#39; 25 break 26 window.after(1000, getData) 27 28if __name__==\u0026#39;__main__\u0026#39;: 29 window = tk.Tk() 30 window.title(\u0026#39;Weather\u0026#39;) 31 window.geometry(\u0026#39;500x250\u0026#39;) 32 window.resizable(False, False) 33 34 header_label = tk.Label(window, text=\u0026#39;環境監測\u0026#39;, font=(\u0026#39;Arial\u0026#39;, 20), width=30, height=2, borderwidth=2, relief=\u0026#39;solid\u0026#39;) 35 header_label.pack(side=tk.TOP) 36 37 temperature_frame = tk.Frame(window) 38 temperature_frame.pack(side=tk.TOP) 39 temperature_label = tk.Label(temperature_frame, text=\u0026#39;溫度: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) 40 temperature_label.pack(side=tk.LEFT) 41 temperature_value = tk.Label(temperature_frame, font=(\u0026#39;Arial\u0026#39;, 16)) 42 temperature_value.pack(side=tk.LEFT) 43 44 humidity_frame = tk.Frame(window) 45 humidity_frame.pack(side=tk.TOP) 46 humidity_label = tk.Label(humidity_frame, text=\u0026#39;濕度: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) 47 humidity_label.pack(side=tk.LEFT) 48 humidity_value = tk.Label(humidity_frame, font=(\u0026#39;Arial\u0026#39;, 16)) 49 humidity_value.pack(side=tk.LEFT) 50 51 pmat25_frame = tk.Frame(window) 52 pmat25_frame.pack(side=tk.TOP) 53 pmat25_label = tk.Label(pmat25_frame, text=\u0026#39;PM2.5: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) 54 pmat25_label.pack(side=tk.LEFT) 55 pmat25_value = tk.Label(pmat25_frame, font=(\u0026#39;Arial\u0026#39;, 16)) 56 pmat25_value.pack(side=tk.LEFT) 57 58 wind_frame = tk.Frame(window) 59 wind_frame.pack(side=tk.TOP) 60 wind_label = tk.Label(wind_frame, text=\u0026#39;風速: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) 61 wind_label.pack(side=tk.LEFT) 62 wind_value = tk.Label(wind_frame, font=(\u0026#39;Arial\u0026#39;, 16)) 63 wind_value.pack(side=tk.LEFT) 64 65 getData() 66 window.mainloop()  最終成果圖     ","date":"2020-07-12T09:31:38+08:00","permalink":"https://blog.smallten.tk/p/weather-02/","title":"簡易氣象站-02"},{"content":"簡介  這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作由Arduino抓取感測器數值的部分。  硬體  Arduino Uno R3 * 1 攀藤 G5 PMS5003 * 1 DFrobot 三杯式風速感測器 * 1  教學開始 連結電路   \nUno程式碼 1#include \u0026lt;SoftwareSerial.h\u0026gt;2#define windPin A0 3SoftwareSerial pmsSerial(2, 3); 4 5long pmValue=0; 6long pmcf25=0; 7long pmat25=0; 8unsigned int temperature = 0; 9unsigned int humandity = 0; 10 11void retrievepm25(){ 12 int count = 0; 13 unsigned char c; 14 unsigned char high; 15 while (pmsSerial.available()) { 16 c = pmsSerial.read(); 17 if((count==0 \u0026amp;\u0026amp; c!=0x42) || (count==1 \u0026amp;\u0026amp; c!=0x4d)) 18 break; 19 if(count \u0026gt; 27) 20 break; 21 else if(count == 4 || count == 6 || count == 8 || count == 10 || count == 12 || count == 14 || count == 24 || count == 26) 22 high = c; 23 else if(count == 7){ 24 pmcf25 = 256*high + c; 25 pmValue = pmcf25; 26 } 27 else if(count == 13){ 28 pmat25 = 256*high + c; 29 pmValue = pmat25; 30 } 31 else if(count == 25) 32 temperature = (256*high + c)/10; 33 else if(count == 27) 34 humandity = (256*high + c)/10; 35 count++; 36 } 37 while(pmsSerial.available()) 38 pmsSerial.read(); 39} 40 41void setup() { 42 Serial.begin(9600); 43 pmsSerial.begin(9600); 44} 45 46void loop() { 47 retrievepm25(); 48 Serial.print(temperature); 49 Serial.print(\u0026#34;;\u0026#34;); 50 Serial.print(humandity); 51 Serial.print(\u0026#34;;\u0026#34;); 52 Serial.print(pmat25); 53 54 int windValue = analogRead(windPin); 55 int Level = 6 * windValue * (5.0 / 1023.0); 56 Serial.print(\u0026#34;;\u0026#34;); 57 Serial.print(Level); 58 59 Serial.println(); 60 delay(1000); 61} ","date":"2020-07-12T09:02:34+08:00","permalink":"https://blog.smallten.tk/p/weather-01/","title":"簡易氣象站-01"},{"content":"簡介  這篇內容將教大家透過Arduino的序列埠設定HC-05的AT命令  硬體  Arduino Uno * 1 HC-05藍芽模組 * 1  教學 腳位連接    Arduino HC-05     5V VCC   GND GND   8 TX   9 RX    程式碼 1#include \u0026lt;SoftwareSerial.h\u0026gt;2 3SoftwareSerial BT(8, 9); 4char val; 5 6void setup() { 7 Serial.begin(9600); 8 BT.begin(38400); 9} 10 11void loop() { 12 if(Serial.available()){ 13 val = Serial.read(); 14 BT.print(val); 15 } 16 if(BT.available()){ 17 val = BT.read(); 18 Serial.print(val); 19 } 20}  連接腳位，並上傳程式碼，最後給HC-05供電前，先按住上面的按鈕，再提供電源，燈號將變成約兩秒一閃，及表示進入了AT命令模式 接下來打開序列埠監控視窗，將設定調成\u0026quot;9600 baud\u0026quot;和\u0026quot;NL與CR\u0026quot;，最後依需求輸入以下命令即可   AT -\u0026gt; 顯示OK表示連接成功 查看韌體版本 -\u0026gt; AT+VERSION 查看名稱 -\u0026gt; AT+NAME? 修改名稱 -\u0026gt; AT+NAME=你要的名字 查看密碼 -\u0026gt; AT+PSWD? 修改密碼 -\u0026gt; AT+PSWD=你要的密碼  ","date":"2020-05-10T21:56:45+08:00","permalink":"https://blog.smallten.tk/p/arduino-05/","title":"Arduino-05：HC-05 AT命令"},{"content":"簡介  這篇內容將帶領大家製作藍芽的遙控車，並且用Blynk的Joystick操控它  硬體  Arduino nano * 1 L298N 馬達控制板 * 1 HC-05 藍芽模組 * 1 二輪直流馬達遙控車 * 1  下載  至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫  教學開始  先上傳程式碼至Nano板中 依照下方圖示連接腳位，並且設定Blynk App內的物件  連接腳位   \n設定Blynk  創建3個元件，分別為Button、Bluetooth、Joystick，並且依下圖進行設置         nano程式碼 1#include \u0026lt;BlynkSimpleSerialBLE.h\u0026gt;2#define BLYNK_USE_DIRECT_CONNECT 3 4char auth[] = \u0026#34;Blynk Auth\u0026#34;; 5int d[2] = {0}; 6int car[2][2] = { {5, 6}, {11, 10} }; //in 1,2,4,3 7int en[2] = {3, 9}; 8 9void Controller(); 10void Move(int, int, int, int, int, int); 11 12BLYNK_WRITE(V0){ 13 for(int i=0; i\u0026lt;2; ++i){ 14 d[i] = param[i].asInt(); 15 if(d[i]\u0026lt;=64) d[i] = d[i]*2-255; 16 else if(d[i]\u0026gt;64 \u0026amp;\u0026amp; d[i]\u0026lt;=192) d[i]=0; 17 } 18} 19 20void setup() { 21 Serial.begin(9600); 22 Blynk.begin(Serial, auth); 23 for(int i=0; i\u0026lt;2; ++i){ 24 pinMode(en[i], OUTPUT); 25 for(int j=0; j\u0026lt;2; ++j){ 26 pinMode(car[i][j], OUTPUT); 27 } 28 } 29} 30 31void loop() { 32 Blynk.run(); 33 Controller(); 34} 35 36void Controller() { 37 if(d[0]\u0026gt;0){ 38 if(d[1]\u0026gt;0) Move(0, 1, 1, 0, min(d[0], d[1]), max(d[0], d[1])); 39 else if(d[1]==0) Move(0, 0, 1, 0, 0, d[0]); 40 else Move(1, 0, 0, 1, min(d[0], abs(d[1])), max(d[0], abs(d[1]))); 41 } 42 else if(d[0]==0){ 43 if(d[1]\u0026gt;0) Move(1, 0, 1, 0, d[1], d[1]); 44 else if(d[1]==0) Move(0, 0, 0, 0, 0, 0); 45 else Move(0, 1, 0, 1, abs(d[1]), abs(d[1])); 46 } 47 else{ 48 if(d[1]\u0026gt;0) Move(1, 0, 0, 1, max(abs(d[0]), d[1]), min(abs(d[0]), d[1])); 49 else if(d[1]==0) Move(1, 0, 0, 0, abs(d[0]), 0); 50 else Move(0, 1, 1, 0, max(abs(d[0]), abs(d[1])), min(abs(d[0]), abs(d[1]))); 51 } 52} 53 54void Move(int a1,int a2, int a3, int a4, int e1, int e2) { 55 digitalWrite(car[0][0], a1); 56 digitalWrite(car[0][1], a2); 57 digitalWrite(car[1][0], a3); 58 digitalWrite(car[1][1], a4); 59 analogWrite(en[0], e1); 60 analogWrite(en[1], e2); 61} 補充  由於這邊我們將HC-05和Nano板的RX、TX對接，因此自行修改程式碼後要重新上傳時，記得先移除連接Nano板的那兩條線，當然也可使用SoftwareSerial Library來進行，就不用拔除線路了 若要自行修改HC-05的設定，可參考下一篇文章 ARDUINO-05：HC-05 AT命令  ","date":"2020-05-03T16:29:01+08:00","permalink":"https://blog.smallten.tk/p/arduino-04/","title":"Arduino-04：藍芽遙控車"},{"content":"簡介  這篇內容將帶領大家製作點陣跑馬燈，並且用Blynk來操控它  硬體  WeMos D1R2 * 1 MAX7219 8*8LED點陣模組 * 2  下載  至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 maxmatrix－下載並加入函式庫  教學開始 連接腳位    MAX7219 D1R2     VCC 5V   GND GND   DIN MOSI/D7   CS SS/D8   CLK SCK/D5     若要串聯多塊MAX7219的話，請將下一塊的DIN接至上一塊的DOUT連接腳位  設定Blynk  請照下圖拉出三個物件，並設定其相關參數         D1R2程式碼 1#include \u0026lt;MaxMatrix.h\u0026gt;2#include \u0026lt;avr/pgmspace.h\u0026gt;3#include \u0026lt;ESP8266WiFi.h\u0026gt;4#include \u0026lt;BlynkSimpleEsp8266.h\u0026gt;5 6char auth[] = \u0026#34;Blynk auth\u0026#34;; 7char ssid[] = \u0026#34;Wifi ssid\u0026#34;; 8char pass[] = \u0026#34;Wifi password\u0026#34;; 9 10PROGMEM const unsigned char CH[] = { 11 3, 8, B0000000, B0000000, B0000000, B0000000, B0000000, // space 12 1, 8, B1011111, B0000000, B0000000, B0000000, B0000000, // ! 13 3, 8, B0000011, B0000000, B0000011, B0000000, B0000000, // \u0026#34; 14 5, 8, B0010100, B0111110, B0010100, B0111110, B0010100, // # 15 4, 8, B0100100, B1101010, B0101011, B0010010, B0000000, // $ 16 5, 8, B1100011, B0010011, B0001000, B1100100, B1100011, // % 17 5, 8, B0110110, B1001001, B1010110, B0100000, B1010000, // \u0026amp; 18 1, 8, B0000011, B0000000, B0000000, B0000000, B0000000, // \u0026#39; 19 3, 8, B0011100, B0100010, B1000001, B0000000, B0000000, // ( 20 3, 8, B1000001, B0100010, B0011100, B0000000, B0000000, // ) 21 5, 8, B0101000, B0011000, B0001110, B0011000, B0101000, // * 22 5, 8, B0001000, B0001000, B0111110, B0001000, B0001000, // + 23 2, 8, B10110000, B1110000, B0000000, B0000000, B0000000, // , 24 4, 8, B0001000, B0001000, B0001000, B0001000, B0000000, // - 25 2, 8, B1100000, B1100000, B0000000, B0000000, B0000000, // . 26 4, 8, B1100000, B0011000, B0000110, B0000001, B0000000, // / 27 4, 8, B0111110, B1000001, B1000001, B0111110, B0000000, // 0 28 3, 8, B1000010, B1111111, B1000000, B0000000, B0000000, // 1 29 4, 8, B1100010, B1010001, B1001001, B1000110, B0000000, // 2 30 4, 8, B0100010, B1000001, B1001001, B0110110, B0000000, // 3 31 4, 8, B0011000, B0010100, B0010010, B1111111, B0000000, // 4 32 4, 8, B0100111, B1000101, B1000101, B0111001, B0000000, // 5 33 4, 8, B0111110, B1001001, B1001001, B0110000, B0000000, // 6 34 4, 8, B1100001, B0010001, B0001001, B0000111, B0000000, // 7 35 4, 8, B0110110, B1001001, B1001001, B0110110, B0000000, // 8 36 4, 8, B0000110, B1001001, B1001001, B0111110, B0000000, // 9 37 2, 8, B01010000, B0000000, B0000000, B0000000, B0000000, // : 38 2, 8, B10000000, B01010000, B0000000, B0000000, B0000000, // ; 39 3, 8, B0010000, B0101000, B1000100, B0000000, B0000000, // \u0026lt; 40 3, 8, B0010100, B0010100, B0010100, B0000000, B0000000, // = 41 3, 8, B1000100, B0101000, B0010000, B0000000, B0000000, // \u0026gt; 42 4, 8, B0000010, B1011001, B0001001, B0000110, B0000000, // ? 43 5, 8, B0111110, B1001001, B1010101, B1011101, B0001110, // @ 44 4, 8, B1111110, B0010001, B0010001, B1111110, B0000000, // A 45 4, 8, B1111111, B1001001, B1001001, B0110110, B0000000, // B 46 4, 8, B0111110, B1000001, B1000001, B0100010, B0000000, // C 47 4, 8, B1111111, B1000001, B1000001, B0111110, B0000000, // D 48 4, 8, B1111111, B1001001, B1001001, B1000001, B0000000, // E 49 4, 8, B1111111, B0001001, B0001001, B0000001, B0000000, // F 50 4, 8, B0111110, B1000001, B1001001, B1111010, B0000000, // G 51 4, 8, B1111111, B0001000, B0001000, B1111111, B0000000, // H 52 3, 8, B1000001, B1111111, B1000001, B0000000, B0000000, // I 53 4, 8, B0110000, B1000000, B1000001, B0111111, B0000000, // J 54 4, 8, B1111111, B0001000, B0010100, B1100011, B0000000, // K 55 4, 8, B1111111, B1000000, B1000000, B1000000, B0000000, // L 56 5, 8, B1111111, B0000010, B0001100, B0000010, B1111111, // M 57 5, 8, B1111111, B0000100, B0001000, B0010000, B1111111, // N 58 4, 8, B0111110, B1000001, B1000001, B0111110, B0000000, // O 59 4, 8, B1111111, B0001001, B0001001, B0000110, B0000000, // P 60 4, 8, B0111110, B1000001, B1000001, B10111110, B0000000, // Q 61 4, 8, B1111111, B0001001, B0001001, B1110110, B0000000, // R 62 4, 8, B1000110, B1001001, B1001001, B0110010, B0000000, // S 63 5, 8, B0000001, B0000001, B1111111, B0000001, B0000001, // T 64 4, 8, B0111111, B1000000, B1000000, B0111111, B0000000, // U 65 5, 8, B0001111, B0110000, B1000000, B0110000, B0001111, // V 66 5, 8, B0111111, B1000000, B0111000, B1000000, B0111111, // W 67 5, 8, B1100011, B0010100, B0001000, B0010100, B1100011, // X 68 5, 8, B0000111, B0001000, B1110000, B0001000, B0000111, // Y 69 4, 8, B1100001, B1010001, B1001001, B1000111, B0000000, // Z 70 2, 8, B1111111, B1000001, B0000000, B0000000, B0000000, // [ 71 4, 8, B0000001, B0000110, B0011000, B1100000, B0000000, // backslash 72 2, 8, B1000001, B1111111, B0000000, B0000000, B0000000, // ] 73 3, 8, B0000010, B0000001, B0000010, B0000000, B0000000, // hat 74 4, 8, B1000000, B1000000, B1000000, B1000000, B0000000, // _ 75 2, 8, B0000001, B0000010, B0000000, B0000000, B0000000, // ` 76 4, 8, B0100000, B1010100, B1010100, B1111000, B0000000, // a 77 4, 8, B1111111, B1000100, B1000100, B0111000, B0000000, // b 78 4, 8, B0111000, B1000100, B1000100, B0101000, B0000000, // c 79 4, 8, B0111000, B1000100, B1000100, B1111111, B0000000, // d 80 4, 8, B0111000, B1010100, B1010100, B0011000, B0000000, // e 81 3, 8, B0000100, B1111110, B0000101, B0000000, B0000000, // f 82 4, 8, B10011000, B10100100, B10100100, B01111000, B0000000, // g 83 4, 8, B1111111, B0000100, B0000100, B1111000, B0000000, // h 84 3, 8, B1000100, B1111101, B1000000, B0000000, B0000000, // i 85 4, 8, B1000000, B10000000, B10000100, B1111101, B0000000, // j 86 4, 8, B1111111, B0010000, B0101000, B1000100, B0000000, // k 87 3, 8, B1000001, B1111111, B1000000, B0000000, B0000000, // l 88 5, 8, B1111100, B0000100, B1111100, B0000100, B1111000, // m 89 4, 8, B1111100, B0000100, B0000100, B1111000, B0000000, // n 90 4, 8, B0111000, B1000100, B1000100, B0111000, B0000000, // o 91 4, 8, B11111100, B0100100, B0100100, B0011000, B0000000, // p 92 4, 8, B0011000, B0100100, B0100100, B11111100, B0000000, // q 93 4, 8, B1111100, B0001000, B0000100, B0000100, B0000000, // r 94 4, 8, B1001000, B1010100, B1010100, B0100100, B0000000, // s 95 3, 8, B0000100, B0111111, B1000100, B0000000, B0000000, // t 96 4, 8, B0111100, B1000000, B1000000, B1111100, B0000000, // u 97 5, 8, B0011100, B0100000, B1000000, B0100000, B0011100, // v 98 5, 8, B0111100, B1000000, B0111100, B1000000, B0111100, // w 99 5, 8, B1000100, B0101000, B0010000, B0101000, B1000100, // x 100 4, 8, B10011100, B10100000, B10100000, B1111100, B0000000, // y 101 3, 8, B1100100, B1010100, B1001100, B0000000, B0000000, // z 102 3, 8, B0001000, B0110110, B1000001, B0000000, B0000000, // { 103 1, 8, B1111111, B0000000, B0000000, B0000000, B0000000, // | 104 3, 8, B1000001, B0110110, B0001000, B0000000, B0000000, // } 105 4, 8, B0001000, B0000100, B0001000, B0000100, B0000000, // ~ 106}; 107 108const byte data = D7; 109const byte cs = D8; 110const byte clk = D5; 111const byte maxInUse = 2; //使用的點陣模塊數量 112MaxMatrix m(data, cs, clk, maxInUse); 113byte buffer[8]; 114String str; 115int speed = 100; //移動的速度，單位ms 116int light = 5; 117bool islight = false; 118 119void printChar(char); 120 121BLYNK_WRITE(V0){ 122 str = param.asStr(); 123 for(int i=0; i\u0026lt;maxInUse; ++i) 124 str+=\u0026#34; \u0026#34;; 125} 126 127BLYNK_WRITE(V1){ 128 light = param.asInt(); 129 islight = true; 130} 131 132BLYNK_WRITE(V2){ 133 speed = param.asInt(); 134} 135 136void setup() { 137 Serial.begin(115200); 138 //Blynk 139 Blynk.begin(auth, ssid, pass); 140 Blynk.virtualWrite(V1, light); 141 Blynk.virtualWrite(V2, speed); 142 //8*8 led 143 m.init(); 144 m.setIntensity(light); //點陣模組的亮度 145} 146 147void loop() { 148 if(Blynk.connected()){ 149 Blynk.run(); 150 if(islight){ 151 m.setIntensity(light); 152 islight = false; 153 } 154 int len = str.length(); 155 for(int i=0; i\u0026lt;len; ++i){ 156 printChar(str[i]); 157 } 158 } 159 else{ 160 Blynk.begin(auth, ssid, pass); 161 Serial.println(\u0026#34;Reconnected!\u0026#34;); 162 } 163} 164 165void printChar(char c) { 166 if(c\u0026lt;32) return; 167 c-=32; 168 memcpy_P(buffer, CH+7*c, 7); 169 m.writeSprite(32, 0, buffer); 170 m.setColumn(32+buffer[0], 0); 171 for(int i=0; i\u0026lt;=buffer[0]; ++i){ 172 delay(speed); 173 /*往左位移，第一個參數false，代表不旋轉； 174第二個參數false，代表不清空顯示；若設成true，顯示器將不呈現資料。*/ 175 m.shiftLeft(false, false); 176 } 177} 補充  若是覺得Blynk的能量太少，可自行架設 Server  ","date":"2020-04-09T14:50:56+08:00","permalink":"https://blog.smallten.tk/p/arduino-03/","title":"Arduino-03：跑馬燈"},{"content":"簡介  這篇內容將帶領大家把Arduino手把變成電腦手把  所需硬體  Arduino Uno R3 * 1 JoyStick 雙軸按鍵搖桿模組 * 1  下載檔案  FLIP － 請下載包含JRE的檔案(Java Runtime Environment included) UnoJoy － 將Uno變成電腦手把 x360ce － 將手把模擬成xbox 360的手把  教學開始  將下載好的FLIP安裝至電腦 確定電腦已安裝Arduino IDE，並已連接Uno板至電腦，可在裝置管理員查看狀態（如下圖）    打開剛剛下載的UnoJoy資料夾下的檔案，並將它上傳進Uno板中 UnoJoy-master\\UnoJoy\\UnoJoyArduinoSample\\UnoJoyArduinoSample.ino 關閉Arduino IDE，進入DFU Mode，進入方式：用導線同時接觸下圖框起處的兩根針腳    確認已進入 DFU Mode，如下圖     若找不到驅動可手動新增驅動，選擇資料夾為 C:\\Program Files (x86)\\Atmel\\Flip 3.4.7\\usb   打開UnoJoy資料夾，啟動TurnIntoAJoystick的批次檔，檔案路徑 UnoJoy-master\\UnoJoy\\TurnIntoAJoystick.bat，執行成功結果如下圖    至此已完成將Uno變成電腦搖桿，之後插上Uno板皆為UnoJoy Joystick，可在以下路徑查看 控制台\\硬體和音效\\裝置和印表機 將搖桿的vrx和vry分別連接至Uno板的A0和A1，在 控制台\\硬體和音效\\裝置和印表機 裡的UnoJoy Joystick圖示上右鍵-\u0026gt;遊戲控制器-\u0026gt;內容，可查看搖桿狀態，如下圖    最後進入起動x360ce，新建立一個搖桿的設定檔，並選取模擬的位置，點選[Record]，依圖示移動搖桿方向即設定完成  補充  如何將UnoJoy Joystick變回一般的Arduino Uno板  連接UnoJoy Joystick，並進入DFU Mode 打開UnoJoy資料夾，啟動TurnIntoAnArduino的批次檔，檔案路徑 UnoJoy-master\\UnoJoy\\TurnIntoAnArduino.bat 將Uno的usb重新接上電腦，即可看到已變回   如果UnoJoy檔案下載太慢，可至 這裡 下載，但此載點內容僅包含uno板的檔案（Github的檔案裡包含其他板子變成手把的檔案，故檔案相對較大） 如何在電腦遊戲中使用此手把  將剛剛x360ce創建的兩個檔案（x360ce.ini/xinput.dll）放進遊戲資料夾的根目錄即可   此範例檔案預設搖桿資訊  A0~A1 － 為左搖桿的x，y A2~A3 － 為右搖桿的x，y D2~D5 － 為PS搖桿的右側功能鍵 D6~D9 － 為PS搖桿的左側方向鍵 D10~D11 － 為PS搖桿的L1R1 D12 － select A4 － start A5 － home 但由於是模擬成xbox的手把，故可自由接線，再由x360ce中直接[Record]即可 若是腳位不夠可自行替換成mega板    ","date":"2020-04-09T08:16:57+08:00","permalink":"https://blog.smallten.tk/p/arduino-02/","title":"Arduino-02：UNOJOY"},{"content":"官方IDE  此IDE由官方提供，可在此查看官網 下載－官方載點     VSCode + PlatformIO  先下載 VSCode 再安裝 PlatformIO 的插件     ","date":"2020-04-09T08:08:43+08:00","permalink":"https://blog.smallten.tk/p/arduino-01/","title":"Arduino-01：安裝IDE"}]