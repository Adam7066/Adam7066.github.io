[{"content":"ç«¶è³½ç°¡ä»‹  NCPC åˆè³½æ—¥æœŸï¼š2021/10/02  æˆç¸¾  æ ¡å…§ï¼š7 / 12 å…¨é«”ï¼š26 / 166  å¿ƒå¾—æ–‡  \n  é€™æ®µæ™‚é–“çœŸçš„æœ‰é»å¿™éé ­äº†\n å®‰æ’ CTF è®€æ›¸æœƒçš„èª²è¡¨ï¼ˆå˜¿å˜¿ï¼Œé‚„å»è·Ÿ Lç´€ æ•™æˆè¦åˆ°äº†ä¸€å ‚èª²ï¼Œå¸Œæœ›åˆ°æ™‚ä»–ä¸æœƒæœ‰çªç™¼çš„äº‹æƒ…ï¼Œè€Œæ˜¯èƒ½æ­£å¸¸çš„å‡ºå¸­è¬›èª²ï¼‰ï¼Œä¹Ÿè·Ÿå­¸é•·ä¸€èµ·åƒåŠ äº†ç¤¾åœ˜å¹¹éƒ¨åŸ¹è¨“çš„ç ”ç¿’ã€‚ å”åŠ©ä»¥å‰çš„é«˜ä¸­è¾¦ç†äº†å­¸ç§‘èƒ½åŠ›ç«¶è³½çš„æ ¡å…§åˆè³½ï¼Œä¸åªå¾å ±åç°¡ç« åˆ°è¡¨å–®ï¼Œé‚„æœ‰ç«¶è³½çš„å¹³å°ä»¥åŠé¡Œç›®ï¼Œé€™è£¡è¦ç‰¹åˆ¥çš„æ„Ÿè¬ä¸€èµ·é™ªæˆ‘ç˜‹ç‹‚çš„æœ‹æœ‹ è˜‡å­æ¬Šï¼Œä½†ä¸å¾—ä¸èªªï¼Œå­¸å¼Ÿå€‘é‚„å¾—å¤šå¤šåŠ æ²¹å‘€ï¼Œæœ‰æ©Ÿæœƒã€æ™‚é–“çš„è©±å†å›å»è¾¦ç ”ç¿’èª²ç¨‹å§ï¼ æˆ‘è¦å°å°çš„æŠ±æ€¨ä¸€ä¸‹ï¼Œå­¸æ ¡çš„é¸èª²ç³»çµ±  åˆ°åº•è¦å¤šä¹…æ‰æœ‰æ©Ÿæœƒçœ‹åˆ°å®ƒæ›´æ–°ï¼Ÿ(æœ‰æ™‚é–“å»å¼„é‚£ä¸€é»éƒ½ä¸å‹å–„çš„æ‰‹æ©Ÿç‰ˆï¼Œä¸å¦‚å»é‡æ§‹æ•´å€‹ç³»çµ±ã€‚) ä¸è¦å†äººå·¥åˆ†æµäº†ï¼Œå¾ˆæ™ºéšœã€‚ å¥½å¥½åšé˜² Bot ä¸è¡Œå—ï¼Ÿç”¨é‚£è®“äººå¾ˆç„¡è¨€çš„é©—è­‰ç¢¼è¨­è¨ˆï¼Œæ•´å€‹å‚»çœ¼ã€‚ï¼ˆæ‰“è‹±æ–‡é‚„æœƒæ¯”æ‰“æ•¸å­—çš„å¤šæ‰“å¹¾å€‹å­—ï¼‰ ç³»çµ±åˆ†ç™¼çš„éƒ¨ä»½ï¼Œåˆ°åº•ç‚ºä»€éº¼è¦é‚£éº¼ä¹…æ‰å…¬ä½ˆï¼Œåˆä¸æ˜¯ç”¨ä¸Šå¤å¹´ä»£çš„é›»è…¦ï¼Œæœ‰å…§å¹•å—ï¼Ÿï¼ˆæ±‚å…«å¦ äºŒéšé¸èª²ä»¥å‰æ˜¯ä¸æ˜¯ç›´æ¥æ¶èª²çš„å‘€ï¼Œæ•™ç¨‹ä¸€éšç”Ÿï¼Œæœ€é«˜èƒ½é¸ 6 å­¸åˆ†ï¼Œä½†ç”¨å¿—é¡˜åˆ†ç™¼çš„ï¼Œä½†å¿—é¡˜åªèƒ½å¡«åˆ° 6 å­¸åˆ†ï¼Œé€™æ¨£æ ¹æœ¬åˆ†ä¸åˆ°å‘€ï¼Œå‚»çœ¼ï½ï½ æœ€é‡è¦çš„æ˜¯ï¼Œæˆ‘ç¬¬ä¸€å€‹é¸èª²ï¼Œæ¯”æˆ‘æ™šæ¶èª²çš„åŒå­¸éƒ½ä¸€ä¸€æ¶åˆ°ï¼ˆä»–å€‘åœ¨ä¸åŒçš„ server ä¸Šï¼Œå°±æ™ºéšœçš„äººå·¥åˆ†æµå•é¡Œï¼‰ï¼Œæˆ‘å»åªèƒ½çœ‹ä½ å¯«ç™»è¨˜ä¸­ï¼Œç„¶å¾Œæ…¢æ…¢ç­‰ï¼Œç›´åˆ°æœ€å¾Œè·Ÿæˆ‘èªªæ»¿é¡ï¼Œæ˜¯æƒ³æ€æ¨£å•¦ ğŸ˜¡ğŸ˜¡ ï¼Œä½†æ„Ÿè¬èº«æ—çš„æœ‹æœ‹å€‘é¡˜æ„è·Ÿæˆ‘ä¸€èµ·å»ä¿®æ—©å…«çš„èª²ç¨‹ï¼ˆæŠŠå¤§å­¸å¿µåˆ°è®Šé«˜ä¸­ï¼‰ã€‚ æˆ‘çœŸçš„è®Šå­¸åˆ†å­¤å…’äº†ğŸ˜­ğŸ˜­   çµ‚æ–¼æ¶åˆ°ç–«è‹—äº†ï¼Œä½†é€±æ—¥å›è‡ºå—ï¼Œç¦®æ‹œä¸€æ‰“ç–«è‹—ï¼Œç¦®æ‹œä¸‰ä¸€é€€ç‡’å°±åˆé‡å›åŒ—éƒ¨ï¼Œé€±å…­åˆæ‰“ NCPC çš„åˆè³½ï¼Œæ•´å€‹ç˜‹äº†ï½ï½    çµ‚æ–¼è¦ä¾†èªçœŸæ‰“è©²æœ‰çš„å¿ƒå¾—æ–‡äº†ï¼Œé€™æ¬¡çš„ç«¶è³½æˆ‘å€‘éšŠä¼çµ‚æ–¼å¥½ä¸å®¹æ˜“çµ„æˆäº†ï¼ˆæ–‡å…ƒåŸæœ¬å› ç‚ºèº«å¿ƒç‹€æ…‹å•é¡Œæ²’æœ‰è¦æ‰“äº†ï¼‰ï¼Œä½†åˆ°æ¯”è³½çš„å‰ä¸€å¤©ï¼Œæˆ‘å€‘çš„å­æ¬Šæœ‹æœ‹å»è…¸èƒƒç‚(å°·å°¬)ï¼Œè€Œæ–‡å…ƒæœ¬ä¾†å°±æ˜¯è¢«æˆ‘å€‘æŠ“ä¾†ä¸€èµ·ç©çš„è€Œå·²(ç•¢ç«Ÿä»–ä¾ç„¶å¾—åƒè‘¡è„å£å‘³çš„æ›¼é™€ç ï¼Ÿ)ï¼Œè€Œæˆ‘å‰ä¸€æ™šä¹Ÿæƒ³åˆ°ä¸€å †ä¸æƒ³å»æƒ³çš„æ±è¥¿ï¼Œä¹Ÿæ²’ç¡åˆ°ç‰¹åˆ¥å¥½\u0026hellip;å”‰ï¼Œæ•´å€‹ç™¼èŠ¬ï¼ˆæ–‡å…ƒèªï¼Œå’¦ï¼Ÿ\n  å¥½å•¦ï¼Œé›–ç„¶é€™æ¬¡åˆè·Ÿ NCPC çš„æ±ºè³½æ“¦èº«è€Œéï¼Œæˆ‘æ˜¯ä¸æ˜¯çœŸçš„æœ‰è¬å¹´è€äºŒçš„å‘½å‘€ï¼Ÿï¼ˆåˆè³½æ ¡å…§å–åˆ°ç¬¬å…­åï¼‰ï¼Œä½†æ˜¯é€™ä¸€æ¬¡çš„ç«¶è³½æ˜¯çœŸçš„æ‰“çš„éå¸¸çš„é–‹å¿ƒï¼ˆè³½å‰æ¸¬æ©Ÿéƒ¨ä»½ã€æ²’æœ‰å°è¡¨æ©Ÿä»¥åŠé»å¿ƒé™¤å¤–ï¼‰ï¼Œæ°´é¡Œæˆ‘ä¾èˆŠæ˜¯ç©©ç©©çš„ 1 try å°±è§£æ‰è²»æ™‚ä¹Ÿä¸é•·ï¼Œå…¶ä¸­æœ‰ä¸€é¡Œæ–‡å…ƒæå‡ºæ¨¡é‹ç®—ï¼Œæˆ‘æƒ³åˆ°å¦‚ä½•æ­é…å‰ç¶´å’Œä½¿ç”¨ï¼Œå°± AC äº†ï¼Œæ’’èŠ±ï¼ˆä½†æœ‰äº›éšŠä¼æœ‰å¯«éä¸€æ¨£çš„é¡Œç›®äº†ï¼Œæ‰€ä»¥éå¸¸çš„æ—©å°±è§£å‡ºä¾†äº† QAQ)ï¼Œæœ‰ä¸€é¡Œæˆ‘çš„æƒ³æ³•æ˜¯å°çš„äº†ï¼Œä½†å­æ¬Šåˆ»å¾ŒåŠçš„éƒ¨ä»½æ™‚ä¸€å€‹è¿´åœˆå¯«éŒ¯äº†ï¼Œæœ€å¾Œä¹Ÿæœ‰é™¤éŒ¯é™¤å‡ºä¾†ï¼Œæ£’æ£’çš„ï½ï½ï¼ˆé€™æ¬¡æœ‰çœ‹çš„æ‰€æœ‰é¡Œç›®éƒ½æœ‰å¥½å¥½çš„è§£å‡ºä¾†å‘¢ï¼ï¼‰\n  æ•´é«”ä¾†èªªï¼Œé€™æ¬¡ç«¶è³½è®“æˆ‘äº«å—åˆ°äº†ä¸åªæœ‰ç·Šå¼µçš„æ°£æ°›ï¼Œé‚„æœ‰åœ˜éšŠè§£å‡ºé¡Œæ™‚çš„æ„‰æ‚…ï¼Œæ‰€ä»¥é›–ç„¶æ²’æœ‰é€²æ±ºè³½ä¸€æ¨£å¾ˆå¯æƒœï¼Œä½†æˆ‘å€‘å¿—åœ¨åƒèˆ‡å˜›ï¼ˆå¼±è€…çš„ç™¼è¨€ğŸ˜­ğŸ˜­ï¼‰ï¼Œä¸ä¹…å¾Œçš„ TOPC ä¹Ÿå¾—ç¹¼çºŒåŠ æ²¹å‘¢ï¼\n  å¾Œè¨˜  åˆ°åº•ç‚ºä»€éº¼è¦åœ¨ç”Ÿæ—¥ç•¶å¤©æ‰“æ¯”è³½å‘¢ï¼Œç”Ÿæ—¥ä¸å°±æ‡‰è©²å¥½å¥½çš„èººåœ¨åºŠä¸Šè€å»¢åˆ°æ¥µè‡´å—ï¼ŸçœŸæ˜¯çš„ã€‚å¥½å•¦ï¼Œé€™é‚Šä¹Ÿè¦æ„Ÿè¬æˆ‘å®¶é¥…é ­é ­çš„ç”Ÿæ—¥ç¦®ç‰©ï¼Œé›–ç„¶é²äº†ä¸€å¤©ï¼ŒåŸå› æ˜¯å¡ç‰‡æ²’å¯«å¥½ï¼Œï¼ˆå’¦ï½ï¼‰ï¼Œä½†éƒ½æ˜¯æˆ‘å–œæ­¡çš„æ±è¥¿å‘¢(æœ‰æœ€å¯æ„›çš„å°åï¼Œé‚„æœ‰å²èŠå§†)ï¼Œå¤ªé–‹å¿ƒäº†å§ï¼ï¼æˆ‘è‡ªå·±ä¹Ÿé€äº†è‡ªå·±ä¸å°‘æ±è¥¿ï¼ˆå–®ç´”æ‰¾ç†ç”±è²·æ±è¥¿ï¼Œèª¤///ï¼‰å…¶ä¸­æœ‰å¤§å°å…©éš»å¯æ„›çš„å°åå‘¦ï¼Œé–‹å¿ƒï½ï½     ","date":"2021-10-04T09:15:29+08:00","permalink":"https://blog.smallten.tk/p/experience-02/","title":"2021 NCPC åˆè³½"},{"content":"ä¸»é¡Œ  æœ€çŸ­è·¯å¾‘  æœ€çŸ­è·¯å¾‘æ¨¡æ¿ Dijkstraâ€™s  ä¸èƒ½æœ‰è² é‚Š  int vn; // vertex num struct Edge { int w, idx; bool operator \u0026lt; (const Edge \u0026amp;r) const { return w \u0026gt; r.w; } }; vector\u0026lt;Edge\u0026gt; adj[maxv]; void dijkstra(int s) { vector\u0026lt;bool\u0026gt; vis(vn, false); vector\u0026lt;int\u0026gt; dist(vn, INF); dist[s] = 0; priority_queue\u0026lt;Edge\u0026gt; pq; pq.emplace(0, s); while(!pq.empty()) { int u = pq.top().idx; pq.pop(); if(vis[u]) continue; vis[u] = true; for(auto v : adj[u]) { if(dist[v.idx] \u0026gt; dist[u] + v.w) { dist[v.idx] = dist[u] + v.w; pq.emplace(dist[v.idx], v.idx); } } } } Bellman-Ford  å¯ä»¥æª¢æŸ¥æ˜¯å¦æœ‰ç’°  int vn; // vertex num struct Edge { int idx, w; }; vector\u0026lt;Edge\u0026gt; adj[maxv]; bool bellmanford(int s) { //return true if negative cycle exists;  int cnt = 0; bool update = false; vector\u0026lt;int\u0026gt; dist(vn, INF); dist[s] = 0; do { if(++cnt == vn) return true; update = false; for(int u = 0; u \u0026lt; vn; ++u) { if(dist[u] == INF) continue; for(auto v : adj[u]) { if(dist[v.idx] \u0026gt; dist[u] + v.w) { update = true; dist[v.idx] = dist[u] + v.w; } } } } while(update); return false; } Floyd-Warshall int dist[MAX_V][MAX_V]; for(int k = 0; k \u0026lt; vn; ++k) for(int i = 0; i \u0026lt; vn; ++i) for(int j = 0; j \u0026lt; vn; ++j) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); é¡Œç›®  Virtual Judge é¡Œç›®åˆ—è¡¨èˆ‡æç¤º    é¡Œç›® é¡Œç›®éœ€æ±‚ é›£åº¦     UVa 929 çµ¦ä¸€å€‹äºŒç¶­è¿·å®®ï¼Œæ±‚å·¦ä¸Šèµ°åˆ°å³ä¸‹çš„æœ€å°‘æˆæœ¬ï¼ˆæœ€çŸ­è·¯å¾‘ï¼‰ã€‚ å–®æºæ¨¡æ¿é¡Œ   UVa 10986 çµ¦ä¸€å€‹ç„¡å‘å¸¶æ¬Šåœ–ï¼Œæ±‚æŒ‡å®šå…©é»é–“çš„æœ€çŸ­è·¯å¾‘é•·ã€‚ å–®æºæ¨¡æ¿é¡Œ   UVa 10000 çµ¦ä¸€å€‹æœ‰å‘ç„¡ç’°åœ–ï¼Œæ±‚æŒ‡å®šå…©é»é–“çš„æœ€é•·è·¯å¾‘ã€‚ å¤šç¨®ä½œæ³•   UVa 558 çµ¦å®šä¸€å€‹æœ‰å‘å¸¶æ¬Šåœ–ï¼ˆé»‘æ´é€šé“ç‚ºé‚Šï¼‰ï¼Œå•æ˜¯å¦å­˜åœ¨è² ç’°ï¼ˆå¯å›åˆ°ç„¡é™é çš„éå»ï¼‰ã€‚ BF   UVa 10801 çµ¦å®šé›»æ¢¯ç³»çµ±èˆ‡ç§»å‹•æ™‚é–“ï¼Œè‹¥è½‰æ›é›»æ¢¯éœ€ 60 ç§’ï¼Œå•å»æŸæ¨“çš„æœ€çŸ­æ™‚é–“ã€‚ å–®æºå°è®ŠåŒ–   UVa 821 çµ¦ä¸€å€‹ç„¡å‘ç„¡æ¬Šåœ–ï¼Œæ±‚æ‰€æœ‰å…©é»é–“æœ€çŸ­è·¯å¾‘é•·çš„å¹³å‡å€¼ã€‚ FW æ¨¡æ¿é¡Œ   UVa 10048 çµ¦ä¸€å€‹ç„¡å‘å¸¶æ¬Šåœ–ï¼Œæ±‚æŒ‡å®šå…©é»é–“è·¯å¾‘ä¸Šæœ€å¤§é‚Šæ¬Šçš„æœ€å°å€¼ã€‚ FW è®ŠåŒ–   UVa 658 çµ¦ä¸€å †ä¿®è£œç¨‹å¼çš„å®‰è£å‰å¾Œç‹€æ…‹ï¼Œå•æœ€å°‘è¦å®‰è£å¤šå°‘æ¬¡ä¿®è£œç¨‹å¼å¯ä»¥ä¿®å¥½æ‰€æœ‰ bugã€‚ è®ŠåŒ–é¡Œ   UVa 11374 çµ¦ç¶“æ¿Ÿç·šå’Œå•†æ¥­ç·šå…©å¥—æ·é‹è·¯ç·šåœ–çš„è¡Œé§›æ™‚é–“ï¼Œåœ¨å•†æ¥­ç·šåªèƒ½æ­ä¸€æ®µçš„é™åˆ¶ä¸‹ï¼Œæ±‚æŒ‡å®šå…©é»é–“çš„æœ€å¿«è·¯ç·šã€‚ è®ŠåŒ–é¡Œ   UVa 10917 é¡Œç›®ä¸é•·ï¼Œè‡ªå·±è®€è®€çœ‹ã€‚ è®ŠåŒ–é¡Œ      åƒè€ƒä½œæ³• A - Number Maze #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using tiii = tuple\u0026lt;int, int, int\u0026gt;; int d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(m, 0)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; val(n, vector\u0026lt;int\u0026gt;(m, -1)); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; vis(n, vector\u0026lt;bool\u0026gt;(m, false)); priority_queue\u0026lt;tiii, vector\u0026lt;tiii\u0026gt;, greater\u0026lt;tiii\u0026gt;\u0026gt; pq; for(int i = 0; i \u0026lt; n; ++i) for(int j = 0; j \u0026lt; m; ++j) cin \u0026gt;\u0026gt; g[i][j]; val[0][0] = g[0][0]; pq.push(make_tuple(g[0][0], 0, 0)); while(!pq.empty()) { int v, x, y; tie(v, x, y) = pq.top(); pq.pop(); vis[x][y] = true; for(int i = 0; i \u0026lt; 4; ++i) { int nx = x + d[i][0], ny = y + d[i][1]; if(nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; n \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; m \u0026amp;\u0026amp; !vis[nx][ny]) { int tmp = v + g[nx][ny]; if(val[nx][ny] == -1 || val[nx][ny] \u0026gt; tmp) { val[nx][ny] = tmp; pq.push(make_tuple(tmp, nx, ny)); } } } } cout \u0026lt;\u0026lt; val[n - 1][m - 1] \u0026lt;\u0026lt; endl; } return 0; } B - Sending email #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using pii = pair\u0026lt;int, int\u0026gt;; using plli = pair\u0026lt;long long, int\u0026gt;; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; for(int ca = 1; ca \u0026lt;= T; ++ca) { cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; int n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; vector\u0026lt;pii\u0026gt; g[n]; vector\u0026lt;long long\u0026gt; val(n, INF); vector\u0026lt;bool\u0026gt; vis(n, false); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; g[a].push_back({b, c}); g[b].push_back({a, c}); } priority_queue\u0026lt;plli, vector\u0026lt;plli\u0026gt;, greater\u0026lt;plli\u0026gt;\u0026gt; pq; val[s] = 0; pq.push({0, s}); while(!pq.empty()) { int v = pq.top().first, x = pq.top().second; pq.pop(); if(val[x] \u0026lt; v) continue; for(auto it : g[x]) { if(val[it.first] \u0026gt; val[x] + it.second) { val[it.first] = val[x] + it.second; pq.push({val[it.first], it.first}); } } } if(val[t] == INF) cout \u0026lt;\u0026lt; \u0026#34;unreachable\\n\u0026#34;; else cout \u0026lt;\u0026lt; val[t] \u0026lt;\u0026lt; endl; } return 0; } C - Longest Paths #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct edge { int u, v; }; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int n, cnt = 0; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { int s; cin \u0026gt;\u0026gt; s; int p, q; vector\u0026lt;edge\u0026gt; g; vector\u0026lt;int\u0026gt; val(n + 1, INF); while(cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q \u0026amp;\u0026amp; !(p == 0 \u0026amp;\u0026amp; q == 0)) g.push_back({p, q}); val[s] = 0; for(int i = 0; i \u0026lt; n; ++i) { for(auto it : g) { if(val[it.v] \u0026gt; val[it.u] - 1 \u0026amp;\u0026amp; val[it.u] != INF) val[it.v] = val[it.u] - 1; } } int en, ans = 0; for(int i = 1; i \u0026lt;= n; ++i) { if(val[i] \u0026lt; ans) { ans = val[i]; en = i; } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++cnt \u0026lt;\u0026lt; \u0026#34;: The longest path from \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; has length \u0026#34; \u0026lt;\u0026lt; -1 * ans \u0026lt;\u0026lt; \u0026#34;, finishing at \u0026#34; \u0026lt;\u0026lt; en \u0026lt;\u0026lt; \u0026#34;.\\n\\n\u0026#34;; } return 0; } D - Wormholes #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n, m; struct edge { int u, v, w; }; bool Bellman_Ford(vector\u0026lt;edge\u0026gt; \u0026amp;ve, vector\u0026lt;int\u0026gt; val) { for(int i = 0; i \u0026lt; n; ++i) { bool flag = false; for(int j = 0; j \u0026lt; m; ++j) { if(val[ve[j].v] \u0026gt; val[ve[j].u] + ve[j].w \u0026amp;\u0026amp; val[ve[j].u] != INF) { val[ve[j].v] = val[ve[j].u] + ve[j].w; flag = true; } } if(!flag) return true; if(i == n - 1 \u0026amp;\u0026amp; flag) return false; } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; val(n, INF); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; ve.push_back({a, b, c}); } val[0] = 0; if(Bellman_Ford(ve, val)) cout \u0026lt;\u0026lt; \u0026#34;not possible\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;possible\\n\u0026#34;; } return 0; } E - Lift Hopping #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int n, tar; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; tar) { vector\u0026lt;int\u0026gt; vt(n), va; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; w(100, vector\u0026lt;int\u0026gt;(100, INF)); for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; vt[i]; cin.ignore(100, \u0026#39;\\n\u0026#39;); for(int i = 0; i \u0026lt; n; ++i) { va.clear(); string s; getline(cin, s); stringstream ss(s); int tmp; while(ss \u0026gt;\u0026gt; tmp) va.push_back(tmp); for(int j = 0; j \u0026lt; va.size(); ++j) { for(int k = j + 1; k \u0026lt; va.size(); ++k) { int dis = abs(va[j] - va[k]) * vt[i]; if(dis \u0026lt; w[va[j]][va[k]]) w[va[j]][va[k]] = w[va[k]][va[j]] = dis; } } } vector\u0026lt;bool\u0026gt; vis(n, false); vector\u0026lt;int\u0026gt; d(100, INF); d[0] = 0; for(int i = 0; i \u0026lt; 100; ++i) { int x, m = INF; for(int y = 0; y \u0026lt; 100; ++y) { if(!vis[y] \u0026amp;\u0026amp; d[y] \u0026lt; m) { m = d[y]; x = y; } } vis[x] = true; for(int y = 0; y \u0026lt; 100; ++y) { if(d[y] \u0026gt; d[x] + w[x][y] + 60) d[y] = d[x] + w[x][y] + 60; } } if(d[tar] == INF) cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\\n\u0026#34;; else { if(tar == 0) cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; else cout \u0026lt;\u0026lt; d[tar] - 60 \u0026lt;\u0026lt; endl; } } return 0; } F - Page Hopping #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 map\u0026lt;int, int\u0026gt; m; void memNum(int n) { if(m.find(n) == m.end()) m[n] = m.size(); } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int ca = 1, x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026amp;\u0026amp; !(x == 0 \u0026amp;\u0026amp; y == 0)) { m.clear(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(110, vector\u0026lt;int\u0026gt;(110, INF)); for(int i = 0; i \u0026lt; 110; ++i) g[i][i] = 0; memNum(x); memNum(y); g[m[x]][m[y]] = 1; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026amp;\u0026amp; !(x == 0 \u0026amp;\u0026amp; y == 0)) { memNum(x); memNum(y); g[m[x]][m[y]] = 1; } int cnt = 0, sz = m.size(); for(int k = 0; k \u0026lt; sz; ++k) { for(int i = 0; i \u0026lt; sz; ++i) { for(int j = 0; j \u0026lt; sz; ++j) { g[i][j] = min(g[i][j], g[i][k] + g[k][j]); } } } for(int i = 0; i \u0026lt; sz; ++i) { for(int j = 0; j \u0026lt; sz; ++j) { if(g[i][j] != INF) cnt += g[i][j]; } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ca++ \u0026lt;\u0026lt; \u0026#34;: average length between pages = \u0026#34;; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; (double)cnt / (sz * (sz - 1)) \u0026lt;\u0026lt; \u0026#34; clicks\\n\u0026#34;; } return 0; } G - Audiophobia #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int c, s, q, ca = 1; while(cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; s \u0026gt;\u0026gt; q \u0026amp;\u0026amp; !(c == 0 \u0026amp;\u0026amp; s == 0 \u0026amp;\u0026amp; q == 0)) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; path(1005, vector\u0026lt;int\u0026gt;(1005, INF)); int c1, c2, d; for(int i = 0; i \u0026lt; s; ++i) { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; c2 \u0026gt;\u0026gt; d; path[c1][c2] = path[c2][c1] = d; } for(int k = 1; k \u0026lt;= c; ++k) { for(int i = 1; i \u0026lt;= c; ++i) { for(int j = 1; j \u0026lt;= c; ++j) { path[i][j] = min(path[i][j], max(path[i][k], path[k][j])); } } } if(ca \u0026gt; 1) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; ca++ \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; q; ++i) { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; c2; if(path[c1][c2] != INF) cout \u0026lt;\u0026lt; path[c1][c2] \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;no path\\n\u0026#34;; } } return 0; } H - It\u0026rsquo;s not a Bug, it\u0026rsquo;s a Feature! #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 #define maxn (1\u0026lt;\u0026lt;20) + 10 #define maxm 110 int n, m, minTime; bool vis[maxn]; struct node { int time; int a1, a2, b1, b2; } a[maxm]; struct pqNode { int u, d; bool operator \u0026lt; (const pqNode \u0026amp;r) const { return d \u0026gt; r.d; } }; bool dijkstra() { priority_queue\u0026lt;pqNode\u0026gt; pq; pq.push({(1 \u0026lt;\u0026lt; n) - 1, 0}); while(!pq.empty()) { pqNode x = pq.top(); pq.pop(); if(x.u == 0) { minTime = x.d; return true; } if(vis[x.u]) continue; vis[x.u] = true; for(int i = 0; i \u0026lt; m; ++i) { if((x.u \u0026amp; a[i].a1) == a[i].a1 \u0026amp;\u0026amp; (~x.u \u0026amp; a[i].a2) == a[i].a2) { int t = x.u | a[i].b1; t = t \u0026amp; ~a[i].b2; pq.push({t, x.d + a[i].time}); } } } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int ca = 1; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; !(n == 0 \u0026amp;\u0026amp; m == 0)) { cout \u0026lt;\u0026lt; \u0026#34;Product \u0026#34; \u0026lt;\u0026lt; ca++ \u0026lt;\u0026lt; endl; memset(vis, false, sizeof(vis)); for(int i = 0; i \u0026lt;= m; ++i) a[i].time = a[i].a1 = a[i].a2 = a[i].b1 = a[i].b2 = 0; for(int i = 0; i \u0026lt; m; ++i) { int t; string s1, s2; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; for(int j = 0; j \u0026lt; n; ++j) { a[i].time = t; if(s1[n - 1 - j] == \u0026#39;+\u0026#39;) a[i].a1 = (a[i].a1 | (1 \u0026lt;\u0026lt; j)); if(s1[n - 1 - j] == \u0026#39;-\u0026#39;) a[i].a2 = (a[i].a2 | (1 \u0026lt;\u0026lt; j)); if(s2[n - 1 - j] == \u0026#39;+\u0026#39;) a[i].b1 = (a[i].b1 | (1 \u0026lt;\u0026lt; j)); if(s2[n - 1 - j] == \u0026#39;-\u0026#39;) a[i].b2 = (a[i].b2 | (1 \u0026lt;\u0026lt; j)); } } if(dijkstra()) cout \u0026lt;\u0026lt; \u0026#34;Fastest sequence takes \u0026#34; \u0026lt;\u0026lt; minTime \u0026lt;\u0026lt; \u0026#34; seconds.\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bugs cannot be fixed.\\n\u0026#34;; cout \u0026lt;\u0026lt; endl; } return 0; } I - Airport Express #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 #define maxn 505 struct edge { int u, v, dist; }; struct node { int d, u; bool operator \u0026lt; (const node \u0026amp;r) const { return d \u0026gt; r.d; } }; vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; g[maxn], path1[maxn], path2[maxn]; bool done[maxn]; int d[maxn], p[maxn], d1[maxn], d2[maxn]; int ca = 0, n, s, e, m, k; void dijkstra(int s, int *dist, vector\u0026lt;int\u0026gt; *paths) { priority_queue\u0026lt;node\u0026gt; pq; for(int i = 0; i \u0026lt; n; ++i) d[i] = INF; d[s] = 0; memset(done, 0, sizeof(done)); pq.push({0, s}); while(!pq.empty()) { node x = pq.top(); pq.pop(); if(done[x.u]) continue; done[x.u] = true; for(int i = 0; i \u0026lt; g[x.u].size(); ++i) { edge \u0026amp;e = ve[g[x.u][i]]; if(d[e.v] \u0026gt; d[x.u] + e.dist) { d[e.v] = d[x.u] + e.dist; p[e.v] = g[x.u][i]; pq.push({d[e.v], e.v}); } } } for(int i = 0; i \u0026lt; n; ++i) { dist[i] = d[i]; paths[i].clear(); int t = i; paths[i].push_back(t); while(t != s) { paths[i].push_back(ve[p[t]].u); t = ve[p[t]].u; } reverse(paths[i].begin(), paths[i].end()); } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; m) { for(int i = 0; i \u0026lt; n; ++i) g[i].clear(); ve.clear(); --s; --e; for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; --a; --b; ve.push_back({a, b, c}); g[a].push_back(ve.size()-1); ve.push_back({b, a, c}); g[b].push_back(ve.size()-1); } dijkstra(s, d1, path1); dijkstra(e, d2, path2); int ans = d1[e]; vector\u0026lt;int\u0026gt; pp = path1[e]; int midpoint = -1; cin \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; k; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; --a; --b; for(int j = 0; j \u0026lt; 2; ++j) { if(d1[a] + d2[b] + c \u0026lt; ans) { ans = d1[a] + d2[b] + c; pp = path1[a]; for(int p = path2[b].size() - 1; p \u0026gt;= 0; --p) pp.push_back(path2[b][p]); midpoint = a; } swap(a, b); } } if(ca++ != 0) cout \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; pp.size() - 1; ++i) cout \u0026lt;\u0026lt; pp[i] + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; e + 1 \u0026lt;\u0026lt; endl; if(midpoint == -1) cout \u0026lt;\u0026lt; \u0026#34;Ticket Not Used\\n\u0026#34;; else cout \u0026lt;\u0026lt; midpoint + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } J - Walk Through the Forest #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; link[1001]; vector\u0026lt;int\u0026gt; rebuild[1001]; int distant[1001]; int dp[1001]; bool vis[1001]; int n, m; struct node { int dis, index; bool operator \u0026lt; (const node \u0026amp;r) const { return dis \u0026gt; r.dis; } }; int dfs(int now) { if(now == 1) return 1; if(dp[now] == -1) { dp[now] = 0; for(auto i : rebuild[now]) dp[now] += dfs(i); } return dp[now]; } void dijkstra() { priority_queue\u0026lt;node\u0026gt; pq; pq.push({0, 1}); int cur; distant[1] = 0; while(!pq.empty()) { cur = pq.top().index; pq.pop(); if(vis[cur]) continue; vis[cur] = 1; for(auto i : link[cur]) { int next = i.first; int dis = i.second; if(distant[next] \u0026gt; distant[cur] + dis) { distant[next] = distant[cur] + dis; pq.push({distant[next], next}); } } } } void build() { memset(dp, -1, sizeof(dp)); int next, dis; for(int i = 0; i \u0026lt; n; ++i) { rebuild[i].clear(); for(auto j : link[i]) if(distant[i] \u0026gt; distant[j.first]) rebuild[i].emplace_back(j.first); } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n) { memset(link, 0, sizeof(link)); memset(vis, 0, sizeof(vis)); for(int i = 0; i \u0026lt; n; ++i) distant[i] = INF; while(m--) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; link[--a].push_back({--b, c}); link[b].push_back({a, c}); } dijkstra(); build(); cout \u0026lt;\u0026lt; dfs(0) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2021-08-18T16:02:47+08:00","permalink":"https://blog.smallten.tk/p/star_coder-07/","title":"StarCoder2021æš‘è¨“ï¼šWeek06"},{"content":"å‰è¨€ â€ƒæœ‰äº†æ¡Œé¢ç’°å¢ƒï¼Œè»Ÿé«”ä¹Ÿä¸å¯ä»¥ç¼ºå°‘å§ï¼Œå› æ­¤é€™è£¡æœƒç´€éŒ„ä¸€ä¸‹ç”¨åˆ°çš„è»Ÿé«”çš„å®‰è£æ–¹å¼\næ•™å­¸é–‹å§‹ Yay  Yay çš„ Github  pacman -S --needed base-devel git go git clone https://aur.archlinux.org/yay.git cd yay makepkg -si ä¸­æ–‡è¼¸å…¥æ³•  ä¸­æ–‡è¼¸å…¥æ³• Wiki é€™é‚Šæˆ‘é¸æ“‡äº†ä¹‹å‰åœ¨ Ubuntu ç”¨ç¿’æ…£çš„ ibus (IBus (ç®€ä½“ä¸­æ–‡) Wiki)  å®‰è£æ³¨éŸ³è¼¸å…¥æ³•ï¼špacman -S ibus ibus-chewing vim /etc/environment GTK_IM_MODULE=ibus QT_IM_MODULE=ibus XMODIFIERS=@im=ibus  vim ~/.xprofile export CTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -drxR  é‡æ–°å•Ÿå‹•    Oh My Zsh  Oh My Zsh çš„ å®˜ç¶²ã€Github å®‰è£ zshï¼špacman -S zsh çœ‹ç³»çµ±æ˜¯å¦è£äº† zshï¼šcat /etc/shells åˆ‡æ› Shell ç‚º zshï¼šchsh -s /bin/zsh å®‰è£ Git ä»¥åŠ Curlï¼špacman -S git curl å®‰è£ oh-my-zshï¼šsh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; é…ç½®ä¸»é¡Œï¼Œæˆ‘é¸æ“‡çš„æ˜¯ powerlevel10k  å®‰è£ Nerd Fontså­—é«” # ä¸‹è¼‰å­—é«” mkdir -p ~/.local/share/fonts cd ~/.local/share/fonts \u0026amp;\u0026amp; curl -fLo \u0026#34;Droid Sans Mono for Powerline Nerd Font Complete.otf\u0026#34; https://github.com/ryanoasis/nerd-fonts/raw/master/patched-fonts/DroidSansMono/complete/Droid%20Sans%20Mono%20Nerd%20Font%20Complete.otf # å¿«å–å­—é«” fc-cache -vf ~/.local/share/fonts/ # æŸ¥çœ‹æ˜¯å¦å®‰è£æˆåŠŸ fc-list | grep -i droid  è¨­å®šçµ‚ç«¯å­—é«”  è¨­å®š -\u0026gt; ç·¨è¼¯ç›®å‰çš„è¨­å®šæª”\u0026hellip; -\u0026gt; å¤–è§€ -\u0026gt; å­—å‹ -\u0026gt; DroidSansMono Nerd Font   ä¸‹è¼‰ powerlevel10kï¼šgit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k ä¿®æ”¹ä¸»é¡Œï¼švim ~/.zshrc  ä¿®æ”¹ ZSH_THEME ç‚ºï¼šZSH_THEME=\u0026quot;powerlevel10k/powerlevel10k\u0026quot;   æ›´æ–°é…ç½®ï¼šsource .zshrc   å®‰è£æ’ä»¶  ä¸‹è¼‰ zsh-autosuggestionï¼šgit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions ä¸‹è¼‰ zsh-syntax-highlightingï¼šgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting ä¿®æ”¹ .zshrcï¼švim ~/.zshrc plugins=( git extract archlinux colored-man-pages zsh-syntax-highlighting zsh-autosuggestions )  æ›´æ–°é…ç½®ï¼šsource .zshrc    Vim é…ç½®  è«‹æŸ¥çœ‹ Use Vim as IDE  è—èŠ½è¨­ç½®  ä½¿ç”¨ Sony WH-1000XM4 æ¸¬è©¦å¯è¡Œ pacman -S bluez bluez-utils systemctl start bluetooth.service systemctl enable bluetooth.service pacman -S pulseaudio-bluetooth reboot   å…¶ä»–è»Ÿé«”  TLP pacman -S tlp systemctl enable --now tlp  Google Chromeï¼šyay -S google-chrome 1passwordï¼šyay -S 1password Neofetchï¼š pacman -S neofetch Keyringï¼špacman -S gnome-keyring  Seahorseï¼špacman -S seahorse   Visual Studio Codeï¼šyay -S visual-studio-code-bin  å¢åŠ åœ¨è³‡æ–™å¤¾ä¸Šå³éµé–‹å•Ÿçš„é¸é …ï¼švim /usr/share/kservices5/vscodehere.desktop [Desktop Entry] Type=Service X-KDE-ServiceTypes=KonqPopupMenu/Plugin MimeType=inode/directory; X-KDE-Priority=TopLevel Actions=openVSCodeHere; X-KDE-AuthorizeAction=shell_access [Desktop Action openVSCodeHere] TryExec=code Exec=code %f Icon=visual-studio-code Name=Open VS Code Here Comment=Opens a VS Code Instance in the current folder    Discordï¼špacman -S discord LibreOfficeï¼špacman -S libreoffice-still libreoffice-still-zh-tw Hugo-Extendedï¼šyay -S hugo-bin UxPlayï¼šç”¨æ–¼ iPad çš„è¢å¹•å…±äº«  å®‰è£ï¼š yay -S uxplay-git systemctl start avahi-daemon.service systemctl enable avahi-daemon.service  ä½¿ç”¨ï¼šuxplay    ","date":"2021-08-11T22:18:09+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-04/","title":"Arch Linux-04ï¼šåŸºæœ¬è»Ÿé«”å®‰è£"},{"content":"å‰è¨€ â€ƒåœ¨å®‰è£å®Œäº†ç³»çµ±ï¼Œä¹Ÿè¨­å®šäº†åŸºæœ¬é…ç½®å¾Œï¼Œæƒ³ç•¶ç„¶çˆ¾ï¼Œè©²ä¾†å®‰è£ä¸€å€‹æ¡Œé¢ç’°å¢ƒäº†å§ï¼Œå› æ­¤æ¥ä¸‹ä¾†å°‡å‘Šè¨´ä½ æ€éº¼å®‰è£ KDEã€‚\næ•™å­¸é–‹å§‹ åŸºæœ¬å®‰è£  å®‰è£ KDE  Arch Linux çš„ meta package èˆ‡ package group å®‰è£ Plasmaï¼špacman -S plasma-meta å®‰è£ KDE applicationsï¼špacman -S kde-applications   å®‰è£é¡¯ç¤ºç®¡ç†å™¨  é€™é‚Šæˆ‘å€‘å°‡ä½¿ç”¨ SDDMï¼špacman -S sddm è¨­å®šè‡ªå‹•å•Ÿå‹•ï¼šsystemctl enable sddm.service   å®‰è£çµ‚ç«¯æ¨¡æ“¬å™¨  é€™é‚Šæˆ‘å€‘ä½¿ç”¨ konsoleï¼špacman -S konsole å–œæ­¡ kitty çš„ä¹Ÿå¯å®‰è£ï¼špacman -S kitty   å®‰è£æ–‡ä»¶ç®¡ç†å™¨  é€™é‚Šæˆ‘å€‘ä½¿ç”¨ Dolphinï¼špacman -S dolphin   ä¸€äº›åŸºæœ¬è»Ÿé«”  ä¸­æ–‡å­—é«”ï¼špacman -S adobe-source-han-sans-tw-fonts   é‡æ–°å•Ÿå‹•ï¼šreboot  KDE ç¾åŒ–  åˆ‡æ›ç³»çµ±èªè¨€  ç³»çµ±è¨­å®š -\u0026gt; å€åŸŸè¨­å®š -\u0026gt;  èªè¨€ -\u0026gt; å¢åŠ èªè¨€\u0026hellip; -\u0026gt; ç¹é«”ä¸­æ–‡ -\u0026gt; è¨­ç‚ºé è¨­ -\u0026gt; å¥—ç”¨ Formats -\u0026gt; å€åŸŸ -\u0026gt; é¸æ“‡ å°ç£ - ç¹é«”ä¸­æ–‡ (zh_TW)     èª¿æ•´é¡¯ç¤ºè¨­å®š  ç³»çµ±è¨­å®š -\u0026gt; é¡¯ç¤ºèˆ‡è¢å¹• -\u0026gt;  é¡¯ç¤ºè¨­å®š -\u0026gt; å…¨åŸŸç¸®æ”¾æ¯”ä¾‹ -\u0026gt; 125% çµ„åˆå™¨ -\u0026gt;  ç¸®æ”¾æ–¹å¼ï¼šå¹³æ»‘ æˆåƒå¾Œç«¯ä»‹é¢ï¼šOpenGL 3.1 Latencyï¼šPrefer smoother animations       æ›´æ›ç³»çµ±ä¸»é¡Œ  ç³»çµ±è¨­å®š -\u0026gt; å¤–è§€ -\u0026gt;  Global Theme -\u0026gt; å–å¾—æ–°å…¨åŸŸä¸»é¡Œ -\u0026gt; Layan look and feel theme Icons -\u0026gt; å–å¾—æ–°åœ–ç¤º -\u0026gt; Tela dark     æ›´æ›æ¡Œå¸ƒ  åœ¨æ¡Œé¢å³éµ -\u0026gt; Configure Desktop and Wallpaper\u0026hellip; -\u0026gt; æ¡Œå¸ƒ -\u0026gt; å–å¾—æ–°æ¡Œå¸ƒ\u0026hellip; -\u0026gt; æ¡Œå¸ƒå‹æ…‹ï¼šå½±åƒ -\u0026gt; HD NO LOGO PL1591   Konsole ç¾åŒ–  è¨­å®š -\u0026gt;  é¡¯ç¤ºå·¥å…·åˆ— -\u0026gt; å–æ¶ˆ ä¸»å·¥å…·åˆ—ã€Session Toolbar çš„å‹¾é¸ ç·¨è¼¯ç›®å‰è¨­å®šæª” -\u0026gt; å¤–è§€ -\u0026gt; é…è‰²èˆ‡å­—å½¢ -\u0026gt; å–å¾—æ›´å¤š -\u0026gt; Sweet      ","date":"2021-08-11T21:55:25+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-03/","title":"Arch Linux-03ï¼šKDE"},{"content":"å‰è¨€ â€ƒåœ¨ Arch Linux-01ï¼šç³»çµ±å®‰è£ ä¸­ï¼Œå·²ç¶“ä»‹ç´¹äº†å¦‚ä½•å®Œæ•´çš„å®‰è£ä¸€å€‹åŸºç¤çš„ Arch Linux ç³»çµ±ï¼Œè€Œé€™éƒ¨åˆ†å°‡å»ä»‹ç´¹ä¸€äº›åŸºæœ¬çš„è¨­å®šæˆ–æ˜¯é©…å‹•çš„å®‰è£ã€‚\næ•™å­¸é–‹å§‹ æ–°å¢ä½¿ç”¨è€…  ç”±æ–¼ä¸æ‡‰è©²ä¸€ç›´ä½¿ç”¨ root å¸³è™Ÿï¼Œå› æ­¤æˆ‘å€‘ä¾†æ–°å¢ä¸€å€‹ä½¿ç”¨è€…å§ã€‚   æ–°å¢ä½¿ç”¨è€…ï¼šuseradd -m \u0026lt;user\u0026gt; ( \u0026lt;user\u0026gt; ç‚ºä½ è¦æ–°å¢çš„ç”¨æˆ¶åç¨±ï¼Œè«‹è‡ªè¡Œæ›´æ”¹ ) è¨­ç½®å¯†ç¢¼ï¼špasswd \u0026lt;user\u0026gt;  Sudo  Sudo Wiki å®‰è£ï¼špacman -S sudo å°‡ä½¿ç”¨è€…åŠ å…¥ï¼šusermod -aG wheel \u0026lt;user\u0026gt; ä½¿ç”¨ visudo  ç”±æ–¼é è¨­ä½¿ç”¨ viï¼Œä½†æˆ‘å€‘ä¹‹å‰æ˜¯ç”¨å®‰è£ vimï¼Œå› æ­¤è‡¨æ™‚çš„æ›´æ”¹å®ƒå§ï¼šEDITOR=vim visudo é€²å»å¾Œï¼Œæ‰¾åˆ° %wheel ALL=(ALL) ALL é€™è¡Œï¼Œç„¶å¾Œæ¶ˆæ‰è¨»è§£ä¸¦ä¸”å„²å­˜é›¢é–‹ã€‚    Xorg  Xorg Wiki å®‰è£ ï¼špacman -S xorg-server é©…å‹•å®‰è£  æŸ¥çœ‹é¡¯å¡é¡å‹ï¼šlspci -v | grep -A1 -e VGA -e 3D å®‰è£å°æ‡‰é©…å‹•ï¼Œè«‹ä¾ç…§æƒ…æ³è‡ªè¡Œæ›´æ”¹ ä»¥ä¸‹ç‚ºæˆ‘çš„ç­†é›»çš„å®‰è£æ–¹å¼ (åƒè€ƒè‡³æ­¤æ–‡ç« ) é–‹å•Ÿ multilib å€‰åº«ï¼švim /etc/pacman.conf  æ‰¾åˆ°ä¸‹æ–¹å…©è¡Œï¼Œä¸¦æ¶ˆæ‰è¨»è§£ [multilib] Include = /etc/pacman.d/mirrorlist    å®‰è£ mesa åŒ…ï¼špacman -S mesa lib32-mesa è‹¥ä¹‹å‰å·²å®‰è£ xf86-video-intelï¼Œè«‹å¸è¼‰æ‰ï¼špacman -Rsc xf86-video-intel nvidia é©…å‹•ï¼špacman -S nvidia lib32-nvidia-utils å®‰è£… nvidia-primeï¼špacman -S nvidia-prime (Prime Wiki) é‡æ–°å•Ÿå‹•ï¼šreboot    ","date":"2021-08-11T17:26:15+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-02/","title":"Arch Linux-02ï¼šåŸºæœ¬è¨­ç½®"},{"content":"å‰è¨€ â€ƒåœ¨è¢«å³æ–‡å…ƒæœ‹æœ‹æ´—è…¦ã€æ¨å‘ã€ç›´éŠ· Arch Linux çš„å„ç¨®å¥½ä¹‹å¾Œï¼Œæˆ‘çµ‚æ–¼ä¹Ÿå…¥å‘äº†ï¼Œè€Œé€™ä¸€ç³»åˆ—å°‡ç´€éŒ„æ•´å€‹çš„å®‰è£éç¨‹ï¼Œé¿å…æœªä¾†å†è¸©ä¸€æ¬¡å‘ã€‚\nå®‰è£è¨­å‚™  ç­†é›»ï¼šZenbook 14 UX433FN é¡¯å¡ï¼š  GPU0 Intel UHD 620 GPU1 Nvidia MX150    é–‹å§‹å®‰è£  å®Œæ•´å®˜æ–¹å°è¦½ï¼šInstallation guide  å‰ç½®ä½œæ¥­  è£½ä½œé–‹æ©Ÿç¢Ÿ  åˆ° Arch Linux Download ä¸‹è¼‰æ˜ åƒæª” (.iso)  NCHCã€NCTU   ä½¿ç”¨ Rufus å¯«å…¥éš¨èº«ç¢Ÿ   å£“ç¸®ç£ç¢Ÿå€  ç”±æ–¼æˆ‘è¦åœ¨ä¸€å¡Šå·²æœ‰ Windows 10 çš„ç¡¬ç¢Ÿä¸Šå®‰è£ Arch linuxï¼Œå› æ­¤å¾—ä¾†åˆ‡ç£å€ã€‚\n  åœ¨ Windows 10 ä¸­é–‹å•Ÿç¡¬ç¢Ÿç®¡ç†å“¡ ä»¥å£“ç¸®ç£ç¢Ÿå€çš„æ–¹å¼å‰µé€ å‡ºæœªåˆ†é…çš„ç©ºé–“ã€‚    å®‰è£ç³»çµ±  æ’ä¸Šéš¨èº«ç¢Ÿï¼Œä¸¦ä»¥éš¨èº«ç¢Ÿé–‹æ©Ÿ æª¢æŸ¥ç¡¬ç¢Ÿã€åˆ†é…ç£å€  ç”±æ–¼æ–°æ‰‹ä¸Šè·¯ï¼Œé€™é‚Šæˆ‘å€‘å°±åˆ†é…å–®ä¸€ç£å€çµ¦ / å°±å¥½ã€‚ è‡³æ–¼å…¶ä»–åƒæ˜¯ [SWAP] ä¹‹é¡çš„ï¼Œæœ‰éœ€è¦å°±è‡ªè¡Œè™•ç†ã€‚\n  fdisk -l: æŸ¥çœ‹ç¡¬ç¢Ÿç‹€æ…‹ cfdisk /dev/nvme0n1 é¸æ“‡ç¡¬ç¢Ÿ(ä¾ç…§æƒ…æ³è‡ªè¡Œæ›´æ”¹åç¨±)  é€²å»å¾Œé¸å– Free space -\u0026gt; New -\u0026gt; è¼¸å…¥ Size (ä¾‹å¦‚: 200G) -\u0026gt; Write -\u0026gt; è¼¸å…¥ yes -\u0026gt; Quit   æ ¼å¼åŒ–ç‚º ext4 æ ¼å¼ï¼šmkfs.ext4 /dev/nvme0n1p5 é¸æ“‡ç£å€(ä¾ç…§æƒ…æ³è‡ªè¡Œæ›´æ”¹åç¨±)   æ›è¼‰ç¡¬ç¢Ÿ  æ›è¼‰ root åˆ†å€ï¼šmount /dev/nvme0n1p5 /mnt å…ˆå‰µå»º boot è³‡æ–™å¤¾ï¼šmkdir /mnt/boot æ›è¼‰ efi åˆ†å€ï¼šmount /dev/nvme0n1p1 /mnt/boot (ä¾ç…§æƒ…æ³è‡ªè¡Œæ›´æ”¹åç¨±)  é€™é‚Šæˆ‘å€‘é¸æ“‡è·Ÿ Windows 10 å…±ç”¨ efi åˆ†å€     é€£æ¥ç¶²è·¯ï¼Œä»¥ä¸‹ç‚º Wifi é€£æ¥æ–¹å¼  è¼¸å…¥ iwctl æŸ¥è©¢è¨­å‚™ï¼šdevice list (ä»¥ä¸‹ä¾ç…§æƒ…æ³è‡ªè¡Œæ›´æ”¹åç¨±ï¼Œé€™é‚Šä»¥ wlan0 ç‚ºä¾‹) æƒæ wifiï¼šstation wlan0 scan åˆ—å‡º wifiï¼šstation wlan0 get-networks é€£æ¥ wifiï¼šstation wlan0 connect Wifi-Name æœ‰å¯†ç¢¼çš„è©±è¼¸å…¥å¯†ç¢¼ è¼¸å…¥ exit é›¢é–‹ è¼¸å…¥ ping www.google.com æª¢æŸ¥æ˜¯å¦é€£æ¥æˆåŠŸ   æ›´æ–°ç³»çµ±æ™‚é–“  timedatectl set-ntp true å¯ä»¥åŸ·è¡Œ timedatectl status æª¢æŸ¥æ™‚é–“åŒæ­¥æœå‹™çš„ç‹€æ…‹ã€‚   å®‰è£å¿…è¦çš„è»Ÿé«”åŒ…  å¿…è¦ï¼špacstrap /mnt base linux linux-firmware ä¾ç…§éœ€æ±‚å®‰è£ï¼špacstrap /mnt vim iwd man-db man-pages texinfo   é…ç½®ç³»çµ±   ç”Ÿæˆ fstab æ–‡ä»¶\n genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab æª¢æŸ¥ç”Ÿæˆçš„ fstab æ–‡ä»¶ï¼šcat /mnt/etc/fstab    åˆ‡æ›åˆ°è£å¥½çš„ç³»çµ±ï¼šarch-chroot /mnt\n  è¨­å®šæ™‚å€ï¼šln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\n  åŒæ­¥ç¡¬é«”æ™‚é˜ï¼šhwclock --systohc\n  åœ¨åœ°åŒ–\n vim /etc/locale.gen  å–æ¶ˆè¨»è§£ en_US.UTF-8 UTF-8ã€zh_TW.UTF-8 UTF-8   ç”Ÿæˆ locale è¨Šæ¯ï¼šlocale-gen vim /etc/locale.conf  æ·»åŠ è¨­å®šï¼šLANG=en_US.UTF-8      é…ç½®ç¶²è·¯\n å‰µå»º hostname æ–‡ä»¶ï¼švim /etc/hostname  è¼¸å…¥ä½ è¦çš„åç¨±ï¼Œä¾‹å¦‚ï¼šmyhostname   ä¿®æ”¹ hostsï¼švim /etc/hostsï¼Œå…§å®¹å¦‚ä¸‹ 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyhostname.localdomain\tmyhostname     è¨­å®š DHCP\n vim /etc/systemd/network/20-wired.networkï¼Œå…§å®¹å¦‚ä¸‹  enp1s0 ç‚ºç¶²å¡åç¨±ï¼Œè«‹ç”¨ ip a è‡ªè¡ŒæŸ¥çœ‹æ›´æ”¹  [Match] Name=enp1s0 [Network] DHCP=yes  å•Ÿç”¨ï¼šsystemctl enable --now systemd-networkd.service    å•Ÿç”¨ DNSï¼šsystemctl enable --now systemd-resolved\n  ä¿®æ”¹ root å¯†ç¢¼ï¼špasswd\n   é–‹æ©Ÿå¼•å°ï¼Œé€™é‚Šæˆ‘å€‘ä½¿ç”¨ systemd-boot  å°‡ systemd-boot å®‰è£åˆ° efi åˆ†å€ï¼šbootctl --path=/boot install æ‰‹å‹•æ›´æ–° systemd-bootï¼šbootctl --path=/boot update å•Ÿå‹•é¸å–®é…ç½®  vim /boot/loader/loader.confï¼Œå…§å®¹å¦‚ä¸‹ default arch-* # arch é‚£è£¡æ‡‰ç‚ºä¸€å­—ä¸²ä¸ç”¨æ›´æ”¹ timeout 10 console-mode max editor no  vim /boot/loader/entries/arch.confï¼Œå…§å®¹å¦‚ä¸‹  UUID è«‹è‡ªè¡Œå¡«å…¥ï¼Œå¯æ–¼ /etc/fstab ä¸­æŸ¥çœ‹ï¼Œè«‹é¸æ“‡ / ç›®éŒ„çš„ã€‚  title Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=\u0026quot;UUID=XXX-XXX-XXX\u0026quot; rw  cp /boot/loader/entries/arch.conf /boot/loader/entries/arch-fallback.conf vim /boot/loader/entries/arch-fallback.conf  å°‡ /initramfs-linux.img æ›´æ”¹ç‚º /initramfs-linux-fallback.img å³å¯       é‡æ–°å•Ÿå‹•  é€€å‡º chroot ç’°å¢ƒï¼šè¼¸å…¥ exit æˆ–æ˜¯æŒ‰ä¸‹ Ctrl+d å¸è¼‰åˆ†å€ï¼šumount -R /mnt é‡æ–°å•Ÿå‹•ï¼šreboot è¨˜å¾—é‡é–‹æ™‚è¦ç§»é™¤éš¨èº«ç¢Ÿå‘€    è£œå……  é€™å°é›»è…¦é€² BIOS æ–¹æ³•ï¼šæŒ‰ä½ F2ï¼Œå†æŒ‰é›»æºï¼Œç›´åˆ°é€²å…¥ BIOS å†æ”¾é–‹ F2 åœ¨ BIOS æ–°å¢é–‹æ©Ÿé¸é …  Boot -\u0026gt; Add New Boot Option Add boot optionï¼šè¼¸å…¥é¸é …åç¨± Path for boot optionï¼š\\EFI\\systemd\\systemd-bootx64.efi Create -\u0026gt; Ok   é–‹æ©Ÿé¸å–®æ¶ˆå¤±å•é¡Œï¼šWindows_changes_boot_order å­—é«”å¤ªå°å•é¡Œ  HiDPI - Linux Console Linux_console - Fonts    ","date":"2021-08-11T13:50:32+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-01/","title":"Arch Linux-01ï¼šç³»çµ±å®‰è£"},{"content":"ä¸»é¡Œ  æœ€å°ç”Ÿæˆæ¨¹  MST æ¨¡æ¿ Kruskal\u0026rsquo;s Algorithm  æ™‚é–“è¤‡é›œåº¦ O(ElogE)  struct edge { int u, v, w; bool operator \u0026lt; (const edge \u0026amp;r) const { return w \u0026lt; r.w; } }; int vn, en; // vertex num, edge num vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = x; } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int Kruskal() { for(int i = 0; i \u0026lt; vn; ++i) dsu.push_back(i); sort(ve.begin(), ve.end()); int cnt = 0, ans = 0; for(int i = 0; i \u0026lt; en \u0026amp;\u0026amp; cnt \u0026lt; vn; ++i) { if(Union(ve[i].u, ve[i].v)) { ans += ve[i].w; ++cnt; } } return ans; } Prim\u0026rsquo;s Algorithm  æ™‚é–“è¤‡é›œåº¦ O(VlogE)  struct edge { int idx, w; bool operator \u0026lt; (const edge \u0026amp;r) const { return w \u0026gt; r.w; } }; int prim() { int vn; // vertex num  vector\u0026lt;edge\u0026gt; adj[vn]; int ans = 0; priority_queue\u0026lt;edge\u0026gt; pq; vector\u0026lt;bool\u0026gt; vis(vn, false); vis[0] = true; for(auto v : adj[0]) pq.emplace(v); while(!pq.empty()) { edge mn = pq.top(); pq.pop(); if(vis[mn.idx]) continue; vis[mn.idx] = true; ans += mn.w; for(auto v : adj[mn.idx]) pq.emplace(v); } } é¡Œç›®  Virtual Judge é¡Œç›®åˆ—è¡¨èˆ‡æç¤º    é¡Œç›® é¡Œç›®éœ€æ±‚ é›£åº¦     UVa 10034 çµ¦å®šå¹³é¢ä¸Šå„é»åº§æ¨™ï¼Œæ±‚æœ€å°ç”Ÿæˆæ¨¹çš„é‚Šæ¬Šç¸½å’Œã€‚(è£¸) æ¨¡æ¿é¡Œ   UVL 7001 è®€æ‡‚é¡Œç›®çš„ä¸‰é …æ€§è³ªï¼Œä¾¿çŸ¥é“é¡Œæ„ç‚ºæ±‚æœ€å°ç”Ÿæˆæ¨¹ã€‚ æ¨¡æ¿é¡Œ   UVa 1208 è®€æ‡‚é¡Œç›®ä¾¿çŸ¥é¡Œæ„ã€‚ æ¨¡æ¿é¡Œ   UVa 10369 è®€æ‡‚é¡Œç›®ï¼Œè‡ªè¡Œæ€è€ƒå’Œæœ€å°ç”Ÿæˆæ¨¹æ¼”ç®—æ³•çš„é—œä¿‚ã€‚ å°è®ŠåŒ–   UVL 6437 è®€æ‡‚é¡Œç›®ï¼Œè‡ªè¡Œæ€è€ƒè©²ä½œä»€éº¼æ¨£çš„å°ä¿®æ”¹ã€‚ å°è®ŠåŒ–   UVa 534 è®€æ‡‚é¡Œç›®ï¼Œè‡ªè¡Œæ€è€ƒå’Œæœ€å°ç”Ÿæˆæ¨¹æ¼”ç®—æ³•çš„é—œä¿‚ã€‚(æœ€å°ç“¶é ¸è·¯) ç¶“å…¸è®ŠåŒ–   Uva 11733 è®€æ‡‚é¡Œç›®ï¼Œè‡ªè¡Œæ€è€ƒå’Œæœ€å°ç”Ÿæˆæ¨¹æ¼”ç®—æ³•çš„é—œä¿‚ã€‚ å°è®ŠåŒ–   Uva 1395 çµ¦å®šåœ–ï¼Œå°è©²åœ–æ‰€æœ‰ç”Ÿæˆæ¨¹è¨ˆç®—æœ€å¤§é‚Šæ¬Šæ¸›æœ€å°é‚Šæ¬Šï¼Œè¼¸å‡ºè©²å·®è·ä¹‹æœ€å°å€¼ã€‚ å°è®ŠåŒ–   Uva 1151 çµ¦å®šåœ–ä»¥åŠ q çµ„å·²çŸ¥è³¼è²·æˆæœ¬çš„å­ç¶²è·¯ï¼Œå•é€£é€šæ‰€æœ‰é»çš„æœ€å°æˆæœ¬ã€‚ å°è®ŠåŒ–      åƒè€ƒä½œæ³• A - Freckles #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n; struct Point { int group; double x, y; } p[105]; struct Line { int aIdx, bIdx; double len; }; double pD(const Point \u0026amp;a, const Point \u0026amp;b) { double dx = a.x - b.x, dy = a.y - b.y; return sqrt(dx * dx + dy * dy); } bool cmpLen(const Line \u0026amp;a, const Line \u0026amp;b) { return a.len \u0026lt; b.len; } bool isMSTEnd() { for(int i = 0; i \u0026lt; n - 1; ++i) if(p[i].group != p[i + 1].group) return false; return true; } void Union(int a, int b) { int minG = min(a, b); for(int i = 0; i \u0026lt; n; ++i) { if(p[i].group == a || p[i].group == b) p[i].group = minG; } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++i) { p[i].group = i; cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; } vector\u0026lt;Line\u0026gt; lines; for(int i = 0; i \u0026lt; n; ++i) { for(int j = i + 1; j \u0026lt; n; ++j) { lines.push_back({i, j, pD(p[i], p[j])}); } } sort(lines.begin(), lines.end(), cmpLen); double ans = 0.0; for(int i = 0; !isMSTEnd(); ++i) { if(p[lines[i].aIdx].group == p[lines[i].bIdx].group) continue; ans += lines[i].len; Union(p[lines[i].aIdx].group, p[lines[i].bIdx].group); } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; if(T) cout \u0026lt;\u0026lt; endl; } return 0; } B - Bus Problem #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n, m; long long sumO, sumM; vector\u0026lt;int\u0026gt; dsu; struct edge { int s, e, v; }; vector\u0026lt;edge\u0026gt; ve; bool cmp(const edge \u0026amp;a, const edge \u0026amp;b) { return a.v \u0026lt; b.v; } int Find(int x) { if(dsu[x] == x) return x; return dsu[x] = Find(dsu[x]); } int merge(int x, int y, int t) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; sumM += ve[t].v; } } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; sumO = sumM = 0; dsu.clear(); ve.clear(); for(int i = 0; i \u0026lt; m; ++i) { int a, b, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; d; ve.push_back({a, b, d}); sumO += d; } for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); sort(ve.begin(), ve.end(), cmp); for(int i = 0; i \u0026lt; m; ++i) { merge(ve[i].s, ve[i].e, i); } cout \u0026lt;\u0026lt; sumO - sumM \u0026lt;\u0026lt; endl; } return 0; } C - Oreon #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n; struct edge { int u, v, w; }; vector\u0026lt;edge\u0026gt; g; vector\u0026lt;int\u0026gt; dsu; bool cmp(const edge \u0026amp;a, const edge \u0026amp;b) { if(a.w == b.w){ if(a.u == b.u) return a.v \u0026lt; b.v; else return a.u \u0026lt; b.u; } return a.w \u0026lt; b.w; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  int T; cin \u0026gt;\u0026gt; T; for(int ca = 1; ca \u0026lt;= T; ++ca) { cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; cin \u0026gt;\u0026gt; n; g.clear(); cin.ignore(100, \u0026#39;\\n\u0026#39;); for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { int t; char c; scanf(\u0026#34;%d%c\u0026#34;, \u0026amp;t, \u0026amp;c); if(i == j || t == 0) continue; g.push_back({i, j, t}); } } sort(g.begin(), g.end(), cmp); dsu.clear(); for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); int sz = g.size(); for(int i = 0; i \u0026lt; sz; ++i) { int a = Find(g[i].u), b = Find(g[i].v); if(a != b) { Union(a, b); cout \u0026lt;\u0026lt; (char)(\u0026#39;A\u0026#39; + g[i].u) \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; (char)(\u0026#39;A\u0026#39; + g[i].v) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; g[i].w \u0026lt;\u0026lt; endl; } } } return 0; } D - Arctic Network #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct Point { int x, y; }; vector\u0026lt;Point\u0026gt; vp; struct edge { int u, v; double len; }; vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; dsu; bool cmpVE(const edge \u0026amp;a, const edge \u0026amp;b) { return a.len \u0026lt; b.len; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a == b)return false; dsu[a] = b; return true; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int s, p; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; vp.clear(); ve.clear(); dsu.clear(); for(int i = 0; i \u0026lt; p; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; vp.push_back({x, y}); dsu.push_back(i); } for(int i = 0; i \u0026lt; p; ++i) { for(int j = i + 1; j \u0026lt; p; ++j) { int dx = vp[i].x - vp[j].x, dy = vp[i].y - vp[j].y; ve.push_back({i, j, sqrt(dx * dx + dy * dy)}); } } sort(ve.begin(), ve.end(), cmpVE); vector\u0026lt;double\u0026gt; ans; for(int i = 0; ans.size() \u0026lt; p - 1; ++i) { if(!Union(ve[i].u, ve[i].v)) continue; ans.push_back(ve[i].len); } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; ans[p - 1 - s] \u0026lt;\u0026lt; endl; } return 0; } E - Power Plant #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int x, y, z; } a[500010]; int fa[100010], n, m, k, ans, len = 0; bool vis[100010]; int getf(int x) { if (x == fa[x]) return x; return fa[x] = getf(fa[x]); } bool cmp(node x, node y) { return x.z \u0026lt; y.z; } int main() { int T, ll = 0;; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { memset(vis, 0, sizeof(vis)); ll++; len = ans = 0; int xx; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;xx), vis[xx] = 1; for (int i = 1; i \u0026lt;= m; i++) { ++len; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a[len].x, \u0026amp;a[len].y, \u0026amp;a[len].z); len++; a[len].x = a[len - 1].y; a[len].y = a[len - 1].x; a[len].z = a[len - 1].z; } for (int i = 1; i \u0026lt;= len; i++) { if (vis[a[i].x]) a[i].x = n + 1; if (vis[a[i].y]) a[i].y = n + 1; } sort(a + 1, a + len + 1, cmp); for (int i = 1; i \u0026lt;= n + 1; i++) fa[i] = i; int num = 0; for (int i = 1; i \u0026lt;= len; i++) { int x = getf(a[i].x), y = getf(a[i].y); if (x != y) { fa[x] = y; ans += a[i].z; num++; if (num == n) break; } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, ll, ans); } return 0; } F - Frogger #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int x, y; }; vector\u0026lt;node\u0026gt; vn; double dis[205][205]; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int n, cnt = 1; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { vn.clear(); for(int i = 0; i \u0026lt; n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vn.push_back({a, b}); } for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { int dx = vn[i].x - vn[j].x, dy = vn[i].y - vn[j].y; dis[i][j] = sqrt(dx * dx + dy * dy); } } for(int k = 0; k \u0026lt; n; ++k) { for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { dis[i][j] = min(dis[i][j], max(dis[i][k], dis[k][j])); } } } cout \u0026lt;\u0026lt; \u0026#34;Scenario #\u0026#34; \u0026lt;\u0026lt; cnt++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Frog Distance = \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; dis[0][1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } return 0; } G - Airports #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int u, v, w; bool operator \u0026lt; (const node \u0026amp;r) const { return w \u0026lt; r.w; } }; vector\u0026lt;node\u0026gt; vn; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; for(int ca = 1; ca \u0026lt;= T; ++ca) { int n, m, cost; vn.clear(); dsu.clear(); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; cost; for(int i = 0; i \u0026lt;= n; ++i) dsu.push_back(i); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; vn.push_back({a, b, c}); } sort(vn.begin(), vn.end()); int sum = 0; for(int i = 0; i \u0026lt; m; ++i) { if(vn[i].w \u0026gt;= cost) continue; if(Union(vn[i].u, vn[i].v)) sum += vn[i].w; } int cnt = 0; for(int i = 1; i \u0026lt;= n; ++i) { if(i == dsu[i]) ++cnt; } cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; sum + cost*cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } H - Slim Span #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int u, v, w; bool operator \u0026lt; (const node \u0026amp;r) const { return w \u0026lt; r.w; } }; vector\u0026lt;node\u0026gt; vn; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; (n || m)) { vn.clear(); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; vn.push_back({a, b, c}); } sort(vn.begin(), vn.end()); int ans = INF; for(int i = 0; i \u0026lt; m; ++i) { dsu.clear(); for(int i = 0; i \u0026lt;= n; ++i) dsu.push_back(i); int cnt = n - 1; for(int j = i; j \u0026lt; m; ++j) { if(Union(vn[j].u, vn[j].v)) --cnt; if(cnt == 0) { ans = min(ans, vn[j].w - vn[i].w); break; } } } if(ans == INF) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } I - Buy or Build #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct point { int x, y; }; struct buy { int m, ci; vector\u0026lt;int\u0026gt; a; }; struct node { int u, v, w; bool operator \u0026lt; (const node \u0026amp;r) const { return w \u0026lt; r.w; } }; vector\u0026lt;point\u0026gt; vp; vector\u0026lt;buy\u0026gt; vb; vector\u0026lt;node\u0026gt; vn, vt; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int ksu(int t, vector\u0026lt;node\u0026gt; \u0026amp;vn, vector\u0026lt;node\u0026gt; \u0026amp;used) { if(t == 1) return 0; int m = vn.size(), ans = 0; used.clear(); for(int i = 0; i \u0026lt; m; ++i) { if(Union(vn[i].u, vn[i].v)) { ans += vn[i].w; used.push_back(vn[i]); if(--t == 1) break; } } return ans; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { vp.clear(); vb.clear(); vn.clear(); dsu.clear(); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; q; ++i) { buy tmp; cin \u0026gt;\u0026gt; tmp.m \u0026gt;\u0026gt; tmp.ci; for(int j = 0; j \u0026lt; tmp.m; ++j) { int t; cin \u0026gt;\u0026gt; t; tmp.a.push_back(t - 1); } vb.push_back(tmp); } for(int i = 0; i \u0026lt; n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; vp.push_back({x, y}); } for(int i = 0; i \u0026lt; n; ++i) { for(int j = i + 1; j \u0026lt; n; ++j) { int dx = vp[i].x - vp[j].x, dy = vp[i].y - vp[j].y; vn.push_back({i, j, dx * dx + dy * dy}); } } sort(vn.begin(), vn.end()); for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); int ans = ksu(n, vn, vt); for(int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; q); ++mask) { dsu.clear(); for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); int cnt = n, c = 0; for(int i = 0; i \u0026lt; q; ++i) { if(mask \u0026amp; (1 \u0026lt;\u0026lt; i)) { c += vb[i].ci; for(int j = 1; j \u0026lt; vb[i].a.size(); j++) { if(Union(vb[i].a[0], vb[i].a[j])) --cnt; } } } vector\u0026lt;node\u0026gt; vd; ans = min(ans, c + ksu(cnt, vt, vd)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; if(T) cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-08-10T23:50:17+08:00","permalink":"https://blog.smallten.tk/p/star_coder-06/","title":"StarCoder2021æš‘è¨“ï¼šWeek05"},{"content":"ä¸»é¡Œ  å‹•æ…‹è¦åŠƒ  ç¶“å…¸èƒŒåŒ…æ¨¡æ¿ 0/1 èƒŒåŒ… \u0026amp; ç„¡é™èƒŒåŒ… const int N = 100, W = 100000; int cost[N], weight[N], c[W + 1]; void knapsack(int n, int w) { memset(c, 0, sizeof(c)); for (int i = 0; i \u0026lt; n; ++i) for (int j = w; j - weight[i] \u0026gt;= 0; --j) // 0/1 èƒŒåŒ…  // for (int j = weight[i]; j \u0026lt;= w; ++j) ç„¡é™èƒŒåŒ…  c[j] = max(c[j], c[j - weight[i]] + cost[i]); cout \u0026lt;\u0026lt; \u0026#34;æœ€é«˜çš„åƒ¹å€¼ç‚º\u0026#34; \u0026lt;\u0026lt; c[w]; } æœ‰é™èƒŒåŒ… const int N = 100, W = 100000; int cost[N], weight[N], number[N], c[W + 1]; void knapsack(int n, int w) { for (int i = 0; i \u0026lt; n; ++i) { int num = min(number[i], w / weight[i]); for (int k = 1; num \u0026gt; 0; k *= 2) { if (k \u0026gt; num) k = num; num -= k; for (int j = w; j \u0026gt;= weight[i] * k; --j) c[j] = max(c[j], c[j - weight[i] * k] + cost[i] * k); } } cout \u0026lt;\u0026lt; \u0026#34;æœ€é«˜çš„åƒ¹å€¼ç‚º\u0026#34; \u0026lt;\u0026lt; c[w]; } ç¶“å…¸é›¶éŒ¢å•é¡Œæ¨¡æ¿ int price[5] = {5, 2, 6, 11, 17}; bool c[1000+1]; //int c[1000+1]; void change(int m) { memset(c, false, sizeof(c)); c[0] = true; for (int i = 0; i \u0026lt; 5; ++i) for (int j = price[i]; j \u0026lt;= m; ++j) c[j] ||= c[j-price[i]]; // c[j] += c[j-price[i]];  if (c[m]) cout \u0026lt;\u0026lt; \u0026#34;æ¹Šå¾—åˆ°\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;æ¹Šä¸åˆ°\u0026#34;; // cout \u0026lt;\u0026lt; \u0026#34;æ¹Šå¾—åƒ¹ä½\u0026#34; \u0026lt;\u0026lt; m;  // cout \u0026lt;\u0026lt; \u0026#34;æ¹Šæ³•ç¸½å…±\u0026#34; \u0026lt;\u0026lt; c[m] \u0026lt;\u0026lt; \u0026#34;ç¨®\u0026#34;; } LIS æ¨¡æ¿ DP const int N = 100; int s[N], length[N]; int LIS() { for (int i=0; i\u0026lt;N; i++) length[i] = 1; for (int i=0; i\u0026lt;N; i++) for (int j=0; j\u0026lt;i; j++) if (s[j] \u0026lt; s[i]) length[i] = max(length[i], length[j] + 1); int l = 0; for (int i=0; i\u0026lt;N; i++) l = max(l, length[i]); return l; } Robinson-Schensted-Knuth Algorithm  æ™‚é–“è¤‡é›œåº¦ O(NlogL) ï¼Œ N æ˜¯åºåˆ—é•·åº¦ï¼Œ L æ˜¯ LIS é•·åº¦ã€‚  int LIS(vector\u0026lt;int\u0026gt;\u0026amp; s) { if (s.size() == 0) return 0; vector\u0026lt;int\u0026gt; v; v.push_back(s[0]); for (int i=1; i\u0026lt;s.size(); ++i) { int n = s[i]; if (n \u0026gt; v.back()) v.push_back(n); else *lower_bound(v.begin(), v.end(), n) = n; } return v.size(); } LCS æ¨¡æ¿ DP const int N1 = 7, N2 = 5; int s1[N1+1] = {0, 2, 5, 7, 9, 3, 1, 2}; int s2[N2+1] = {0, 3, 5, 3, 2, 8}; int length[N1+1][N2+1]; int LCS() { for (int i=0; i\u0026lt;=N1; i++) length[i][0] = 0; for (int j=0; j\u0026lt;=N2; j++) length[0][j] = 0; for (int i=1; i\u0026lt;=N1; i++) for (int j=1; j\u0026lt;=N2; j++) if (s1[i] == s2[j]) length[i][j] = length[i-1][j-1] + 1; else length[i][j] = max(length[i-1][j], length[i][j-1]); return length[N1][N2]; } Hunt-Szymanski Algorithm  LCS å•é¡Œï¼ŒåŒ–ä½œ 2D LIS å•é¡Œï¼Œå†åŒ–ä½œ 1D LIS å•é¡Œï¼Œæœ€å¾Œå¥—ç”¨ Robinson-Schensted-Knuth Algorithm ã€‚ æ’åºæ‰€æœ‰æ•¸å°ï¼Œä½¿ç”¨ Counting Sort ã€‚æƒæä¸€é s2 ï¼ŒæŠŠæ¯å€‹å­—å…ƒçš„ä½ç½®ç´€éŒ„ä¸‹ä¾†ã€‚ è¼ƒçŸ­çš„åºåˆ—ç•¶ä½œ s1 ï¼Œæ™‚é–“è¤‡é›œåº¦æ˜¯ O(Klog(min(N,M)) + R) ã€‚ K æ˜¯æ•¸å°æ•¸ç›®ï¼Œ N å’Œ M æ˜¯åºåˆ—é•·åº¦ï¼Œ R æ˜¯æ•¸å­—ç¯„åœã€‚ K è‡³å¤šæ˜¯ NM ï¼Œæœ€å·®æƒ…æ³ä¸‹æ¯”å…ˆå‰çš„æ¼”ç®—æ³•é‚„æ…¢ï¼Œå¹³å‡æƒ…æ³ä¸‹æ¯”å…ˆå‰çš„æ¼”ç®—æ³•å¿«ä¸Šè¨±å¤šã€‚ R æºè‡ª Counting Sort ã€‚  int LCS(string \u0026amp;s1, string \u0026amp;s2) { vector\u0026lt;int\u0026gt; p[128]; // å‡è¨­å­—å…ƒç¯„åœç‚º 0 ~ 127  for (int i = 0; i \u0026lt; s2.size(); ++i) p[s2[i]].push_back(i); vector\u0026lt;int\u0026gt; v; v.push_back(-1); for (int i = 0; i \u0026lt; s1.size(); ++i) for (int j = p[s1[i]].size() - 1; j \u0026gt;= 0; --j) { int n = p[s1[i]][j]; if (n \u0026gt; v.back()) v.push_back(n); else *lower_bound(v.begin(), v.end(), n) = n; } return v.size() - 1; } é¡Œç›®  Virtual Judge é¡Œç›®åˆ—è¡¨èˆ‡æç¤º    é¡Œç›® é¡Œç›®éœ€æ±‚ æ¡ç”¨æ¼”ç®—æ³• é›£åº¦ (for æ–°æ‰‹)     UVa 10130 çµ¦ç‰©å“åƒ¹å€¼å’Œé‡é‡ï¼Œçµ¦å…¨å®¶äººæ¯äººæœ€å¤§è² é‡ï¼Œå•å…¨å®¶èƒ½æ¬èµ°çš„æœ€é«˜ç¸½åƒ¹ã€‚ ç¶“å…¸èƒŒåŒ… æ˜“   UVa 357 çµ¦å®šå¹£å€¼ç¨®é¡ï¼Œå•æŸä¸€å€‹é‡‘é¡å­˜åœ¨å¹¾ç¨®è¡¨ç¤ºæ³•ã€‚ ç¶“å…¸é›¶éŒ¢å•é¡Œ æ˜“   UVa 10405 çµ¦å…©å€‹å­—ä¸²ï¼Œå•æœ€é•·å…±åŒå­å­—ä¸²ã€‚ è£¸ LCS æ˜“   UVa 369 æ±‚ N å€‹ä¸­å– M å€‹æ•¸çš„ç¸½çµ„åˆæ•¸ã€‚ çµ„åˆæ•¸å…¬å¼ æ˜“   UVa 10003 çµ¦ä¸€æ ¹æ£å­ä¸Šçš„åˆ‡æ–·é»ï¼Œæ¯æ¬¡åˆ‡æ–·çš„æˆæœ¬ç‚ºè©²æ®µé•·åº¦ï¼Œå•æ‰€æœ‰åˆ‡æ–·é»éƒ½åˆ‡æ–·çš„æœ€å°æˆæœ¬ã€‚ å€é–“ DP æ˜“   UVa 103 çµ¦ä¸€å † D ç¶­çš„ç›’å­ï¼Œå•é€™äº›ç›’å­ä¸€å€‹è£é€²ä¸€å€‹ï¼Œæœ€å¤šèƒ½è£å¤šå°‘å€‹ã€‚ DAG æœ€çŸ­è·¯/LIS ä¸­   UVa 10534 ä¸€å€‹ Wavio åºåˆ—å« 2n+1 å€‹æ•¸ï¼Œå‰åŠåš´æ ¼éå¢ï¼Œå¾ŒåŠåš´æ ¼éæ¸›ã€‚æ±‚ä¸€å€‹æ•¸åˆ—ä¸­çš„æœ€é•· Wavio åºåˆ—ã€‚ O(nlogn) LIS é›£   UVa 10949 çµ¦å…©å€‹é•·åº¦æœ€å¤š 20000 å€‹å­—å…ƒçš„å­—ä¸²ï¼Œæ±‚æœ€é•·å…±åŒå­å­—ä¸²ã€‚ å› å­—ä¸²å¾ˆé•·ï¼Œéœ€é€é LCS-\u0026gt;LIS è½‰æ›ï¼Œå†ç”¨å¿«é€Ÿ LIS è§£æ±ºã€‚ é›£   UVa 10032 çµ¦ä¸€ç¾¤äººçš„é«”é‡ï¼Œå°‡ä»–å€‘åˆ†æˆå…©ç¾¤ï¼ˆäººæ•¸æœ€å¤šå·®ä¸€å€‹ï¼‰ï¼Œä¸¦å„˜å¯èƒ½æœ€å°åŒ–å…©ç¾¤çš„é«”é‡å’Œå·®è·ã€‚ èƒŒåŒ…è®ŠåŒ–+ç‹€æ…‹å£“ç¸® \\(é›£^2\\)   UVa 104 çµ¦ n ç¨®è²¨å¹£å½¼æ­¤é–“çš„åŒ¯ç‡ï¼Œæ‰¾å‡ºä¸€ç¨®åŒ¯ç‡è½‰æ›é †åºèƒ½å¾ä¸­å¥—åˆ© 1% ä»¥ä¸Šã€‚ Floyd-Warshall \\(é›£^2\\)      åƒè€ƒä½œæ³• A - SuperSale #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, m, c[35], g, ans = 0; cin \u0026gt;\u0026gt; n; int p[n], w[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; p[i] \u0026gt;\u0026gt; w[i]; cin \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; g; memset(c, 0x00, sizeof(c)); for(int j = 0; j \u0026lt; n; ++j) { for(int k = g; k - w[j] \u0026gt;= 0; --k) { c[k] = max(c[k], c[k - w[j]] + p[j]); } } ans += c[g]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } B - Let Me Count The Ways #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int p[5] = {50, 25, 10, 5, 1}, n; long long c[30005]; while(cin \u0026gt;\u0026gt; n) { memset(c, 0, sizeof(c)); c[0] = 1; for(int i = 0; i \u0026lt; 5; ++i) { for(int j = p[i]; j \u0026lt;= n; ++j) { c[j] += c[j - p[i]]; } } if(c[n] == 1) cout \u0026lt;\u0026lt; \u0026#34;There is only 1 way to produce \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; cents change.\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;There are \u0026#34; \u0026lt;\u0026lt; c[n] \u0026lt;\u0026lt; \u0026#34; ways to produce \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; cents change.\\n\u0026#34;; } return 0; } C - Longest Common Subsequence #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); string s1, s2; while(getline(cin, s1)) { getline(cin, s2); int n1 = s1.length(), n2 = s2.length(); int dp[n1 + 1][n2 + 1]; for(int i = 0; i \u0026lt;= n1; ++i) dp[i][0] = 0; for(int i = 0; i \u0026lt;= n2; ++i) dp[0][i] = 0; for(int i = 0; i \u0026lt; n1; ++i) { for(int j = 0; j \u0026lt; n2; ++j) { if(s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); } } cout \u0026lt;\u0026lt; dp[n1][n2] \u0026lt;\u0026lt; endl; } return 0; } D - Combinations #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); long long c[105][105] = {0}; for(int i = 1 ; i \u0026lt;= 100 ; ++i) { for(int j = 1 ; j \u0026lt;= i ; ++j) { if(i == j) c[i][j] = 1; else c[i][j] = c[i - 1][j] * i / (i - j); } } int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; !(n == 0 \u0026amp;\u0026amp; m == 0)) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; things taken \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; at a time is \u0026#34; \u0026lt;\u0026lt; c[n][m] \u0026lt;\u0026lt; \u0026#34; exactly.\\n\u0026#34;; return 0; } E - Cutting Sticks #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int len, n, c[55], dp[55][55]; while(cin \u0026gt;\u0026gt; len \u0026amp;\u0026amp; len) { cin \u0026gt;\u0026gt; n; c[0] = 0; c[++n] = len; memset(dp, 0, sizeof(dp)); for(int i = 1; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; c[i]; for(int w = 2; w \u0026lt;= n; ++w) { for(int l = 0; l \u0026lt; n - 1; ++l) { int r = l + w; if(r \u0026gt; n) break; dp[l][r] = INF; for(int m = l + 1; m \u0026lt; r; ++m) dp[l][r] = min(dp[l][m] + dp[m][r] + c[r] - c[l], dp[l][r]); } } cout \u0026lt;\u0026lt; \u0026#34;The minimum cutting is \u0026#34; \u0026lt;\u0026lt; dp[0][n] \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; } return 0; } F - Stacking Boxes #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct Box { int id; vector\u0026lt;int\u0026gt; len; }; bool boxcmp(const Box \u0026amp;a, const Box \u0026amp;b) { int sz = a.len.size(); for(int i = 0; i \u0026lt; sz; ++i) { if(a.len[i] \u0026lt; b.len[i]) return true; if(a.len[i] \u0026gt; b.len[i]) return false; } return true; } bool isContain(const Box \u0026amp;a, const Box \u0026amp;b) { int sz = a.len.size(); for(int i = 0; i \u0026lt; sz; ++i) { if(a.len[i] \u0026lt;= b.len[i]) return false; } return true; } void printBox(const vector\u0026lt;int\u0026gt; \u0026amp;prevNesting, const vector\u0026lt;Box\u0026gt; \u0026amp;box, int lastbox, bool printSpace) { if(lastbox == -1) return; printBox(prevNesting, box, prevNesting[lastbox], true); cout \u0026lt;\u0026lt; box[lastbox].id; if(printSpace) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int k, n; while(cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n) { vector\u0026lt;Box\u0026gt; box; for(int i = 0; i \u0026lt; k; ++i) { int t; vector\u0026lt;int\u0026gt; tmp; for(int j = 0; j \u0026lt; n; ++j) { cin \u0026gt;\u0026gt; t; tmp.push_back(t); } sort(tmp.begin(), tmp.end()); box.push_back({i + 1, tmp}); } sort(box.begin(), box.end(), boxcmp); vector\u0026lt;int\u0026gt; maxNesting(k, 1), prevNesting(k, -1); int maxLen = 1, lastbox = 0; for(int i = 0; i \u0026lt; k; ++i) { for(int j = 0; j \u0026lt; i; ++j) { if(isContain(box[i], box[j])) { if(maxNesting[j] + 1 \u0026gt; maxNesting[i]) { maxNesting[i] = maxNesting[j] + 1; prevNesting[i] = j; if(maxNesting[i] \u0026gt; maxLen) { maxLen = maxNesting[i]; lastbox = i; } } } } } cout \u0026lt;\u0026lt; maxLen \u0026lt;\u0026lt; endl; printBox(prevNesting, box, lastbox, false); cout \u0026lt;\u0026lt; endl; } return 0; } G - Wavio Sequence #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n, a[10005], dpI[10005], dpD[10005]; void LIS() { if(n == 0) return; vector\u0026lt;int\u0026gt; v; v.push_back(a[0]); dpI[0] = 1; for(int i = 1; i \u0026lt; n; ++i) { if(a[i] \u0026gt; v.back()) v.push_back(a[i]); else *lower_bound(v.begin(), v.end(), a[i]) = a[i]; dpI[i] = v.size(); } } void LDS() { if(n == 0) return; vector\u0026lt;int\u0026gt; v; v.push_back(a[n - 1]); dpD[n - 1] = 1; for(int i = n - 2; i \u0026gt;= 0; --i) { if(a[i] \u0026gt; v.back()) v.push_back(a[i]); else *lower_bound(v.begin(), v.end(), a[i]) = a[i]; dpD[i] = v.size(); } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); while(cin \u0026gt;\u0026gt; n) { memset(dpI, 0, sizeof(dpI)); memset(dpD, 0, sizeof(dpD)); for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; LIS(); LDS(); int ans = 1; for(int i = 0; i \u0026lt; n; ++i) ans = max(min(dpI[i], dpD[i]) * 2 - 1, ans); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } H - Kids in a Grid #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 string g[30]; int LCS(string \u0026amp;s1, string \u0026amp;s2) { vector\u0026lt;int\u0026gt; p[130]; for(int i = 0; i \u0026lt; s2.size(); ++i) p[s2[i]].push_back(i); vector\u0026lt;int\u0026gt; v; v.push_back(-1); for (int i = 0; i \u0026lt; s1.size(); ++i) { for (int j = p[s1[i]].size() - 1; j \u0026gt;= 0; --j) { int n = p[s1[i]][j]; if (n \u0026gt; v.back()) v.push_back(n); else *lower_bound(v.begin(), v.end(), n) = n; } } return v.size() - 1; } string getStr() { string s, path; int n, x, y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; cin.ignore(100, \u0026#39;\\n\u0026#39;); getline(cin, path); int curX = x - 1, curY = y - 1; s += g[curX][curY]; for(int i = 0; i \u0026lt; n; ++i) { if(path[i] == \u0026#39;N\u0026#39;) --curX; else if(path[i] == \u0026#39;E\u0026#39;) ++curY; else if(path[i] == \u0026#39;S\u0026#39;) ++curX; else if(path[i] == \u0026#39;W\u0026#39;) --curY; s += g[curX][curY]; } return s; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; ++i) { int row, col; cin \u0026gt;\u0026gt; row \u0026gt;\u0026gt; col; string str1, str2, tmp; for(int j = 0; j \u0026lt; row; ++j) cin \u0026gt;\u0026gt; g[j]; str1 = getStr(); str2 = getStr(); int len, len1 = str1.length(), len2 = str2.length(); if(len1 \u0026gt; len2) len = LCS(str2, str1); else len = LCS(str1, str2); cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; len1 - len \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; len2 - len \u0026lt;\u0026lt; endl; } return 0; } I - Tug of War #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int f(vector\u0026lt;int\u0026gt; \u0026amp;w, int sum) { if(w.size() == 1) return 0; sort(w.begin(), w.end()); } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, w[105]; long long dp[22505]; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; long long sum = accumulate(w + 1, w + n + 1, 0LL); memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int i = 1; i \u0026lt;= n; ++i) { for(int j = sum / 2; j \u0026gt;= w[i]; j--) { dp[j] |= (dp[j - w[i]] \u0026lt;\u0026lt; 1); } } if(n \u0026amp; 1) { for(int i = sum / 2; i \u0026gt;= 0; --i) { long long flag1 = (1LL \u0026lt;\u0026lt; (n / 2)); long long flag2 = (1LL \u0026lt;\u0026lt; (n / 2 + 1)); if((dp[i]\u0026amp;flag1) || (dp[i]\u0026amp;flag2)) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum - i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; } } } else { for(int i = sum / 2; i \u0026gt;= 0; --i) { if(dp[i] \u0026amp; (1LL \u0026lt;\u0026lt; (n / 2))) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum - i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; } } } if(T) cout \u0026lt;\u0026lt; endl; } return 0; } J - Arbitrage #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 void printPath(vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; \u0026amp;paths, int t, int i, int j) { if(t == 0) { cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j + 1; return; } printPath(paths, t - 1, i, paths[t][i][j]); cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j + 1; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int n; while(cin \u0026gt;\u0026gt; n) { vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; ct(n, vector\u0026lt;double\u0026gt;(n, 0)); for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { if(i == j) ct[i][j] = 1; else cin \u0026gt;\u0026gt; ct[i][j]; } } vector\u0026lt;vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt;\u0026gt; values(n, vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt;(n, vector\u0026lt;double\u0026gt;(n))); vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; paths(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(n, -1))); values[0] = ct; int item = -1, itemT = -1; for(int t = 1 ; t \u0026lt; n \u0026amp;\u0026amp; item == -1 ; ++t) { for(int i = 0 ; i \u0026lt; n \u0026amp;\u0026amp; item == -1 ; ++i) { for(int j = 0 ; j \u0026lt; n \u0026amp;\u0026amp; item == -1 ; ++j) { values[t][i][j] = -1.0; for(int k = 0 ; k \u0026lt; n ; ++k ) { double newRate = values[t - 1][i][k] * ct[k][j]; if(newRate \u0026gt; values[t][i][j]) { values[t][i][j] = newRate; paths[t][i][j] = k; } } } if(values[t][i][i] \u0026gt; 1.01) { item = i; itemT = t; break; } } } if(item == -1) cout \u0026lt;\u0026lt; \u0026#34;no arbitrage sequence exists\\n\u0026#34;; else { printPath(paths, itemT, item, item); cout \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2021-08-06T10:42:11+08:00","permalink":"https://blog.smallten.tk/p/star_coder-05/","title":"StarCoder2021æš‘è¨“ï¼šWeek04"},{"content":"ä¸»é¡Œ  åœ–ã€ç‹€æ…‹æœå°‹ã€æ‹“æ¨¸æ’åºã€å°¤æ‹‰è·¯  é¡Œç›®  Virtual Judge é¡Œç›®åˆ—è¡¨èˆ‡æç¤º    é¡Œç›® é¡Œç›®éœ€æ±‚ æ¡ç”¨æ¼”ç®—æ³• åŸºæœ¬é¡Œ     UVa 10004 ç„¡å‘åœ–çš„å…©è‰²è‘—è‰²å•é¡Œ DFS/BFS å‡å¯ V   UVa 10959 æ±‚ç„¡å‘ç„¡æ¬Šåœ–ä¸Šæ¯ä¸€é»å’Œä¸€æŒ‡å®šé»çš„æœ€çŸ­è·é›¢ BFS V   UVa 572 æ±‚äºŒç¶­åœ°åœ–ä¸Šçš„é€£é€šå¡Šæ•¸é‡ DFS/BFS å‡å¯ V   UVa 441 çµ¦å®š k å€‹æ•¸ï¼Œç”±å°åˆ°å¤§åˆ—å‡ºæ‰€æœ‰åŒ…å«å…¶ä¸­ 6 å€‹æ•¸çš„éå¢æ•¸åˆ— DFS    UVa 567 æ±‚ç„¡å‘ç„¡æ¬Šåœ–ä¸ŠæŒ‡å®šå…©é»é–“çš„æœ€çŸ­è·é›¢ BFS (æˆ–ç”¨å¾Œé¢æœƒå­¸åˆ°çš„ Floyd-Warshall æ¼”ç®—æ³•) V   UVa 10926 çµ¦æœ‰å‘ç„¡ç’°åœ–ï¼Œæ±‚æœ€å¤§ä¸€æ£µæ¨¹çš„ç¯€é»æ•¸æ¸›1 DFS/BFS å‡å¯    SPOJ PT07Z æ±‚æ•¸ç›´å¾‘ï¼ˆç¶“å…¸é¡Œï¼‰ DFS/BFS å‡å¯    UVa 10603 å€’æ°´å•é¡Œï¼ˆçµ¦ä¸‰å€‹æ°´ç“¶ï¼Œå€’å‡ºæŒ‡å®šæ°´é‡ï¼‰ BFS è®Šå‹ (å¸¶æ¬Šæœ€çŸ­è·¯)    UVa 10305 çµ¦å®š n å€‹å·¥ä½œçš„å…©å…©å…ˆå¾Œé—œä¿‚ï¼Œè¼¸å‡ºä»»ä¸€å€‹åˆæ³•çš„å·¥ä½œå®Œæˆé †åºã€‚ æ‹“æ¨¸æ’åº V   UVa 1423 çµ¦å®šä¸€æ•¸åˆ—ä¸­ Sij = a[i]+â€¦+a[j] çš„æ­£è² è™Ÿï¼Œè¼¸å‡ºä¸€çµ„ç¬¦åˆæ­£è² è™Ÿé—œä¿‚çš„æ•¸åˆ—ã€‚(æœ‰è¶£ï¼Œå€¼å¾—æ€è€ƒï¼) æ‹“æ¨¸æ’åº    UVa 302 çµ¦å®šä¸€å€‹ç„¡å‘åœ–å’ŒæŒ‡å®šèµ·é»ï¼Œåˆ—å°å°¤æ‹‰è·¯ã€‚ å°¤æ‹‰è·¯    UVa 10441 çµ¦å®šä¸€å †å­—ä¸²ï¼Œå•å¦‚ä½•å°‡å®ƒå€‘é ­å°¾ç›¸é€£ä¸²èµ·ä¾†ã€‚ å°¤æ‹‰è·¯       åƒè€ƒä½œæ³• A - Bicoloring #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; bool a[205][205]; int p[205]; bool dfs(int x, int n, int color) { if(p[x]) { if(p[x] != color) return false; else return true; } p[x] = color; bool ans = true; for(int i = x + 1; i \u0026lt; n; ++i) { if(a[x][i]) ans = dfs(i, n, (color == 1) ? 2 : 1); } return ans; } int main() { USE_CPPIO(); int n, e; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { cin \u0026gt;\u0026gt; e; memset(a, false, sizeof(a)); memset(p, 0x00, sizeof(p)); int u, v; for(int i = 0; i \u0026lt; e; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; a[u][v] = a[v][u] = true; } if(dfs(0, n, 1)) cout \u0026lt;\u0026lt; \u0026#34;BICOLORABLE.\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NOT BICOLORABLE.\\n\u0026#34;; } return 0; } B - The Party, Part I #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; bool a[1005][1005]; int d[1005], n, m; void bfs() { for(int i = 0; i \u0026lt; n; ++i) d[i] = n; d[0] = 0; queue\u0026lt;int\u0026gt; q; q.push(0); while (!q.empty()) { int now = q.front(); q.pop(); for(int i = 0; i \u0026lt; n; ++i) { if(a[now][i] \u0026amp;\u0026amp; d[i] \u0026gt; d[now] + 1) { d[i] = d[now] + 1; q.push(i); } } } } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { memset(a, false, sizeof(a)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int u, v; for(int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; a[u][v] = a[v][u] = true; } bfs(); for(int i = 1; i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if(T) cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } C - Oil Deposits #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, m, ans; char g[105][105]; int d[8][2] = {{1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}, {0, 1}}; void dfs(int x, int y) { g[x][y] = \u0026#39;*\u0026#39;; for(int i = 0; i \u0026lt; 8; ++i) { int dx = x + d[i][0], dy = y + d[i][1]; if(dx \u0026gt;= 0 \u0026amp;\u0026amp; dx \u0026lt; n \u0026amp;\u0026amp; dy \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026lt; m \u0026amp;\u0026amp; g[dx][dy] == \u0026#39;@\u0026#39;) { dfs(dx, dy); } } } int main() { USE_CPPIO(); while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { ans = 0; string s; for(int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; s; for(int j = 0; j \u0026lt; m; ++j) g[i][j] = s[j]; } for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; m; ++j) { if(g[i][j] == \u0026#39;@\u0026#39;) { dfs(i, j); ++ans; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } D - Lotto #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, a[15], ans[15]; bool u[15]; void dfs(int x, int t) { if(t == 6) { for(int i = 0; i \u0026lt; 5; ++i) cout \u0026lt;\u0026lt; ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; ans[5] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } for(int i = x; i \u0026lt; n; ++i) { if(!u[i]) { u[i] = true; ans[t] = a[i]; dfs(i + 1, t + 1); u[i] = false; } } } int main() { USE_CPPIO(); int cnt = 0; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { if(cnt++) cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; memset(u, false, sizeof(u)); for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; dfs(0, 0); } return 0; } E - Risk #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int main() { int cnt = 0, g[21][21], n; while(cin \u0026gt;\u0026gt; n) { memset(g, INF, sizeof(g)); for(int i = 1; i \u0026lt;= 19; ++i) { int a; for(int j = 0; j \u0026lt; n; ++j) { cin \u0026gt;\u0026gt; a; g[i][a] = g[a][i] = 1; } if(i \u0026lt; 19) cin \u0026gt;\u0026gt; n; } for(int k = 1; k \u0026lt;= 20; ++k) { for(int i = 1; i \u0026lt;= 20; ++i) { for(int j = 1; j \u0026lt;= 20; ++j) { g[i][j] = min(g[i][j], g[i][k] + g[k][j]); } } } cout \u0026lt;\u0026lt; \u0026#34;Test Set #\u0026#34; \u0026lt;\u0026lt; ++cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; printf(\u0026#34;%2d to %2d: %d\\n\u0026#34;, a, b, g[a][b]); } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } F - How Many Dependencies? #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, a[105]; vector\u0026lt;int\u0026gt; g[105]; int dfs(int x) { if(a[x] != -1) return a[x]; int t = 0; for(auto i : g[x]) t = max(t, dfs(i)); return a[x] = t + 1; } int main() { USE_CPPIO(); int n; while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for(int i = 0; i \u0026lt; 105; ++i) g[i].clear(); memset(a, -1, sizeof(a)); for(int i = 1; i \u0026lt;= n; ++i) { int t, b; cin \u0026gt;\u0026gt; t; while(t--) { cin \u0026gt;\u0026gt; b; g[i].push_back(b); } } int ans = 1, most = 0; for(int i = 1; i \u0026lt;= n; ++i) { int t = dfs(i); if(t \u0026gt; most) { most = t; ans = i; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } G - Longest path in a tree #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, ans = 0; vector\u0026lt;int\u0026gt; g[10005]; bool vis[10005]; int dfs(int x, int y) { int ans1 = 0, ans2 = 0; for(auto i : g[x]) { if(i == y) continue; int t = dfs(i, x); if(t \u0026gt; ans1) { ans2 = ans1; ans1 = t; } else if(t \u0026gt; ans2) { ans2 = t; } } if(ans1 + ans2 \u0026gt; ans) ans = ans1 + ans2; return ans1 + 1; } int main() { USE_CPPIO(); cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } H - Fill #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; struct node { int v[3], dist; bool operator\u0026lt;(const node \u0026amp;r) const { return dist \u0026gt; r.dist; } }; int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int cup[3], d, ans[205]; bool vis[205][205]; cin \u0026gt;\u0026gt; cup[0] \u0026gt;\u0026gt; cup[1] \u0026gt;\u0026gt; cup[2] \u0026gt;\u0026gt; d; memset(vis, false, sizeof(vis)); memset(ans, -1, sizeof(ans)); priority_queue\u0026lt;node\u0026gt; pq; pq.push({0, 0, cup[2], 0}); vis[0][0] = true; while(!pq.empty()) { node now = pq.top(); pq.pop(); for(int i = 0; i \u0026lt; 3; ++i) { int t = now.v[i]; if(ans[t] \u0026lt; 0 || now.dist \u0026lt; ans[t]) ans[t] = now.dist; } if(ans[d] \u0026gt; 0) break; for(int i = 0; i \u0026lt; 3; ++i) { for(int j = 0; j \u0026lt; 3; ++j) { if(i != j) { if(now.v[i] == 0 || now.v[j] == cup[j]) continue; int amount = min(cup[j], now.v[i] + now.v[j]) - now.v[j]; node tmp = now; tmp.dist = now.dist + amount; tmp.v[i] -= amount; tmp.v[j] += amount; if(!vis[tmp.v[0]][tmp.v[1]]) { vis[tmp.v[0]][tmp.v[1]] = true; pq.push(tmp); } } } } } while(d \u0026gt;= 0) { if(ans[d] \u0026gt;= 0) { cout \u0026lt;\u0026lt; ans[d] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; break; } --d; } } return 0; } I - Ordering Tasks #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int main() { USE_CPPIO(); int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { if(n == 0 \u0026amp;\u0026amp; m == 0) break; int indeg[105] = {0}, cnt = 0; vector\u0026lt;int\u0026gt; g[101]; for(int i = 0; i \u0026lt; m; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); ++indeg[v]; } for(int i = 1; i \u0026lt;= n; ++i) { if(indeg[i] == 0) { if(cnt \u0026lt; n) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++cnt; indeg[i] = -1; for(auto j : g[i]) --indeg[j]; } if(cnt == n) break; else if(i == n) i = 0; } cout \u0026lt;\u0026lt; endl; } return 0; } J - Guess #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, indeg[15], a[15]; string s; vector\u0026lt;int\u0026gt; g[15]; void addEdge(int u, int v) { ++indeg[v]; g[u].push_back(v); } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; memset(indeg, 0, sizeof(indeg)); for(int i = 0; i \u0026lt;= n; ++i) g[i].clear(); int pos = 0; for(int i = 0; i \u0026lt;= n; ++i) { for(int j = i + 1; j \u0026lt;= n; ++j) { if(s[pos] == \u0026#39;+\u0026#39;) addEdge(i, j); else if(s[pos] == \u0026#39;-\u0026#39;) addEdge(j, i); ++pos; } } int d = 0; queue\u0026lt;int\u0026gt; q; for(int i = 0; i \u0026lt;= n; ++i) if(indeg[i] == 0) q.push(i); while(!q.empty()) { int sz = q.size(); for(int i = 0; i \u0026lt; sz; ++i) { int f = q.front(); q.pop(); a[f] = d; for(auto j : g[f]) { --indeg[j]; if(indeg[j] == 0) q.push(j); } } ++d; } for(int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] - a[i - 1] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n]; } return 0; } K - John\u0026rsquo;s trip #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int g[50][2010], cnt[50], nRoads, nPoints, start; bool vis[2010]; stack\u0026lt;int\u0026gt; st; void init() { nRoads = nPoints = 0; while(!st.empty()) st.pop(); memset(g, 0, sizeof(g)); memset(cnt, 0, sizeof(cnt)); memset(vis, false, sizeof(vis)); } void euler(int u) { for(int v = 1; v \u0026lt;= nRoads; ++v) { if(!vis[v] \u0026amp;\u0026amp; g[u][v]) { vis[v] = true; euler(g[u][v]); st.push(v); } } } void solve() { bool flag = false; for(int i = 1; i \u0026lt; 50; ++i) { if(cnt[i] % 2) { flag = true; break; } } if(flag) cout \u0026lt;\u0026lt; \u0026#34;Round trip does not exist.\\n\u0026#34;; else { euler(start); bool ff = false; while(!st.empty()) { if(ff) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; st.top(); st.pop(); ff = true; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { USE_CPPIO(); int x, y, z, t = 0; bool flag = false; init(); while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { ++t; if(x == 0 \u0026amp;\u0026amp; y == 0) { if(flag) break; flag = true; t = 0; solve(); init(); continue; } flag = false; cin \u0026gt;\u0026gt; z; if(t == 1) start = min(x, y); nRoads = max(nRoads, z); nPoints = max(nPoints, max(x, y)); g[x][z] = y; g[y][z] = x; ++cnt[x]; ++cnt[y]; } return 0; } L - Catenyms #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, dsu[26], cnt, tot, indeg[26], outdeg[26]; bool vis[26], used[26][1005]; vector\u0026lt;string\u0026gt; g[26], ans; void init() { cnt = 1, tot = 0; memset(indeg, 0, sizeof(indeg)); memset(outdeg, 0, sizeof(outdeg)); memset(vis, false, sizeof(vis)); memset(used, false, sizeof(used)); for(int i = 0; i \u0026lt; 26; ++i) { g[i].clear(); dsu[i] = i; } ans.clear(); } int Find(int x) { if(dsu[x] == x) return x; return dsu[x] = Find(dsu[x]); } void euler(int u) { for(int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i][g[u][i].length() - 1] - \u0026#39;a\u0026#39;; if(!used[u][i]) { used[u][i] = true; euler(v); ans.push_back(g[u][i]); } } } bool solve() { if(cnt != tot) return false; int t = INF, odd = 0, q; for(int i = 0; i \u0026lt; 26; ++i) { if(g[i].size()) t = min(t, i); if(outdeg[i] - indeg[i] == 1) { ++odd; q = i; } else if(indeg[i] - outdeg[i] == 1) ++odd; else if(indeg[i] != outdeg[i]) return false; if(odd \u0026gt; 2) return false; } if(!odd) euler(t); else euler(q); for(int i = ans.size() - 1; i \u0026gt; 0; --i) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; cout \u0026lt;\u0026lt; ans[0] \u0026lt;\u0026lt; endl; return true; } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { init(); cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++i) { string s; cin \u0026gt;\u0026gt; s; int u = s[0] - \u0026#39;a\u0026#39;, v = s[s.length() - 1] - \u0026#39;a\u0026#39;; if(!vis[u]) { vis[u] = true; ++tot; } if(!vis[v]) { vis[v] = true; ++tot; } ++indeg[v]; ++outdeg[u]; g[u].push_back(s); int x = Find(u), y = Find(v); if(x != y) { dsu[x] = y; ++cnt; } } for(int i = 0; i \u0026lt; 26; ++i) sort(g[i].begin(), g[i].end()); if(!solve()) cout \u0026lt;\u0026lt; \u0026#34;***\\n\u0026#34;; } return 0; } ","date":"2021-07-28T05:48:25+08:00","permalink":"https://blog.smallten.tk/p/star_coder-04/","title":"StarCoder2021æš‘è¨“ï¼šWeek03"},{"content":" ä¸‹è¼‰ NPS Clientsï¼Œä¸¦æ”¾åˆ°ä¸€å€‹è³‡æ–™å¤¾ä¸­ã€‚ ä¸‹è¼‰ pkg2Zipï¼Œä¸¦å°‡ pkg2zip.exe æ”¾åˆ°åŒä¸€å€‹è³‡æ–™å¤¾ä¸­ã€‚ åŸ·è¡Œ NPS_Browser.exeã€‚ è¤‡è£½ä»¥ä¸‹é€£çµï¼š  Games  PSV tsv http://nopaystation.com/tsv/PSV_GAMES.tsv PSM tsv http://nopaystation.com/tsv/PSM_GAMES.tsv PSX tsv http://nopaystation.com/tsv/PSX_GAMES.tsv PSP tsv http://nopaystation.com/tsv/PSP_GAMES.tsv PS3 tsv http://nopaystation.com/tsv/PS3_GAMES.tsv   DLCs:  PSV tsv http://nopaystation.com/tsv/PSV_DLCS.tsv PSP tsv http://nopaystation.com/tsv/PSP_DLCS.tsv PS3 tsv http://nopaystation.com/tsv/PS3_DLCS.tsv   Themes:  PSV tsv http://nopaystation.com/tsv/PSV_THEMES.tsv     è¨­å®š Download and unpack dir: æª”æ¡ˆä¸‹è¼‰å¾Œçš„ä½ç½®ã€‚ è¨­å®š Any pkg dec tool: è·¯å¾‘ç‚º pkg2Zip.exe çš„ä½ç½®ã€‚ è¨­å®š Your pkg dec params: -x {pkgFile} \u0026quot;{zRifKey}\u0026quot;ã€‚ è¨­å®š HMAC key for updates: E5E278AA1EE34082A088279C83F9BBC806821C52F2AB5D2B4ABD995450355114ã€‚ è¨­å®š CompPack URL: https://gitlab.com/nopaystation_repos/nps_compati_packs/raw/master/entries.txt è¨­å®š CompPack Patch URL: https://gitlab.com/nopaystation_repos/nps_compati_packs/raw/master/entries_patch.txt é‡æ–°å•Ÿå‹• NPS Browserã€‚ ä¸‹è¼‰ä½ è¦çš„æª”æ¡ˆï¼Œä¸¦å°‡å…¶æ”¾é€² PSV å°æ‡‰è·¯å¾‘ä¸­ã€‚ é€²å…¥ Vita Shellï¼ŒæŒ‰ä¸‹ä¸‰è§’å½¢æŒ‰éˆ•ï¼Œé¸æ“‡ Refresh LiveArea  ","date":"2021-07-26T11:50:17+08:00","permalink":"https://blog.smallten.tk/p/psv-03/","title":"PlayStation Vita-03ï¼šNoPayStation Browser"},{"content":" åœ¨ PSV åŸ·è¡Œ Vita Shellï¼Œç„¶å¾ŒæŒ‰ä¸€ä¸‹ Select æŒ‰éˆ•ï¼Œæœ€å¾Œä»¥ USB é€£æ¥ PCã€‚ ä¸‹è¼‰ NoNpDrmï¼Œä¸¦å°‡ nonpdrm.skprx æ”¾é€² tai è³‡æ–™å¤¾ä¸­ã€‚ å›åˆ° PSV çš„ Vita Shell ä¸­ï¼Œä¸¦åˆ°é” ux0:tai/ï¼Œé¸æ“‡ config.txtã€‚ æ‰¾åˆ°ä¸¦ç§»åˆ° *KERNEL é‚£è¡Œï¼ŒæŒ‰ä¸€ä¸‹ä¸‰è§’å½¢æŒ‰éˆ•ï¼Œé¸ Insert empty lineã€‚ é¸æ“‡ä¸‹æ–¹æ–°å¢çš„ç©ºç™½è¡Œï¼Œä¸¦è¼¸å…¥ ux0:tai/nonpdrm.skprxï¼Œç„¶å¾Œå„²å­˜é›¢é–‹ã€‚ åˆ°è¨­å®šä¸­çš„ HENkaku è¨­ç½®ï¼Œé¸æ“‡ é‡è¼‰ taiHEN config.txtã€‚ é‡æ–°å•Ÿå‹• PSVã€‚  ","date":"2021-07-26T11:46:32+08:00","permalink":"https://blog.smallten.tk/p/psv-02/","title":"PlayStation Vita-02ï¼šNoNpDrm"},{"content":" ä¸‹è¼‰ Qcma ä¸¦å®‰è£åˆ°é›»è…¦ä¸Šã€‚ PSV ä»¥ USB çš„æ–¹å¼é€£æ¥åˆ° PCã€‚ ä¸‹è¼‰ Final h-encoreï¼Œç„¶å¾Œå°‡å…¶è§£å£“ç¸®ï¼Œæœ€å¾ŒåŸ·è¡Œå®ƒã€‚ é»æ“Š Let\u0026rsquo;s Go ï¼Œç„¶å¾Œç­‰åˆ° 100% å®Œæˆã€‚ å›åˆ° PSV çš„æª”æ¡ˆç®¡ç† (Content Manager)ï¼Œç„¶å¾Œé¸æ“‡è¤‡è£½å…§å®¹(Copy Content) PC to PSVï¼Œä¹‹å¾Œ Applications \u0026gt; PS Vitaï¼Œæœ€å¾Œé¸ h-encore 2 å†æŒ‰ è¤‡è£½(Copy) \u0026gt; OKã€‚ æ‹”æ‰ USBï¼ŒåŸ·è¡Œ PSV æ¡Œé¢ä¸Šçš„ h-encore 2ã€‚ PSV è¨˜å¾—è¦é€£ç¶²ï¼Œç„¶å¾Œé¸ Install HENkaku \u0026gt; Download VitaShell \u0026gt; Exit åˆ°è¨­å®šç¢ºèªç³»çµ±è³‡è¨Šï¼Œç¢ºèªæˆåŠŸå¾Œï¼Œå†å»è¨­å®š HENkakuã€‚   ä¹‹å¾Œè‹¥æœ‰é‡é–‹æ©Ÿçš„è©±ï¼Œå¾—é‡æ–°é€²å…¥ h-encore 2 å†é›¢é–‹å³å¯ã€‚\n ","date":"2021-07-26T11:04:05+08:00","permalink":"https://blog.smallten.tk/p/psv-01/","title":"PlayStation Vita-01ï¼šH-encore 2"},{"content":"ä¸»é¡Œ  STLã€ä½µæŸ¥é›†  ä½µæŸ¥é›†æ¨¡æ¿ int dsu[MAX_N]; void init(int num) { for(int i = 0; i \u0026lt;= num; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } é¡Œç›®  Virtual Judge é¡Œç›®åˆ—è¡¨èˆ‡æç¤º    é¡Œç›® é¡Œç›®éœ€æ±‚ æ¡ç”¨çµæ§‹ å„ªå…ˆç·´ç¿’     UVa 673 æ‹¬è™ŸåŒ¹é…èˆ‡ LIFO æ“ä½œ std::stack v   UVa 442 æ‹¬è™ŸåŒ¹é…èˆ‡ LIFO æ“ä½œ std::stack    UVa 12100 éæ­·å’Œ FIFO æ“ä½œ std::queue (åŠ ä¸Š std::priority_queue æ•ˆç‡æ›´é«˜) v   UVa 245 å–å‡ºç¬¬ n å€‹ä»¥åŠæ’å…¥é ­ç«¯ std::list / std::deque / std::vector    UVa 1203 æ’å…¥èˆ‡å–å‡ºæœ€å°å€¼ std::priority_queue v   UVa 11995 æ¨¡æ“¬ stack, queue, priority_queue std::stack, std::queue, std::priority_queue v   UVa 10583 æ¨™æº–ä½µæŸ¥é›†æ“ä½œ disjoint set v   UVa 11987 ä½µæŸ¥é›†çš„è®ŠåŒ–é¡Œ(å€¼å¾—æ€è€ƒ) disjoint set    UVa 1665 åˆ¤æ–·é€£é€šå¡Šæ•¸ disjoint set    UVa 230 å­—ä¸²æ’åºèˆ‡æœå°‹ std::map / std::set v   UVa 1592 å­—ä¸²æ¯”è¼ƒï¼ˆå°‡å­—ä¸²è½‰æˆæ•¸å€¼ä»¥åŠ å¿«æ¯”è¼ƒï¼‰ std::map       åƒè€ƒä½œæ³• A - Parentheses Balance #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; cin.ignore(100, \u0026#39;\\n\u0026#39;); while(n--) { string s; getline(cin, s); stack\u0026lt;char\u0026gt; st; for(auto \u0026amp;i : s) { if(i == \u0026#39;]\u0026#39;) { if(!st.empty() \u0026amp;\u0026amp; st.top() == \u0026#39;[\u0026#39;) st.pop(); else st.emplace(i); } else if(i == \u0026#39;)\u0026#39;) { if(!st.empty() \u0026amp;\u0026amp; st.top() == \u0026#39;(\u0026#39;) st.pop(); else st.emplace(i); } else st.emplace(i); } cout \u0026lt;\u0026lt; (st.empty() ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } B - Matrix Chain Multiplication #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Matrix { int row, col; }; int main() { int n, errCnt = -1; cin \u0026gt;\u0026gt; n; map\u0026lt;char, Matrix\u0026gt; ma; for(int i = 0; i \u0026lt; n; ++i) { char name; Matrix m; cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; m.row \u0026gt;\u0026gt; m.col; ma[name] = m; } string s; while(cin \u0026gt;\u0026gt; s) { int multiCnt = 0; stack\u0026lt;Matrix\u0026gt; st; for(int i = 0; i \u0026lt; s.length(); ++i) { if(s[i] == \u0026#39;(\u0026#39;) continue; if(s[i] != \u0026#39;)\u0026#39;) { st.push(ma[s[i]]); continue; } Matrix b = st.top(); st.pop(); Matrix a = st.top(); st.pop(); if(a.col != b.row) { multiCnt = errCnt; break; } multiCnt += a.row * b.row * b.col; st.push({a.row, b.col}); } if(multiCnt == errCnt) cout \u0026lt;\u0026lt; \u0026#34;error\\n\u0026#34;; else cout \u0026lt;\u0026lt; multiCnt \u0026lt;\u0026lt; endl; } return 0; } C - Printer Queue #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; deque\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dq; int t[10] = {0}; for(int i = 0; i \u0026lt; n; ++i) { int a; cin \u0026gt;\u0026gt; a; dq.emplace_back(a, i); ++t[a]; } int cnt = 0; int lev, idx; while(true) { tie(lev, idx) = dq.front(); int canPop = 1; for(int i = lev + 1; i \u0026lt; 10; ++i) canPop \u0026amp;= (t[i] == 0); if(canPop) { ++cnt; --t[lev]; if(idx == m) break; dq.pop_front(); } else { dq.push_back(dq.front()); dq.pop_front(); } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } D - Uncompress #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { vector\u0026lt;string\u0026gt; vs; string buf; while (getline(cin, buf) \u0026amp;\u0026amp; buf[0] != \u0026#39;0\u0026#39;) { string s; for (int i = 0; buf[i]; ++ i) { if (isalpha(buf[i])) { s = \u0026#34;\u0026#34;; while (isalpha(buf[i])) s.insert(s.end(), buf[i ++]); vs.push_back(s); --i; cout \u0026lt;\u0026lt; s; } else if (isdigit(buf[i])) { int value = 0; while (isdigit(buf[i])) value = value * 10 + buf[i ++] - \u0026#39;0\u0026#39;; s = vs[vs.size() - value]; vs.erase(vs.end() - value); vs.push_back(s); --i; cout \u0026lt;\u0026lt; s; } else printf(\u0026#34;%c\u0026#34;, buf[i]); } puts(\u0026#34;\u0026#34;); } return 0; } E - Argus #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using tiii = tuple\u0026lt;int, int, int\u0026gt;; // time, query_num, period int main() { priority_queue\u0026lt;tiii, vector\u0026lt;tiii\u0026gt;, greater\u0026lt;tiii\u0026gt;\u0026gt; pq; string s; int q, p, cur, n; while(cin \u0026gt;\u0026gt; s \u0026amp;\u0026amp; s != \u0026#34;#\u0026#34; \u0026amp;\u0026amp; cin \u0026gt;\u0026gt; q \u0026gt;\u0026gt; p) pq.push(make_tuple(p, q, p)); cin \u0026gt;\u0026gt; n; while(n--) { tie(cur, q, p) = pq.top(); pq.pop(); cout \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pq.push(make_tuple(cur + p, q, p)); } return 0; } F - I Can Guess the Data Structure! #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int main() { USE_CPPIO(); int n; while(cin \u0026gt;\u0026gt; n) { bool flag[3]; memset(flag, true, sizeof(flag)); stack\u0026lt;int\u0026gt; st; queue\u0026lt;int\u0026gt; qu; priority_queue\u0026lt;int\u0026gt; pq; int a, b; for(int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(a == 1) { st.push(b); qu.push(b); pq.push(b); } else if(a == 2) { if(flag[0]) { if(!st.empty() \u0026amp;\u0026amp; st.top() == b) st.pop(); else flag[0] = false; } if(flag[1]) { if(!qu.empty() \u0026amp;\u0026amp; qu.front() == b) qu.pop(); else flag[1] = false; } if(flag[2]) { if(!pq.empty() \u0026amp;\u0026amp; pq.top() == b) pq.pop(); else flag[2] = false; } } } if((flag[0] \u0026amp;\u0026amp; flag[1])||(flag[1] \u0026amp;\u0026amp; flag[2])||(flag[2] \u0026amp;\u0026amp; flag[0])) cout\u0026lt;\u0026lt;\u0026#34;not sure\\n\u0026#34;; else if(flag[0]) cout\u0026lt;\u0026lt;\u0026#34;stack\\n\u0026#34;; else if(flag[1]) cout\u0026lt;\u0026lt;\u0026#34;queue\\n\u0026#34;; else if(flag[2]) cout\u0026lt;\u0026lt;\u0026#34;priority queue\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;impossible\\n\u0026#34;; } return 0; } G - Ubiquitous Religions #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int dsu[50005]; void init(int n) { for(int i = 0; i \u0026lt; n; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x); int b = Find(y); if(a == b) return false; dsu[a] = b; return true; } int main() { USE_CPPIO(); int n, m, Case = 1; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { init(n); int cnt = n; for(int i = 0; i \u0026lt; m; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(Union(a - 1, b - 1)) --cnt; } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; Case++ \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } H - Almost Union-Find #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int dsu[200005], num[200005], sum[200005]; void init(int n) { for(int i = 0; i \u0026lt;= n; ++i) { dsu[i] = dsu[i + n] = i + n; sum[i] = sum[i + n] = i; num[i] = num[i + n] = 1; } } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } int main() { USE_CPPIO(); int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { init(n); for(int i = 0; i \u0026lt; m; ++i) { int t, a, b; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; a; if(t == 1) { cin \u0026gt;\u0026gt; b; int x = Find(a); int y = Find(b); if(x == y) continue; dsu[x] = y; num[y] += num[x]; sum[y] += sum[x]; } else if(t == 2) { cin \u0026gt;\u0026gt; b; int x = Find(a); int y = Find(b); if(x == y) continue; dsu[a] = y; --num[x]; ++num[y]; sum[x] -= a; sum[y] += a; } else if(t == 3) { int x = Find(a); cout \u0026lt;\u0026lt; num[x] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum[x] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } return 0; } I - Islands #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int n, m, total, dsu[1000010]; int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0}; struct Point { int x, y, id, height; }; vector\u0026lt;Point\u0026gt; vp; bool cmp(Point a, Point b) { return a.height \u0026gt; b.height; } int Find(int t) { if(t == -1) return -1; if(dsu[t] == t) return t; return dsu[t] = Find(dsu[t]); } void add(int idx) { int id = vp[idx].id; dsu[id] = id; ++total; for(int i = 0; i \u0026lt; 4; ++i) { int x = vp[idx].x + dx[i]; int y = vp[idx].y + dy[i]; if(x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; m) { int id2 = x * m + y; int root_id2 = Find(id2); if(root_id2 == -1) continue; if(root_id2 != id) { --total; dsu[root_id2] = id; } } } } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vp.clear(); vector\u0026lt;int\u0026gt; h; for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; m; ++j) { int t; cin \u0026gt;\u0026gt; t; Point p = {i, j, i * m + j, t}; vp.push_back(p); dsu[i * m + j] = -1; } } sort(vp.begin(), vp.end(), cmp); int q; cin \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; q; ++i) { int t; cin \u0026gt;\u0026gt; t; h.push_back(t); } int idx = 0; total = 0; for(int i = h.size() - 1; i \u0026gt;= 0; --i) { while(idx \u0026lt; vp.size() \u0026amp;\u0026amp; h[i] \u0026lt; vp[idx].height) add(idx++); h[i] = total; } for(auto i : h) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return 0; } J - Borrowers #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; map\u0026lt;string, string\u0026gt; mss; struct ReturnBook { string title; string author; }; bool cmp(string b1, string b2) { string a1 = mss[b1]; string a2 = mss[b2]; if(a1 != a2) return a1 \u0026lt; a2; return b1 \u0026lt; b2; } bool cmp_return(ReturnBook b1, ReturnBook b2) { if(b1.author != b2.author) return b1.author \u0026lt; b2.author; return b1.title \u0026lt; b2.title; } int main() { USE_CPPIO(); string s; vector\u0026lt;string\u0026gt; shelve; vector\u0026lt;ReturnBook\u0026gt; vRB; while(getline(cin, s)) { if(s == \u0026#34;END\u0026#34;) break; int idx = s.find(\u0026#34;\\\u0026#34;by\u0026#34;); string title = s.substr(0, idx + 1); string author = s.substr(idx + 4); mss[title] = author; shelve.push_back(title); } sort(shelve.begin(), shelve.end(), cmp); while(getline(cin, s)) { if(s == \u0026#34;END\u0026#34;) break; if(s == \u0026#34;SHELVE\u0026#34;) { sort(vRB.begin(), vRB.end(), cmp_return); for(int i = 0; i \u0026lt; vRB.size(); ++i) { auto it = lower_bound(shelve.begin(), shelve.end(), vRB[i].title, cmp); if(it == shelve.begin()) cout \u0026lt;\u0026lt; \u0026#34;Put \u0026#34; \u0026lt;\u0026lt; vRB[i].title \u0026lt;\u0026lt; \u0026#34; first\u0026#34; \u0026lt;\u0026lt; endl; else { int t = it - shelve.begin() - 1; cout \u0026lt;\u0026lt; \u0026#34;Put \u0026#34; \u0026lt;\u0026lt; vRB[i].title \u0026lt;\u0026lt; \u0026#34; after \u0026#34; \u0026lt;\u0026lt; shelve[t] \u0026lt;\u0026lt; endl; } shelve.insert(it, vRB[i].title); } vRB.clear(); cout \u0026lt;\u0026lt; \u0026#34;END\\n\u0026#34;; } else { int idx = s.find(\u0026#34;\\\u0026#34;\u0026#34;); string title = s.substr(idx); if(s[0] == \u0026#39;B\u0026#39;) { auto it = lower_bound(shelve.begin(), shelve.end(), title, cmp); shelve.erase(it); } else vRB.push_back({title, mss[title]}); } } return 0; } K - Database #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; map\u0026lt;string, int\u0026gt; ID; int idx = 1; int StrID(string str) { if(ID[str]) return ID[str]; return ID[str] = idx++; } int main() { USE_CPPIO(); int row, col; while(cin \u0026gt;\u0026gt; row \u0026gt;\u0026gt; col) { cin.get(); int IDtable[row + 2][col + 2]; string table[row + 2][col + 2], tmp; for(int i = 1; i \u0026lt;= row; ++i) { getline(cin, tmp); char *pch = strtok((char*)tmp.c_str(), \u0026#34;,\u0026#34;); int j = 1; while(pch) { table[i][j++] = pch; pch = strtok(NULL, \u0026#34;,\u0026#34;); } } for(int i = 1; i \u0026lt;= row; ++i) { for(int j = 1; j \u0026lt;= col; ++j) { IDtable[i][j] = StrID(table[i][j]); } } bool flag = true; for(int i = 1; i \u0026lt;= col \u0026amp;\u0026amp; flag; ++i) { for(int j = i + 1; j \u0026lt;= col \u0026amp;\u0026amp; flag; ++j) { map\u0026lt;int, int\u0026gt; mii; for(int k = 1; k \u0026lt;= row \u0026amp;\u0026amp; flag; ++k) { int idx = IDtable[k][i] * 100000 + IDtable[k][j]; if(mii.count(idx)) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; mii[idx] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; flag = false; } else mii[idx] = k; } } } if(flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-07-24T08:26:57+08:00","permalink":"https://blog.smallten.tk/p/star_coder-03/","title":"StarCoder2021æš‘è¨“ï¼šWeek02"},{"content":"å‰æƒ…æè¦ â€ƒä¸€é–‹å§‹æ™‚ï¼Œå­¸é•·å€‘åœ¨ Messenger çš„ç¾¤çµ„è£¡å•æœ‰æ²’æœ‰äººè¦åƒåŠ é€™å ´æ–°æ‰‹å‘çš„ CTF ç«¶è³½ï¼Œæˆ‘æ˜¯æ²’æœ‰é¸æ“‡åƒåŠ çš„ (å› ç‚ºæˆ‘å¾ä¾†æ²’æœ‰æ·±å…¥çš„å»ç©ã€å­¸ç¿’é€™æ–¹é¢çš„æ±æ±ï¼Œå¯ä»¥ç®—æ˜¯å€‹ç´”æ­£çš„å°èŒæ–°~~)ï¼Œç„¶è€Œåˆ°æœ€å¾Œå› ç‚ºäººæ•¸çš„é—œä¿‚å­¸é•·å€‘çµ„æˆäº†å…©éšŠï¼Œç„¶å¾Œé‚„èƒ½å†å¤š 2 å€‹äººï¼Œå› æ­¤æˆ‘ä¹ŸåŠ å…¥æƒ³èªªå»è¦‹è¦‹ä¸–é¢ä¹Ÿå¥½ã€‚(å…¶ä¸­é‚„å¾—æ„Ÿè¬å­¸é•·å€‘çš„é¼“å‹µï¼Œä»¥åŠé¡˜æ„å¸¶æˆ‘é€™å€‹ä»€éº¼éƒ½ä¸æœƒçš„æ–°æ‰‹)ğŸ˜†ğŸ˜†\nç«¶è³½ç°¡ä»‹  R2S CTF ç«¶è³½ç¶²ç«™ Online Qualification : 7/16 - 18 Flag æ¨£å¼ï¼šR2S{}  æˆç¸¾  All: 7 / 81 Offical Only: 4 / 43      è§£é¡Œç´€éŒ„  ä»¥ä¸‹æ˜¯æˆ‘è§£çš„é¡Œç›®ï¼Œå…¶ä»–é¡Œç›®æˆ‘ç„¡èƒ½ç‚ºåŠ›ï¼Œå°±åªèƒ½çœ‹æœ‰æ²’æœ‰å­¸é•·å¯«é¡Œè§£äº†(é¡†é¡†  Welcome  Welcome to R2S CTF o((\u0026gt;Ï‰\u0026lt; ))o  åœ¨ R2S Discord ç¾¤çµ„ä¸­çš„ challenge-announcement é »é“ä¸­ï¼Œæœ‰é»‘é»‘çš„è¨Šæ¯è¦é»é–‹å°±èƒ½åˆ° Flag äº†ã€‚ ä¸€é–‹å§‹è¦ºå¾—å¾ˆé…·ï¼Œäº‹å¾ŒçŸ¥é“äº†é€™å«æš´é›·æ¨™ç±¤ ||æš´é›·è¨Šæ¯||ã€‚    Forensics  Headache  é€™é¡Œä¾ç…§ CRC32 æ‰¾å‡ºåœ–ç‰‡çš„é•·å¯¬ï¼Œä¸¦ç”¨ hex editor æŠŠ png çš„ header æ”¹æˆæ­£ç¢ºçš„å°±è¡Œäº†ã€‚    Crypto  Base1024  é€™é¡Œå°‡é‚£å † emoji è§£ç¢¼å¾Œå°±å¾—åˆ° Flag äº†ã€‚ ecojiã€ecoji ç·šä¸Šå·¥å…·   BiGGG_RSA  ä¸€é–‹å§‹ä¸çŸ¥é“æ€éº¼åˆ†è§£ Nï¼Œå°æ–¼ Factordb ä¾†èªªä¹Ÿå¤ªå¤§äº†ï¼Œè§£ä¸å‡ºä¾†ã€‚ä¹‹å¾Œåˆ°äº†é€™å€‹ primefac-forkï¼Œå†å¯«å€‹ç°¡å–®çš„ç¨‹å¼å°±è§£æ±ºäº†ã€‚   Seeeeed  ä¹Ÿæ˜¯ RSA ç›¸é—œé¡Œã€‚    Misc  Time Traveler  nc time-traveler.misc.quals.r2s.tw 5487 ä¾ç…§æ ¼å¼è¼¸å…¥ä¸¦è¨ˆç®—ä¸€ä¸‹ï¼Œå¼„åˆ° 1937 å¹´å°±æœ‰ Flag äº†ã€‚   Fat7z  ä¾ç…§çµ¦çš„ code åè‘—å¯«ï¼Œå°±èƒ½å¾—åˆ° Flag äº†ã€‚    Reverse  What is this!?  JavaSript aaencode å°‡è¨€æ–‡å­—è½‰å› jsï¼Œå†åŸ·è¡Œè£¡é¢çš„ function å°±è¡Œäº†ã€‚    Web  Chatroom  chatroom ä¸€æ¨£æ˜¯ JavaSript aaencode è¤‡è£½ä¸‹ä¾†ï¼ŒF12 ä¸Ÿ consoleï¼ŒFlag å°±å™´å‡ºä¾†äº†ã€‚    å¿ƒå¾— â€ƒé€™æ¬¡æ˜¯æˆ‘ç¬¬ä¸€æ¬¡åƒåŠ  CTF ç›¸é—œçš„ç«¶è³½ï¼Œé›–ç„¶å¹¾ä¹éƒ½ä¸å¤ªæœƒå¯«ï¼Œä¸»è¦çš„é¡Œç›®é‚„éƒ½æ˜¯å­¸é•·å€‘è§£é–‹çš„ï¼Œä½†é€™å ´æ¯”è³½ä¸­æˆ‘ä¾ç„¶å­¸åˆ°äº†ä¸å°‘æ–°çš„æŠ€å·§ï¼Œä¹Ÿå° CTF æœ‰äº†æ›´å¤šçš„èˆˆè¶£ï¼Œæœªä¾†ç¹¼çºŒåŠªåŠ›å§!\n","date":"2021-07-19T14:03:54+08:00","permalink":"https://blog.smallten.tk/p/experience-01/","title":"2021 R2S CTF"},{"content":"ä¸»é¡Œ  æœå°‹ã€æ’åºã€è²ªå¿ƒ  é¡Œç›®  Virtual Judge  åƒè€ƒä½œæ³• A - Flip Sort  é¡Œç›®èªªæ˜ï¼š  çµ¦ä¸€å †æ•¸å­—ï¼Œè¼¸å‡ºè¦äº¤æ›(åªèƒ½ç›¸é„°äº¤æ›)å¤šå°‘æ¬¡ï¼Œæ‰èƒ½ç”±å°åˆ°å¤§æ’å¥½ã€‚   è§£é¡Œæ€è·¯ï¼š  Bubble sort   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, a[1005]; while(cin \u0026gt;\u0026gt; n) { int ans = 0; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; for(int i = 0; i \u0026lt; n; ++i) { for(int j = n - 1; j \u0026gt; i; --j) { if(a[j] \u0026lt; a[j - 1]) { swap(a[j], a[j - 1]); ++ans; } } } cout \u0026lt;\u0026lt; \u0026#34;Minimum exchange operations : \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; }   B - Age Sort  é¡Œç›®èªªæ˜ï¼š  çµ¦ä¸€å †æ•¸å­—ï¼Œç”±å°åˆ°å¤§æ’åºã€‚   è§£é¡Œæ€è·¯ï¼š  std::sort() å°å¿ƒ Presentation error   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); int n; bool flag; while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { int a[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); flag = false; for(auto i : a) { if(flag) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; i; flag = true; } cout \u0026lt;\u0026lt; endl; } return 0; }   C - Conformity  é¡Œç›®èªªæ˜ï¼š  è¼¸å‡ºæœ€å¤šäººé¸æ“‡èª²çš„ç¨‹çµ„åˆçš„äººæ•¸ï¼Œè‹¥æ˜¯æœ€å¤šçš„æœ‰å¤šå€‹ï¼Œå°‡äººæ•¸ç›¸åŠ ã€‚   è§£é¡Œæ€è·¯ï¼š  å°‡æ¯è¡Œçš„èª²ç¨‹æ’åºå¾Œï¼Œå†ä¸Ÿå…¥ map ä¸­çµ±è¨ˆã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { int maxNum = 0, total = 0; map\u0026lt;string, int\u0026gt; msi; vector\u0026lt;string\u0026gt; vs; string input, line; while(n--) { line.clear(); vs.clear(); for(int i = 0; i \u0026lt; 5; ++i) { cin \u0026gt;\u0026gt; input; vs.push_back(input); } sort(vs.begin(), vs.end()); for(int i = 0; i \u0026lt; 5; ++i) line += vs[i]; ++msi[line]; } for(auto it = msi.begin(); it != msi.end(); ++it) if(it-\u0026gt;second \u0026gt; maxNum) maxNum = it -\u0026gt; second; for(auto it = msi.begin(); it != msi.end(); ++it) if(it-\u0026gt;second == maxNum) total += maxNum; cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } return 0; }   D - Guessing Game  é¡Œç›®èªªæ˜ï¼š  ä¾ç…§é¡Œç›®æ¨¡æ“¬ï¼Œçœ‹æœ‰æ²’æœ‰èªªè¬Šã€‚   è§£é¡Œæ€è·¯ï¼š  æ¨¡æ“¬æ“ä½œï¼Œæœ€å¾Œçœ‹ right on çš„å€¼æœ‰æ²’æœ‰åœ¨å€é–“ä¸­ã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; while(scanf(\u0026#34;%d \u0026#34;, \u0026amp;n) != EOF \u0026amp;\u0026amp; n != 0) { int s = 1, e = 10; string str; while(getline(cin, str) \u0026amp;\u0026amp; str != \u0026#34;right on\u0026#34;) { if(str == \u0026#34;too high\u0026#34;) e = min(e, n - 1); else if(str == \u0026#34;too low\u0026#34;) s = max(s, n + 1); scanf(\u0026#34;%d \u0026#34;, \u0026amp;n); } if(n \u0026gt;= s \u0026amp;\u0026amp; n \u0026lt;= e) cout \u0026lt;\u0026lt; \u0026#34;Stan may be honest\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Stan is dishonest\\n\u0026#34;; } return 0; }   E - Ancient Cipher  é¡Œç›®èªªæ˜ï¼š  åˆ¤æ–·ç¬¬ä¸€è¡Œå­—ä¸²èƒ½ä¸èƒ½ä¾ç…§é¡Œç›®çš„è½‰æ›æ–¹å¼è®Šæˆç¬¬äºŒè¡Œå­—ä¸²ã€‚   è§£é¡Œæ€è·¯ï¼š  å…ˆç´€éŒ„å½¼æ­¤å­—æ¯å‡ºç¾çš„æ¬¡æ•¸ä¸¦æ’åºï¼Œå†æ¯”å°æ’åºå¾Œæ•¸å€¼æ˜¯å¦ç›¸åŒå³å¯ã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { string s1, s2; while(cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2) { int a[26] = {0}, b[26] = {0}; for(auto i : s1) ++a[i - \u0026#39;A\u0026#39;]; for(auto i : s2) ++b[i - \u0026#39;A\u0026#39;]; sort(a, a + 26); sort(b, b + 26); bool flag = true; for(int i = 0; i \u0026lt; 26; ++i) { if(a[i] != b[i]) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; flag = false; break; } } if(flag) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; } return 0; }   F - Bridge Hands  é¡Œç›®èªªæ˜ï¼š  ä¾ç…§çµ¦å®šæ–¹ä½çš„ä¸‹ä¸€å€‹äººé–‹å§‹çµ¦ç‰Œï¼Œæœ€å¾Œè¼¸å‡ºè¦ä¾ç…§é †åºæ’åˆ—ã€‚   è§£é¡Œæ€è·¯ï¼š  å°±æ¨¡æ“¬ç™¼ç‰Œä¸¦æ’åºå§ã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using pcc = pair\u0026lt;char, char\u0026gt;; char c; vector\u0026lt;pcc\u0026gt; v[4]; bool cmp(pcc a, pcc b) { int ta[2], tb[2]; char cc[4] = {\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;H\u0026#39;}; char ct[13] = {\u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;A\u0026#39;}; for(int i = 0; i \u0026lt; 4; ++i) { if(a.first == cc[i]) ta[0] = i; if(b.first == cc[i]) tb[0] = i; } for(int i = 0; i \u0026lt; 13; ++i) { if(a.second == ct[i]) ta[1] = i; if(b.second == ct[i]) tb[1] = i; } if(ta[0] \u0026lt; tb[0]) return true; else if(ta[0] \u0026gt; tb[0]) return false; else { if(ta[1] \u0026lt; tb[1]) return true; else return false; } } void sortCard() { for(int i = 0; i \u0026lt; 4; ++i) { sort(v[i].begin(), v[i].end(), cmp); } } void printCard() { char oc[4] = {\u0026#39;S\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;E\u0026#39;}; char cc[4] = {\u0026#39;N\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;W\u0026#39;}; int ic[4][4] = {{1, 2, 3, 0}, {0, 1, 2, 3}, {3, 0, 1, 2}, {2, 3, 0, 1}}; int t; for(int i = 0; i \u0026lt; 4; ++i) { if(cc[i] == c) { t = i; break; } } for(int i = 0; i \u0026lt; 4; ++i) { cout \u0026lt;\u0026lt; oc[i] \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; for(auto it : v[ic[t][i]]) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it.first \u0026lt;\u0026lt; it.second; cout \u0026lt;\u0026lt; endl; } } int main() { while(cin \u0026gt;\u0026gt; c \u0026amp;\u0026amp; c != \u0026#39;#\u0026#39;) { string s; int temp = 0; for(int i = 0; i \u0026lt; 4; ++i) v[i].clear(); for(int i = 0; i \u0026lt; 2; ++i) { cin \u0026gt;\u0026gt; s; int len = s.size(); for(int j = 0; j \u0026lt; len; j += 2) { v[temp % 4].push_back({s[j], s[j + 1]}); ++temp; } } sortCard(); printCard(); } return 0; }   G - Vito\u0026rsquo;s Family  é¡Œç›®èªªæ˜ï¼š  é¸å‡ºä¸€å€‹æ•¸ï¼Œä¸¦è¨ˆç®—å½¼æ­¤è·é›¢å’Œæœ€å°çš„å€¼ã€‚   è§£é¡Œæ€è·¯ï¼š  ä¸­ä½æ•¸ç®—è·é›¢å’Œã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n; cin \u0026gt;\u0026gt; n; int a[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); int mid = a[n / 2], ans = 0; for(int i = 0; i \u0026lt; n; ++i) ans += abs(a[i] - mid); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   H - Shoemaker\u0026rsquo;s Problem  é¡Œç›®èªªæ˜ï¼š  æ‰¾å‡ºèƒ½ä½¿ç½°é‡‘æœ€å°‘çš„å·¥ä½œé †åºã€‚   è§£é¡Œæ€è·¯ï¼š  è²ªå¿ƒæ³• ä¾ç…§ (ç½°é‡‘ / æ™‚é–“) çš„å€¼ï¼Œå¤§åˆ°å°æ’åºã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using pdi = pair\u0026lt;double, int\u0026gt;; bool cmp(pdi a, pdi b) { return a.first \u0026gt; b.first; } int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pdi\u0026gt; v; for(int i = 1; i \u0026lt;= n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; v.push_back({(b * 1.0 / a), i}); } sort(v.begin(), v.end(), cmp); bool flag = false; for(auto it : v) { if(flag) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; it.second; flag = true; } cout \u0026lt;\u0026lt; endl; if(T) cout \u0026lt;\u0026lt; endl; } return 0; }   I - The Bus Driver Problem  é¡Œç›®èªªæ˜ï¼š  å…¬è»Šå·¥ä½œå®‰æ’ï¼Œè¼¸å‡ºé›‡ä¸»æœ€å°‘éœ€è¦æ”¯ä»˜çš„åŠ ç­è²»ã€‚   è§£é¡Œæ€è·¯ï¼š  å…ˆä¾ç…§æ—©æ™šæ’åºï¼Œé ­å°¾é…å°(æœ€å¤§é…æœ€å°)ï¼Œæœ€å¾Œè¨ˆç®—åŠ ç­è²»çš„é‡‘é¡ã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, d, r; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d \u0026gt;\u0026gt; r \u0026amp;\u0026amp; n \u0026amp;\u0026amp; d \u0026amp;\u0026amp; r) { int morning[n], night[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; morning[i]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; night[i]; sort(morning, morning + n); sort(night, night + n); int ans = 0; for(int i = 0; i \u0026lt; n; ++i) { if(morning[i] + night[n - i - 1] \u0026gt; d) ans += ((morning[i] + night[n - i - 1] - d) * r); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   J - Watering Grass  é¡Œç›®èªªæ˜ï¼š  è¨ˆç®—æœ€å°‘éœ€è¦å¤šå°‘å€‹å™´æ°´é ­æ‰èƒ½è¦†è“‹æ•´å€‹å€åŸŸï¼Œè‹¥éƒ½ä¸è¡Œè¼¸å‡º -1ã€‚   è§£é¡Œæ€è·¯ï¼š  å…ˆè½‰æ›æˆä¸€ç¶­ã€‚ è²ªå¿ƒæ³• å€é–“è¦†è“‹   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using pdd = pair\u0026lt;double, double\u0026gt;; bool cmp(pdd a, pdd b) { if(a.first == b.first) return a.second \u0026gt; b.second; else return a.first \u0026lt; b.first; } int main() { int n; double l, w; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l \u0026gt;\u0026gt; w) { w /= 2; double p, r; vector\u0026lt;pdd\u0026gt; v; for(int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; r; if(r \u0026gt; w) { double dd = sqrt(r * r - w * w); v.push_back({p - dd, p + dd}); } } sort(v.begin(), v.end(), cmp); int ans = 0; double right = 0.0; for(int i = 0; i \u0026lt; v.size(); ++i) { if(v[i].first \u0026gt; right) break; for(int j = i + 1; j \u0026lt; v.size() \u0026amp;\u0026amp; v[j].first \u0026lt;= right; ++j) { if(v[j].second \u0026gt; v[i].second) i = j; } ++ans; right = v[i].second; if(right \u0026gt;= l) break; } if(right \u0026gt;= l) cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } return 0; }   K - Ultra-QuickSort  é¡Œç›®èªªæ˜ï¼š  è¼¸å‡ºæœ€å°‘è¦äº¤æ›çš„æ•¸é‡ã€‚   è§£é¡Œæ€è·¯ï¼š  ç”¨ merge sort æ±‚é€†åºæ•¸å°ã€‚ å¤§ä½¬å€‘è¦ç”¨ BIT å»è§£ä¹Ÿè¡Œã€‚   ç¨‹å¼ç¢¼ï¼š #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; long long ans = 0; long long a[500005]; void mergeSort(long long *arr, int len) { if(len \u0026lt;= 1) return; int leftLen = len / 2, rightLen = len - leftLen; long long *leftArr = arr, *rightArr = arr + leftLen; mergeSort(leftArr, leftLen); mergeSort(rightArr, rightLen); static long long tmp[500005]; long long tmpLen = 0, l = 0, r = 0; while(l \u0026lt; leftLen \u0026amp;\u0026amp; r \u0026lt; rightLen) { if(leftArr[l] \u0026lt; rightArr[r]) tmp[tmpLen++] = leftArr[l++]; else { tmp[tmpLen++] = rightArr[r++]; ans += leftLen - l; } } while(l \u0026lt; leftLen) tmp[tmpLen++] = leftArr[l++]; while(r \u0026lt; rightLen) tmp[tmpLen++] = rightArr[r++]; for(int i = 0; i \u0026lt; tmpLen; ++i) arr[i] = tmp[i]; } int main() { int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { ans = 0; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; mergeSort(a, n); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   ","date":"2021-07-15T00:07:54+08:00","permalink":"https://blog.smallten.tk/p/star_coder-02/","title":"StarCoder2021æš‘è¨“ï¼šWeek01"},{"content":"ç°¡ä»‹    é€±æ¬¡ ä¸»é¡Œ é¡Œç›®     ä¸€ æœå°‹ã€æ’åºã€è²ªå¿ƒ Link   äºŒ STLã€ä½µæŸ¥é›† Link   ä¸‰ åœ–ã€ç‹€æ…‹æœå°‹ã€æ‹“æ¨¸æ’åºã€å°¤æ‹‰è·¯ Link   å›› å‹•æ…‹è¦åŠƒ Link   äº” æœ€å°ç”Ÿæˆæ¨¹ Link   å…­ æœ€çŸ­è·¯å¾‘ Link    å­¸ç¿’è³‡æº ç¬¬ä¸€é€± - æœå°‹ã€æ’åºã€è²ªå¿ƒ  ç·šä¸Šæ•™æ    æ•™æ èªªæ˜     å¸«å¤§ç¢¼è³½å®¢ï¼šæ’åº/è²ªå¿ƒ/äºŒåˆ†æœ å­ç·¯å­¸é•·çš„æ•™å­¸è¬›ç¾©ï¼ˆè©³ç›¡çš„æ–°æ‰‹å…¥é–€ï¼‰   åŒ—ä¸€å¥³åŸ¹è¨“ï¼šæ’åº å…­ç¨®æ’åºæ³•çš„ç¨‹å¼èˆ‡ç°¡ä»‹   å»ºä¸­åŸ¹è¨“ (ç¬¬4/6/7ç¯€) 4.æ’åºSTL/6.è²ªå¿ƒ/7.äºŒåˆ†æœ   å°å¤§è³‡è¨Šä¹‹èŠ½ï¼šè²ªå¿ƒ è²ªå¿ƒæ³•èˆ‡ç†è«–/Huffman Tree   æˆå¤§ç«¶ç¨‹åŸ¹è¨“ (å–®å…ƒ5/6) 5.äºŒåˆ†æœ/6.ä¸‰ç¨®æ’åº     ç·šä¸Šå½±ç‰‡    å½±ç‰‡ èªªæ˜     å°å¤§å­”ä»¤å‚‘è€å¸«ï¼šäºŒåˆ†æœå°‹æ³• 7 åˆ†é˜å­¸æœƒäºŒåˆ†æœå°‹æ³•   çœ‹èˆè¹ˆå­¸æ’åºæ³• ä»¥èˆè¹ˆå‘ˆç¾å„ç¨®æ’åºæ³•çš„é‹ä½œéç¨‹   å°å¤§é™³ç¸•å„‚è€å¸«ï¼šè²ªå¿ƒ 50 åˆ†é˜çš„æ­£è¦æ¼”ç®—æ³•èª²ç¨‹ (CLRSèª²æœ¬)     æ¼”ç®—æ³•è¦–è¦ºåŒ–    æ¼”ç®—æ³•      ç·šæ€§æœå°‹èˆ‡äºŒåˆ†æœå°‹ ä»¥å‹•ç•«å‘ˆç¾å…©ç¨®æœå°‹æ³•çš„é‹ä½œéç¨‹   æ’åº ä»¥å‹•ç•«å‘ˆç¾å…­ç¨®æ’åºæ¼”ç®—æ³•çš„é‹ä½œéç¨‹      ç¬¬äºŒé€± - STLã€ä½µæŸ¥é›†  å…§å®¹å¤§ç¶±    è³‡æ–™çµæ§‹ ç°¡è¦èªªæ˜ C++ å…§å»º     é™£åˆ— åœ¨è¨˜æ†¶é«”ä¸­é€£çºŒï¼Œæ”¯æ´éš¨æ©Ÿå­˜å–ä»¥åŠ O(1) æ’å…¥å°¾ç«¯ std::vector   å­—ä¸² ä»¥ â€˜\\0â€™ çµå°¾çš„å­—å…ƒé™£åˆ— std::string   ä¸²åˆ— linked list æ”¯æ´ O(1) çš„æ’å…¥èˆ‡åˆªé™¤ std::list   å †ç–Š stack æ”¯æ´å¾Œé€²å…ˆå‡º (LIFO) çš„å­˜å–æ¨¡å¼ std::stack   ä½‡åˆ— queue æ”¯æ´å…ˆé€²å…ˆå‡º (FIFO) çš„å­˜å–æ¨¡å¼ std::queue   å †ç© heap (å„ªå…ˆéšŠåˆ— priority_queue) æ”¯æ´ O(logN) çš„æ’å…¥å’Œ O(logN) å–å‡ºæœ€å¤§/å°å€¼ std::priority_queue   ä½µæŸ¥é›† disjoint set æœ‰æ•ˆç‡åœ°åˆä½µå…©å€‹é›†åˆã€æœ‰æ•ˆç‡åœ°æŸ¥è©¢å…©å€‹å…ƒç´ æ˜¯å¦å±¬æ–¼åŒä¸€é›†åˆ ç„¡ã€‚æ¨¡æ¿   å¹³è¡¡æœå°‹æ¨¹ è¨˜éŒ„ (éµ, å€¼) å°æ‡‰é—œä¿‚ï¼Œæ”¯æ´ O(logN) çš„æ’å…¥å’ŒæŸ¥è©¢ std::map   å¹³è¡¡æœå°‹æ¨¹ å¯¦ç¾ã€Œé›†åˆã€ï¼Œæ”¯æ´ O(logN) çš„æ’å…¥å’ŒæŸ¥è©¢ std::set     ç·šä¸Šæ•™æ    æ•™æ èªªæ˜     å¸«å¤§ç¢¼è³½å®¢ï¼šåŸºç¤è³‡æ–™çµæ§‹/STL å“æ–°å­¸é•·çš„æ•™å­¸è¬›ç¾©ï¼ˆè©³ç›¡çš„STLèªæ³•ç¤ºç¯„èˆ‡é¡Œç›®è§£èªªï¼‰   æ¿ä¸­åŸ¹è¨“ï¼šSTL STLèªæ³•   å»ºä¸­åŸ¹è¨“ (ç¬¬3ç¯€) STLèªæ³•   åŒ—ä¸€å¥³åŸ¹è¨“ï¼šæ¨¹/äºŒå…ƒæ¨¹/Heap/BST æ¨¹ç‹€çµæ§‹æŠ•å½±ç‰‡   åŒ—ä¸€å¥³åŸ¹è¨“ï¼šä½µæŸ¥é›†(disjoint set) ä½µæŸ¥é›†æŠ•å½±ç‰‡   æˆå¤§ç«¶ç¨‹åŸ¹è¨“ (å–®å…ƒ2/3/4) è³‡çµ/STL/æ¨¹/åœ–     æ¼”ç®—æ³•è¦–è¦ºåŒ–    è³‡æ–™çµæ§‹ èªªæ˜     å †ç© (heap) æœ€å°å †ç©çš„æ’å…¥èˆ‡å–å€¼å‹•ç•«ï¼ˆåœ–å½¢çµæ§‹èˆ‡é™£åˆ—å…§å®¹ï¼‰ï¼šæ¨è–¦ï¼   ä½µæŸ¥é›† ä½µæŸ¥é›†çš„ union/find æ“ä½œå‹•ç•«ï¼ˆåœ–å½¢çµæ§‹èˆ‡é™£åˆ—å…§å®¹ï¼‰ï¼šæ¨è–¦ï¼      ç¬¬ä¸‰é€± - åœ–ã€ç‹€æ…‹æœå°‹ã€æ‹“æ¨¸æ’åºã€å°¤æ‹‰è·¯  ç·šä¸Šæ•™æ    æ•™æ èªªæ˜     å¸«å¤§ç¢¼è³½å®¢ï¼šç‹€æ…‹æœå°‹ ä»²è»’å­¸é•·çš„æ•™å­¸è¬›ç¾©ï¼ˆæ‰‹æŠŠæ‰‹æ•™å­¸èˆ‡é¡Œç›®è§£èªªï¼‰   å¸«å¤§ç¢¼è³½å®¢ï¼šåŸºç¤åœ–è«– å¥æ„·å­¸é•·çš„æ•™å­¸è¬›ç¾©ï¼ˆæœ‰æ‹“æ¨¸åºå’Œå°¤æ‹‰è·¯ï¼‰   å°å¤§è³‡è¨Šä¹‹èŠ½ï¼šåœ– åœ–çš„å¯¦ä½œ/æœå°‹/äºŒåˆ†åœ–åˆ¤å®š   å»ºä¸­åŸ¹è¨“ (ç¬¬ 1/2/5 ç¯€) ç¬¬5ç¯€æœ‰æ‹“æ¨¸æ’åº   æˆå¤§åŸ¹è¨“ (å–®å…ƒ 4)ï¼šåœ–/DFS/BFS æœ‰ä¸€äº›ç·´ç¿’é¡Œ     ç·šä¸Šå½±ç‰‡    å½±ç‰‡ èªªæ˜     å°å¤§é™³ç¸•å„‚è€å¸«ï¼šåœ– 40 åˆ†é˜å­¸åœ–çš„æ¦‚å¿µã€å¯¦ä½œèˆ‡ä¸€ç­†ç•«å•é¡Œ   å°å¤§é™³ç¸•å„‚è€å¸«ï¼šBFS 60 åˆ†é˜ï¼ˆä¸»è¦è¬›è­‰æ˜ï¼‰   å°å¤§é™³ç¸•å„‚è€å¸«ï¼šDFS/é€£é€š/æ‹“æ¨¸æ’åº 60 åˆ†é˜     æ¼”ç®—æ³•è¦–è¦ºåŒ–    æ¼”ç®—æ³• èªªæ˜     BFS æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œï¼šæ¨è–¦ï¼   DFS æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œï¼šæ¨è–¦ï¼   é€£é€š (connected component) æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œ   æ‹“æ¨¸æ’åº æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œ      ç¬¬å››é€± - å‹•æ…‹è¦åŠƒ  ç·šä¸Šæ•™æ    æ•™æ èªªæ˜     å¸«å¤§ç¢¼è³½å®¢ï¼šåŸºç¤ DP å“æ–°å­¸é•·çš„æ•™å­¸è¬›ç¾©ï¼ˆæ¶µè“‹é‡è¦ç¶“å…¸é¡Œå‹èˆ‡é¡Œè§£ï¼‰   å°å¤§è³‡è¨Šä¹‹èŠ½ï¼šDP æ¦‚å¿µã€LIS/LCSã€é›¶éŒ¢/èƒŒåŒ… ä¸‰æ®µè¬›ç¾©   æˆå¤§åŸ¹è¨“ (å–®å…ƒ 9)ï¼šDP (èƒŒåŒ…/LIS/LCS) æœ‰ä¸€äº›ç·´ç¿’é¡Œ   sa072686 çš„ç­†è¨˜ æœ‰å¾ˆå¤šç¿’é¡Œèˆ‡è§£ç­”ã€‚     ç·šä¸Šå½±ç‰‡    å½±ç‰‡ èªªæ˜     å°å¤§é™³ç¸•å„‚è€å¸«ï¼šDP æ¦‚å¿µ 20 åˆ†é˜å½±ç‰‡ï¼šä»¥è²»æ°æ•¸åˆ—è§£é‡‹ DP æ¦‚å¿µ   å°å¤§é™³ç¸•å„‚è€å¸«ï¼šçŸ©é™£é€£ä¹˜ (å€é–“ DP) 30 åˆ†é˜     æ¼”ç®—æ³•è¦–è¦ºåŒ–    æ¼”ç®—æ³• èªªæ˜     LIS O(n2) ç¨‹å¼æ­¥é€²å‹•ç•«   LCS O(n2) ç¨‹å¼æ­¥é€²å‹•ç•«   èƒŒåŒ… O(NW) ç¨‹å¼æ­¥é€²å‹•ç•«      ç¬¬äº”é€± - æœ€å°ç”Ÿæˆæ¨¹  ç·šä¸Šæ•™æ    æ•™æ èªªæ˜     å¸«å¤§ç¢¼è³½å®¢ï¼šMST æ™ºéˆå­¸é•·çš„æ•™å­¸è¬›ç¾©èˆ‡é¡Œè§£ï¼ˆæœ¬é›†ä¹ŸåŒ…å«æ‹“æ’²æ’åºå’Œå°¤æ‹‰è·¯ï¼‰   æˆå¤§åŸ¹è¨“ (å–®å…ƒ 11)ï¼šGraph é€Ÿæˆã€æœ‰ä¸€äº›ç·´ç¿’é¡Œ   æ¼”ç®—æ³•ç­†è¨˜ï¼šç”Ÿæˆæ¨¹ å¸«å¤§è³‡å·¥æœ€æœ‰åçš„å€‹äººç¶²ç«™XD     ç·šä¸Šå½±ç‰‡    å½±ç‰‡ èªªæ˜     è³‡è¨Šä¹‹èŠ½ï¼šæœ€å°ç”Ÿæˆæ¨¹ 30åˆ†é˜     æ¼”ç®—æ³•è¦–è¦ºåŒ–    æ¼”ç®—æ³• èªªæ˜     Kruskalâ€™s æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œï¼šæ¨è–¦ï¼   Kruskalâ€™s æ­é…ç¨‹å¼ç¢¼   Primâ€™s æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œï¼šæ¨è–¦ï¼   Primâ€™s æ­é…ç¨‹å¼ç¢¼      ç¬¬å…­é€± - æœ€çŸ­è·¯å¾‘  ç·šä¸Šæ•™æ    æ•™æ èªªæ˜     å¸«å¤§ç¢¼è³½å®¢ï¼šæœ€çŸ­è·¯ å“æ–°å­¸é•·çš„æ•™å­¸è¬›ç¾©èˆ‡é¡Œè§£   æ¼”ç®—æ³•ç­†è¨˜:è·¯å¾‘ Dijkstraâ€™sã€BellmanFordã€Floyd-Warshall   æˆå¤§åŸ¹è¨“ (å–®å…ƒ 11)ï¼šGraph é€Ÿæˆã€æœ‰ä¸€äº›ç·´ç¿’é¡Œ     ç·šä¸Šå½±ç‰‡    å½±ç‰‡ èªªæ˜     å°å¤§é™³ç¸•å„‚è€å¸«ï¼šæœ€çŸ­è·¯ 15åˆ†é˜ç°¡ä»‹   å°å¤§é™³ç¸•å„‚è€å¸«ï¼šBellman-Ford 30 åˆ†é˜ä»‹ç´¹   å°å¤§é™³ç¸•å„‚è€å¸«ï¼šDijkstraâ€™s 20 åˆ†é˜ä»‹ç´¹     æ¼”ç®—æ³•è¦–è¦ºåŒ–    æ¼”ç®—æ³• èªªæ˜     Dijkstraâ€™s æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œï¼šæ¨è–¦ï¼   Dijkstraâ€™s æ­é…ç¨‹å¼ç¢¼   Bellman-Ford æ­é…ç¨‹å¼ç¢¼   Floyd-Warshall æ­é…æ¨¹ç‹€åœ–/é™£åˆ—å¯¦ä½œ/ä¸²åˆ—å¯¦ä½œï¼šæ¨è–¦ï¼   Floyd-Warshall æ­é…ç¨‹å¼å—      ","date":"2021-07-14T22:52:11+08:00","permalink":"https://blog.smallten.tk/p/star_coder-01/","title":"StarCoder2021æš‘è¨“"},{"content":" linuxlist.h  #pragma once  struct list_head { struct list_head *next, *prev; }; #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) }  #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)  /* * Insert a new entry between two known consecutive entries. * * This is only for internal list manipulation where we know * the prev/next entries already! */ static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-\u0026gt;prev = new; new-\u0026gt;next = next; new-\u0026gt;prev = prev; prev-\u0026gt;next = new; } /** * list_add - add a new entry * @new: new entry to be added * @head: list head to add it after * * Insert a new entry after the specified head. * This is good for implementing stacks. */ static inline void list_add(struct list_head *new, struct list_head *head) { __list_add(new, head, head-\u0026gt;next); } /** * list_add_tail - add a new entry * @new: new entry to be added * @head: list head to add it before * * Insert a new entry before the specified head. * This is useful for implementing queues. */ static inline void list_add_tail(struct list_head *new, struct list_head *head) { __list_add(new, head-\u0026gt;prev, head); } /* * Delete a list entry by making the prev/next entries * point to each other. * * This is only for internal list manipulation where we know * the prev/next entries already! */ static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; prev-\u0026gt;next = next; } /** * list_del - deletes entry from list. * @entry: the element to delete from the list. * Note: list_empty() on entry does not return true after this, the entry is * in an undefined state. */ static inline void __list_del_entry(struct list_head *entry) { if (entry == NULL) return; __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } static inline void list_del(struct list_head *entry) { __list_del_entry(entry); entry-\u0026gt;next = NULL; entry-\u0026gt;prev = NULL; } /** * list_empty - tests whether a list is empty * @head: the list to test. */ static inline int list_empty(const struct list_head *head) { return head -\u0026gt; next == head; } #define offsetof(TYPE, MEMBER) ((size_t)\u0026amp;((TYPE *)0)-\u0026gt;MEMBER)  #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ ((type *)(__mptr - offsetof(type, member))); })  /** * list_entry - get the struct for this entry * @ptr:\tthe \u0026amp;struct list_head pointer. * @type:\tthe type of the struct this is embedded in. * @member:\tthe name of the list_head within the struct. */ #define list_entry(ptr, type, member) \\ container_of(ptr, type, member)  /** * list_first_entry - get the first element from a list * @ptr:\tthe list head to take the element from. * @type:\tthe type of the struct this is embedded in. * @member:\tthe name of the list_head within the struct. * * Note, that list is expected to be not empty. */ #define list_first_entry(ptr, type, member) \\ list_entry((ptr)-\u0026gt;next, type, member)  /** * list_last_entry - get the last element from a list * @ptr:\tthe list head to take the element from. * @type:\tthe type of the struct this is embedded in. * @member:\tthe name of the list_head within the struct. * * Note, that list is expected to be not empty. */ #define list_last_entry(ptr, type, member) \\ list_entry((ptr)-\u0026gt;prev, type, member)  /** * list_for_each\t-\titerate over a list * @pos:\tthe \u0026amp;struct list_head to use as a loop cursor. * @head:\tthe head for your list. */ #define list_for_each(pos, head) \\ for (pos = (head)-\u0026gt;next; pos != (head); pos = pos-\u0026gt;next)  /** * list_for_each_prev\t-\titerate over a list backwards * @pos:\tthe \u0026amp;struct list_head to use as a loop cursor. * @head:\tthe head for your list. */ #define list_for_each_prev(pos, head) \\ for (pos = (head)-\u0026gt;prev; pos != (head); pos = pos-\u0026gt;prev)  main.c  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;time.h\u0026gt;#include \u0026#34;linuxlist.h\u0026#34;typedef struct _sCharacter { int32_t id; char name[32]; int32_t hp; int32_t mp; int32_t exp; int32_t atk; int32_t def; int32_t ats; int32_t adf; int32_t spd; struct list_head list; } sCharacter; sCharacter *allocCharacter(int32_t id) { sCharacter *newComer = calloc(1, sizeof(sCharacter)); newComer-\u0026gt;id = id; newComer-\u0026gt;name[0] = rand() % 26 + \u0026#39;A\u0026#39;; for(int32_t j = 1 ; j \u0026lt; 6 ; j++) newComer-\u0026gt;name[j] = rand() % 26 + \u0026#39;a\u0026#39;; newComer-\u0026gt;hp = rand() % 100 + 1; newComer-\u0026gt;mp = rand() % 100 + 1; newComer-\u0026gt;exp = rand() % 100 + 1; newComer-\u0026gt;atk = rand() % 100 + 1; newComer-\u0026gt;def = rand() % 100 + 1; newComer-\u0026gt;ats = rand() % 100 + 1; newComer-\u0026gt;adf = rand() % 100 + 1; newComer-\u0026gt;spd = rand() % 100 + 1; return newComer; } void printCharacter(sCharacter *one) { printf(\u0026#34;%04d) \u0026#34;, one-\u0026gt;id); printf(\u0026#34;%8s \u0026#34;, one-\u0026gt;name); for(int32_t *ptr = \u0026amp;(one-\u0026gt;hp); ptr \u0026lt;= \u0026amp;(one-\u0026gt;spd); ptr++) printf(\u0026#34;%3d \u0026#34;, *ptr); printf(\u0026#34;\\n\u0026#34;); return; } int main() { LIST_HEAD(char_list_head); srand(time(0)); for(int32_t i = 0 ; i \u0026lt; 1000 ; i++) { sCharacter *newComer = allocCharacter(i + 1); list_add(\u0026amp;(newComer-\u0026gt;list), \u0026amp;char_list_head); } struct list_head *listptr = NULL; list_for_each(listptr, \u0026amp;char_list_head) { sCharacter *cptr = list_entry(listptr, sCharacter, list); printCharacter(cptr); } /* list_for_each_prev(listptr, \u0026amp;char_list_head) { sCharacter *cptr = list_entry(listptr, sCharacter, list); printCharacter(cptr); } */ return 0; } ","date":"2021-07-13T22:25:50+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-08/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-08ï¼šLinux List"},{"content":"Predefined Macros Standard Predefined Macros #include \u0026lt;stdio.h\u0026gt;int main() { printf(\u0026#34;line: %d \\n\u0026#34;, __LINE__); printf(\u0026#34;file: %s \\n\u0026#34;, __FILE__); printf(\u0026#34;function: %s \\n\u0026#34;, __FUNCTION__); // gcc  printf(\u0026#34;function: %s \\n\u0026#34;, __func__); // C99  printf(\u0026#34;time: %s \\n\u0026#34;, __TIME__); printf(\u0026#34;date: %s \\n\u0026#34;, __DATE__); printf(\u0026#34;STDC: %d \\n\u0026#34;, __STDC__); printf(\u0026#34;STDC_VERSION: %ld \\n\u0026#34;, __STDC_VERSION__); printf(\u0026#34;TIMESTAMP: %s \\n\u0026#34;, __TIMESTAMP__); return 0; }  æˆ‘å€‘å¯ä»¥æ€éº¼ä½¿ç”¨é€™äº› Macros ?  fprintf(stderr, \u0026quot;Internalâ£error: at %s, line %d. ver %s %s\u0026quot;, __FILE__, __LINE__, __DATE__, __TIME__); Define when Compiling  gcc -D__DEBUG__ debug.c  #include \u0026lt;stdio.h\u0026gt;int main() { printf(\u0026#34;Hello World!!\\n\u0026#34;); #ifdef __DEBUG__  printf(\u0026#34;debug!!\\n\u0026#34;); #endif  return 0; }    Other GCC Predefined MACROs  Common Predefined Macros    Comparing Unsigned Integers  When comparisons between signed and unsigned integers, C will force the signed type to unsigned. C99 and C11 section 6.3.1.8. It is hard to debug since it looks so nature.  Call Functions at Program Termination atexit int atexit(void (*function)(void));\n Register a Function to be Called at Normal Process Termination The atexit() function registers the given function to be called at normal process termination, either via exit(3) or via return from the programâ€™s main(). Functions so registered are called in the reverse order of their registration; no arguments are passed. The atexit() function returns the value 0 if successful; otherwise it returns a nonzero value.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void foo(void) { printf(\u0026#34;Goodbye Foo!\\n\u0026#34;); } void bar(void) { printf(\u0026#34;Goodbye Bar!\\n\u0026#34;); } int main(int argc, wchar_t* argv[]) { atexit(bar); atexit(foo); return 0; } system and more System: Execute a Shell Command int system(const char *command);\n The system() library function uses fork(2) to create a child process that executes the shell command specified in command. system() returns after the command has been completed.  fork  fork() creates a new process by duplicating the calling process. This is an important function. However, I will not talk too much about this function but you will learn more in System Programming.      system() is a blockingfunction. #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main() { system(\u0026#34;while true; do echo \u0026#39;Hit CTRL+C\u0026#39;; sleep 1; done\u0026#34;); return 0; }  The system() returns -1 means your system cannot fork another process instead of your command fails. You can try a command to delete a non-existing file.   Every system call is independent.  So you cannot setup an environment variable and hope other other system calls use this variable.    popen FILE *popen(const char *command, const char *type);\n The popen() function opens a process by creating a pipe, forking, and invoking the shell. The popen() function returns NULL if the fork(2) or pipe(2) calls fail, or if it cannot allocate memory. åˆ¥å¿˜äº†ä½¿ç”¨ pclose.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;int main() { char buffer[512]; FILE *pPing = NULL; uint32_t counter = 0; pPing = popen(\u0026#34;ping -c 4 www.google.com\u0026#34;, \u0026#34;r\u0026#34;); if(pPing == NULL) { printf(\u0026#34;error end\\n\u0026#34;); exit(1); } while(fgets(buffer, 512, pPing)) { counter++; printf(\u0026#34;--- %d ---\\n\u0026#34;, counter); printf(\u0026#34;%s\u0026#34;, buffer); } pclose(pPing); return 0; } assert  In computer programming, an assertion is a statement that a predicate(Boolean-valued function, i.e. a true-false expression) is always true at that point in code execution. It can help a programmer read the code, help a compiler compile it, or help the program detect its own defects. If the assertion check is not in fact true, an assertion failure, the program considers itself to be brokenand typically deliberately crashes or throws an assertion failure exception.   void assert(scalar expression);\n The macro assert() prints an error message to standard error and terminates the program by calling abort(3) if expression is false. The purpose of this macro is to help programmers find bugs in their programs.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;int main() { FILE *fd; fd = fopen (\u0026#34;file.txt\u0026#34;, \u0026#34;r\u0026#34;); assert (fd); fclose (fd); return 0; }  æˆ‘å¯ä»¥ç°¡å–®çš„ä½¿ç”¨ if-else å»ç¢ºèªä¸¦å›å‚³å€¼ã€‚é‚£ç‚ºä»€éº¼é‚„è¦ä½¿ç”¨ assert?  é€™å–æ±ºæ–¼æ‚¨æ˜¯å¦å¯ä»¥å„ªé›…åœ°è™•ç†éŒ¯èª¤ã€‚   Note:  ä¸€èˆ¬ä¾†èªªï¼Œassert è¢«ç”¨åœ¨é–‹ç™¼éšæ®µã€‚ ç•¶ç™¼ä½ˆæ™‚ï¼Œè«‹ç§»é™¤æ‰€æœ‰ assertã€‚    qsort void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));\n The qsort() function sorts an array with nmemb elements of size size. The base argument points to the start of the array. The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second. If two members compare as equal, their order in the sorted array is undefined.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int values[] = {88, 56, 100, 2, 25}; int cmpfunc (const void * a, const void * b) { return (*(int*)a - *(int*)b); } int main() { int n; printf(\u0026#34;Before sorting the list is:\u0026#34;); for(n = 0 ; n \u0026lt; 5; n++) printf(\u0026#34;%d \u0026#34;, values[n]); qsort(values, 5, sizeof(int), cmpfunc); printf(\u0026#34;After sorting the list is:\u0026#34;); for( n = 0 ; n \u0026lt; 5; n++ ) printf(\u0026#34;%d \u0026#34;, values[n]); return 0; } libcurl  å®‰è£: sudo apt-get install libcurl4 libcurl4-openssl-dev ä½¿ç”¨: Example codes ç·¨è­¯: gcc -I curl-7.63.0/include -L curl-7.63.0/lib/.libs/ opendata.c -lcurl (éœ€ä¾ç…§æƒ…æ³è‡ªè¡Œä¿®æ”¹)  Makefile: CFLAGS = -O3 -Wall INCLUDE = -I curl-7.63.0/include LIB = -L curl-7.63.0/lib/.libs/ all: opendata.c gcc ${CFLAGS} ${INCLUDE} ${LIB} opendata.c -o opendata -lcurl clean: rm -f opendata     ","date":"2021-07-13T21:39:10+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-07/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-07ï¼šSome Tricks"},{"content":"Preprocessor é è™•ç†å™¨  åœ¨ç·¨è­¯å™¨å°‡æ‚¨çš„æºä»£ç¢¼ç·¨è­¯ç‚ºçµ„èªå‰ï¼Œé‚„æœ‰ä¸€å€‹ç¨±ç‚ºé è™•ç†çš„é™„åŠ éšæ®µã€‚ Objective: Produce a source code file with preprocessing commands properly sorted out.   Preprocessor commands are known as Directives. Preprocessor provides certain features, which are called preprocessor directives. Preprocessor directive ä»¥ # ç‚ºé–‹é ­ã€‚(ä¾‹å¦‚ï¼š#include \u0026lt;stdio.h\u0026gt;) Preprocessor directives å¯ä»¥è¢«æ”¾åœ¨ç¨‹å¼ä¸­çš„ä»»ä½•åœ°æ–¹ã€‚ä½†å»ºè­°æ”¾åœ¨é–‹é ­ï¼Œä¸¦ä¸”æ¯å€‹å¿…é ˆç¨ç«‹ä¸€è¡Œã€‚   #include \u0026lt;stdio.h\u0026gt;#define MACRO_DEMO 123 int main() { printf(\u0026#34;demo:â£%d\\n\u0026#34;, MACRO_DEMO); return 0; }  ä»¥ gcc -E main.c æŸ¥çœ‹é è™•ç†å¾Œçš„ç‹€æ…‹ã€‚  Macro å·¨é›†  #define is known as macro expansion. General Form: #define macro_template macro_expansion  Macro Expansion  Preprocessor searches for macro definition. After finding macro definition, it searches the whole program for macro_template. Replaceevery macro_template with macro_expansion.  Replacement will not occur if the template is in a quoted string.   Notes:  é€šå¸¸ macro_template æœƒä½¿ç”¨å¤§å¯«å­—æ¯ ä¸è¦ä½¿ç”¨åˆ†è™Ÿ ;      ç‚ºä»€éº¼è¦ç”¨å·¨é›†?  ç‚ºäº†å¯«å‡ºæ›´é«˜æ•ˆç‡çš„ç¨‹å¼ã€‚ æé«˜ç¨‹å¼çš„å¯è®€æ€§ã€‚ å®šç¾©çš„å·¨é›†åç¨±å¯ä½œç‚ºå…¶ä»–å®šç¾©çš„ä¸€éƒ¨åˆ†ã€‚   å·¨é›†å¯ä»¥åƒå‡½å¼ä¸€æ¨£æ“æœ‰ argumentsã€‚ Notesï¼š  åœ¨å®šç¾©å·¨é›†æ™‚ï¼Œåƒæ•¸å’Œåç¨±ä¹‹é–“ä¸å…è¨±æœ‰ç©ºæ ¼ã€‚ Macro expansions æ‡‰è©²ç”¨æ‹¬è™Ÿæ‹¬èµ·ä¾†ã€‚ ä½¿ç”¨ \\ å°‡å·¨é›†æ‹†åˆ†ç‚ºå¤šè¡Œã€‚    Macro vs. Function Macro  å–®ç´”æ›¿æ› é›–ç„¶ä½ å¯èƒ½æ²’æ„Ÿè¦ºï¼Œä½†æ¯”å‡½å¼æ›´å¿«ã€‚  Function  å‚³éåƒæ•¸ -\u0026gt; åŸ·è¡Œ -\u0026gt; å›å‚³çµæœ æ”¯æ´éè¿´  inline Functions  inline is a CPP keyword. C includes this keyword from C99. Though GNU C (and some other compilers) had inline functions long before standard C. Comparison:  inline is just a suggestion. inline will check types.   I will not talk too much about this keyword since it is different from CPP. I do not want to mislead you. If you are interested in this topic, please read here.  File Inclusion  Why File Inclusion?  Divide a program in multiple files.  Each file contains related functions. How to classify functions. Up to you.   Some functions or macros are required in lot of programs.  Put them in a file. Make them a library. Include them when you need them.     What does Inclusion Mean?  Nothing but simply copy and paste. Nested Inclusionis supported.    Conditional Compilation  Write one code to run on different environments.  #if: if. #else: else. #elif: else if. #endif: end if. #ifdef: if defined. #ifndef: if not defined.    ifdef and endif #ifdef macroname  statement sequence. #endif  å¦‚æœ macroname è¢«å®šç¾©äº†ï¼Œé‚£éº¼ #ifdef å’Œ #endif ä¹‹é–“çš„ç¨‹å¼å°‡è¢«åŸ·è¡Œã€‚ ç¯„ä¾‹ï¼š #ifndef TEST_H #define TEST_H ... #endif  ä½†ä¹Ÿå¯ç”¨ #pragma once      gcc -D OS_LINUX os_dependent.c -D: Predefine name as a macro, with definition 1. So one code can be executed on different OSs. What you need to do is to build your code with different definitions. This is a very useful technique. Letâ€™s see a real case (cJSON).    è«‹è‡ªè¡Œå»äº†è§£ # åŠ ## åœ¨å·¨é›†ä¸­çš„ä½œç”¨ã€‚  ","date":"2021-07-13T20:47:06+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-06/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-06ï¼šMacro"},{"content":"Program Argument argc, argv #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;int main(int argc, char *argv[]) { printf(\u0026#34;argc: %d\\n\u0026#34;, argc); for(int32_t i = 0 ; i \u0026lt; argc ; i++) printf(\u0026#34;argv[%d]: %s\\n\u0026#34;, i, argv[i]); return 0; }  èª°å‘¼å«äº† main å‡½å¼? èª°æä¾›äº† argc å’Œ argv åˆ° main å‡½å¼? Is main() the actual starting entry point?  No! Actually, the process start from _start which is defined in crt1.o. ç­‰ç­‰\u0026hellip; æˆ‘ä¸¦æ²’æœ‰ä½¿ç”¨ crt1.o å‘€! å¯¦éš›ä¸Šæ˜¯æœ‰çš„ã€‚è«‹æŸ¥çœ‹ gcc -v $ nm /usr/lib/x86_64-linux-gnu/crt1.o   Simplified C Linking Process   main() æ˜¯å¦‚ä½•å–å¾— argc, argv çš„?  Actually, _start will prepare argc and argv first. Then _start will register main function to __libc_start_main. _start will call __libc_start_main and __libc_start_main will call main. More details will be described in Assembly.    getopt int getopt(int argc, char * const argv[], const char *optstring);\n The getopt() function parses the command-line arguments. Its arguments argc and argv are the argument count and array as passed to the main() function on program invocation. An element of argv that starts with â€™-â€™ (and is not exactly â€-â€ or â€â€“â€) is an option element. The characters of this element (aside from the initial â€™-â€™) are option characters. If getopt() is called repeatedly, it returns successively each of the option characters from each of the option elements. æé†’ï¼šé€™æ˜¯ä¸€å€‹ POSIX æ¨™æº–è€Œä¸æ˜¯ C æ¨™æº–ã€‚ extern è®Šæ•¸ extern char *optarg; extern int optind, opterr, optopt;  é€™æ„å‘³è‘—æˆ‘å€‘å¯ä»¥åœ¨ç¨‹å¼ä¸­ä½¿ç”¨é€™äº›è®Šæ•¸ã€‚    #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main(int argc, char *argv[]) { int32_t c = 0; while((c = getopt(argc, argv, \u0026#34;ab:\u0026#34;)) != -1) { switch(c) { case \u0026#39;a\u0026#39;: printf( \u0026#34;option: -a\\n\u0026#34; ); break; case \u0026#39;b\u0026#39;: printf( \u0026#34;option: -b, %s\\n\u0026#34;, optarg ); case \u0026#39;?\u0026#39;: printf( \u0026#34;option: ?\\n\u0026#34; ); break; default: printf( \u0026#34;option: unknown\\n\u0026#34; ); break; } } return 0; }  optstring  optstring æ˜¯ä¸€å€‹åŒ…å«åˆæ³•é¸é …å­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚ Example: \u0026quot;abc\u0026quot; implies supporting -a, -b, -c. -ab, -bc, -ac, -abc are also supported. å¦‚æœé€™æ¨£çš„å­—ç¬¦å¾Œè·Ÿä¸€å€‹å†’è™Ÿï¼Œå‰‡æ„å‘³è‘—è©²é¸é …éœ€è¦ä¸€å€‹åƒæ•¸ã€‚ optarg ç‚ºåƒæ•¸å€¼ã€‚   å›å‚³å€¼  å¦‚æœæˆåŠŸæ‰¾åˆ°é¸é …ï¼Œå‰‡ getopt() å›å‚³é¸é …å­—ç¬¦ã€‚ å¦‚æœæ‰€æœ‰å‘½ä»¤è¡Œé¸é …éƒ½å·²è§£æï¼Œå‰‡ getopt() å›å‚³ -1ã€‚ å¦‚æœ getopt() é‡åˆ°ä¸åœ¨ optstring ä¸­çš„é¸é …å­—ç¬¦ï¼Œå‰‡è¿”å› '?'ã€‚ å¦‚æœ getopt() é‡åˆ°ç¼ºå°‘åƒæ•¸çš„é¸é …ï¼Œå‰‡è¿”å›å€¼å–æ±ºæ–¼ optstring ä¸­çš„ç¬¬ä¸€å€‹å­—ç¬¦ï¼š  å¦‚æœæ˜¯':'ï¼Œå‰‡è¿”å›':'ï¼› å¦å‰‡è¿”å›'?'ã€‚      getopt_long int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);\n The getopt_long() function works like getopt() except that it also accepts long options, started with two dashes. If the program accepts only long options, then optstring should be specified as an empty string (â€â€), not NULL. Long option names may be abbreviated if the abbreviation is unique or is an exact match for some defined option. A long option may take a parameter, of the form â€“arg=param or â€“arg param. If longindex is not NULL, it points to a variable which is set to the index of the long option relative to longopts. struct option struct option { const char *name; int has_arg; int *flag; int val; };  name: the name of the long option. has_arg:  0: no arguments. 1: required arguments. 2: optional arguments.   flag: specifies how results are returned for a long option. val: the value to return, or to load into the variable pointed to by flag.    #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;getopt.h\u0026gt; struct option long_options[] = { {\u0026#34;all\u0026#34;, 0, NULL, \u0026#39;a\u0026#39;}, {\u0026#34;break\u0026#34;, 0, NULL, \u0026#39;b\u0026#39;}, {\u0026#34;cancel\u0026#34;, 1, NULL, \u0026#39;c\u0026#39;}, {0, 0, 0, 0}, }; int main(int argc, char *argv[]) { int32_t c = 0, index = 0; while((c = getopt_long(argc, argv, \u0026#34;abc:\u0026#34;, long_options, \u0026amp;index)) != -1) { printf(\u0026#34;index: %d\\n\u0026#34;, index); switch(c) { case \u0026#39;a\u0026#39;: printf( \u0026#34;option: -a\\n\u0026#34; ); break; case \u0026#39;b\u0026#39;: printf( \u0026#34;option: -b\\n\u0026#34; ); break; case \u0026#39;c\u0026#39;: printf( \u0026#34;option: -c, %s\\n\u0026#34;, optarg ); break; case \u0026#39;?\u0026#39;: printf( \u0026#34;option: ?\\n\u0026#34; ); break; default: printf( \u0026#34;option: unknown\\n\u0026#34; ); break; } } return 0; } Variable Length Arguments  å¯è®Šé•·åº¦åƒæ•¸æ˜¯ä¸€é …åŠŸèƒ½ï¼Œå…è¨±å‡½æ•¸æ¥æ”¶ä»»æ„æ•¸é‡çš„åƒæ•¸ã€‚ å¯è®Šæ•¸é‡çš„åƒæ•¸ç”±ä¸‰å€‹é»è¡¨ç¤º ...ã€‚  #include \u0026lt;stdarg.h\u0026gt;void va_start(va_list ap, last); type va_arg(va_list ap, type); void va_end(va_list ap); void va_copy(va_list dest, va_list src);  Actually, they are macros instead of functions. ç¯„ä¾‹ä¸€ï¼š printargs.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdarg.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;/* print all args one at a time until a negative argument is seen; all args are assumed to be of int type */ void printargs(int32_t arg1, ...) { va_list ap; int32_t i; va_start( ap, arg1 ); for(int32_t i = arg1; i \u0026gt;= 0; i = va_arg(ap, int32_t)) printf( \u0026#34;%d \u0026#34;, i); va_end( ap ); putchar(\u0026#39;\\n\u0026#39;); return; } int main() { printargs(5, 2, 14, 84, 97, 15, -1, 48, -1); printargs(84, 51, -1); printargs(-1); printargs(1, -1); return 0; }  ç¯„ä¾‹äºŒï¼š avg.c #include \u0026lt;stdarg.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;double average(int32_t num, ...) { va_list valist; int32_t sum = 0; va_start(valist, num); for (int32_t i = 0; i \u0026lt; num; i++) sum += va_arg(valist, int32_t); va_end(valist); return sum / (double)num; } int main() { printf(\u0026#34;Average of { 3, 4 } = %lf\\n\u0026#34;, average(2, 3, 4)); printf(\u0026#34;Average of { 5, 10, 15 } = %lf\\n\u0026#34;, average(3, 5, 10, 15)); return 0; }   ","date":"2021-07-12T21:57:26+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-05/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-05ï¼šVariable Length Arguments List"},{"content":" å¦‚ä½•é¡¯ç¤º BMP æª” ?  æœ‰å¾ˆå¤š libraries å¯ä»¥å¹«åŠ©æ‚¨åšåˆ°é€™ä¸€é»ã€‚å¯¦éš›ä¸Šï¼Œæ‚¨æ‡‰è©²ä½¿ç”¨å®ƒå€‘è€Œä¸æ˜¯å¾é ­é–‹å§‹é–‹ç™¼ã€‚ å¦‚ä½•åœ¨è¢å¹•ä¸Šé¡¯ç¤ºåœ–åƒï¼Ÿ  æ‚¨å¿…é ˆè‡³å°‘å­¸ç¿’ä¸€å€‹ GUI åº«ï¼Œä¾‹å¦‚ Gtkã€Qt ç­‰ã€‚ æˆ‘çš„å»ºè­°ï¼šQtã€‚ä½†æ˜¯ï¼Œé€™æ˜¯ä¸€å€‹ C++ æ¡†æ¶ã€‚ äº†è§£å¦‚ä½•ä½¿ç”¨ GUI å¹³å°æä¾›çš„åŠŸèƒ½é¡¯ç¤ºåœ–åƒã€‚       GTK  GTKï¼ˆä»¥å‰ç¨±ç‚º GTK+ã€GIMP ToolKitï¼‰æ˜¯ä¸€å€‹å…è²»çš„é–‹æºè·¨å¹³å°çš„éƒ¨ä»¶å·¥å…·ç®± (widget toolkit)ï¼Œç”¨æ–¼å‰µå»ºåœ–å½¢ç”¨æˆ¶ç•Œé¢ï¼ˆGUIsï¼‰ã€‚ GTK æ˜¯ç”¨ C èªè¨€æ‰€ç·¨å¯«çš„ç‰©ä»¶å°å‘çš„éƒ¨ä»¶å·¥å…·ç®±ã€‚å®ƒä½¿ç”¨ GObjectï¼ˆå³ GLib ç‰©ä»¶ç³»çµ±ï¼‰é€²è¡Œç‰©ä»¶å°å‘ã€‚  å› æ­¤ï¼Œä¸è¦å‘Šè¨´æˆ‘ C ä¸èƒ½ç‰©ä»¶å°å‘ã€‚   å®‰è£ï¼šsudo apt install libgtk-3-dev   SDL  Simple DirectMedia Layer SDLæ˜¯è·¨å¹³å°çš„è»Ÿä»¶é–‹ç™¼åº«ï¼Œç‚ºè¨ˆç®—æ©Ÿå¤šåª’é«”ç¡¬ä»¶çµ„ä»¶æä¾›ç¡¬ä»¶æŠ½è±¡å±¤ã€‚  è¦–é » è²éŸ³çš„ è¼¸å…¥è¨­å‚™ å…‰ç›¤ èºç´‹ å…±äº«å°è±¡åŠ è¼‰ è¯ç¶² è¨ˆæ™‚å™¨ 3Dåœ–å½¢   è»Ÿé«”é–‹ç™¼è€…å¯ä»¥ä½¿ç”¨å®ƒä¾†ç·¨å¯«é«˜æ€§èƒ½çš„é›»è…¦éŠæˆ²å’Œå…¶ä»–å¤šåª’é«”æ‡‰ç”¨ç¨‹å¼ã€‚ SDL æ¶æ§‹ / ç¯„ä¾‹     SDL Object  SDL_Windowï¼šåŒ…å«æœ‰é—œ Window æœ¬èº«çš„æ‰€æœ‰ä¿¡æ¯çš„çµæ§‹ï¼šå¤§å°ã€ä½ç½®ã€å…¨è¢å¹•ã€é‚Šæ¡†ç­‰ã€‚ SDL_Rendererï¼šè™•ç†æ‰€æœ‰æ¸²æŸ“çš„çµæ§‹ã€‚å®ƒèˆ‡ SDL_Window ç¶å®šåœ¨ä¸€èµ·ï¼Œå› æ­¤åªèƒ½åœ¨è©² SDL_Window ä¸­å‘ˆç¾ã€‚ SDL_Textures å’Œ SDL_Surfaceï¼šSDL_Renderer æ¸²æŸ“SDL_Texture(å­˜å„²ä¸€å€‹å…ƒç´ çš„åƒç´ è³‡è¨Š)ã€‚é€™æ˜¯ SDL_Surface çš„æ–°ç‰ˆæœ¬ï¼Œä»–å€‘å¹¾ä¹ç›¸åŒã€‚  é‡è¦çš„å€åˆ¥æ˜¯ SDL_Surface ä½¿ç”¨è»Ÿä»¶æ¸²æŸ“ï¼ˆé€šéCPUï¼‰ï¼Œè€Œ SDL_Texture ä½¿ç”¨ç¡¬ä»¶æ¸²æŸ“ï¼ˆé€šéGPUï¼‰ã€‚     å®‰è£ï¼šsudo apt-get install libsdl2-dev libsdl2-image-dev Makefile CFLAGS := `sdl2-config --libs --cflags` -ggdb3 -O0 --std=c99 -Wall -lSDL2_image -lm all: example.c gcc example.c -o example $(CFLAGS) clean: rm example    File Descriptor  POSIX C Implementation  C æ¨™å‡†å®šç¾©äº†èªæ³•å’Œæ¨™æº–åº«ï¼Œä½†ä¸è¦ç¯„å¯¦ç¾ã€‚ æ‰€ä»¥åœ¨ Linux ä¸­ï¼Œfopenã€fcloseã€printfã€scanfã€fprintfã€fscanfã€fread å’Œ fwrite æ˜¯é€šéä½éš API å¯¦ç¾çš„ï¼š  open read write close   ç¾åœ¨ï¼Œæˆ‘å€‘å°‡ä½¿ç”¨é€™äº›è¼ƒä½ç´šåˆ¥çš„ API ä¾†è¨ªå•æ–‡ä»¶ã€‚    open, close int open(const char *pathname, int flags);\n Given a pathname for a file, open() returns a file descriptor, a small, nonnegative integer for use in subsequent system calls. open() returns the new file descriptor, or -1 if an error occurred. The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. int close(int fd); close() closes a file descriptor, so that it no longer refers to any file and may be reused. close() returns zero on success. On error, -1 is returned, and errno is set appropriately. For more flags, please read manual.  read, write ssize_t read(int fd, void *buf, size_t count);\n read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On files that support seeking, the read operation commences at the current file offset, and the file offset is incremented by the number of bytes read. If the current file offset is at or past the end of file, no bytes are read, and read() returns zero. ssize_t write(int fd, const void *buf, size_t count); write() writes up to count bytes from the buffer pointed buf to the file referred to by the file descriptor fd. How about seek? use lseek.  fstat int fstat(int fd, struct stat *buf);\n These functions return information about a file, in the buffer pointed to by buf.  mmap  \nvoid *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);\n mmap() creates a new mapping in the virtual address space of the calling process. The starting address for the new mapping is specified in addr. The length argument specifies the length of the mapping. If addr is NULL, then the kernel chooses the address at which to create the mapping. ç¾åœ¨æ‚¨å¯ä»¥å°‡è¿”å›åœ°å€è¦–ç‚ºä¸€å€‹å¤§é™£åˆ—ï¼Œæ‚¨å¯ä»¥ç›´æ¥è¨ªå•æ•¸æ“šï¼ŒåŒ…æ‹¬ä¿®æ”¹æ•¸å€¼ã€‚ åœ¨ä½¿ç”¨ mmap å¾Œï¼Œè«‹è¨˜å¾—è¦ munmapã€‚ mmap() ä¸æ˜¯æ¨™æº– C çš„å‡½å¼ MapViewOfFile function is somewhat equivalent to mmap in Windows.  ","date":"2021-05-08T17:23:11+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-04/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-04ï¼šFile Processing-02"},{"content":"File  C å°‡æ¯å€‹æª”æ¡ˆè¦–ç‚ºä¸€å€‹é€£çºŒçš„ bytes stream æ¯å€‹æª”æ¡ˆä»¥ end-of-file ç‚ºçµå°¾ï¼Œé€™æ˜¯ç”±ç³»çµ±æä¾›è€Œä¸æ˜¯æ–‡ä»¶ã€‚   It looks like there is an additional byte appended to the file. However, that additional byte does not exist. Instead, it is a signal raised by your system. int feof(FILE *stream);  File Stream  Streams æä¾›äº†æ›´é«˜ç´šåˆ¥çš„ä»‹é¢(interface)è®“ä½ å­˜å–è³‡æ–™ã€‚  fprintf fscanf   äº‹å¯¦ä¸Šï¼Œä½ å·²ç¶“ä½¿ç”¨é file stream !  ä¸‰ç¨®æ¨™æº–æµ  æ¨™æº–è¼¸å…¥ 0 (standard input.) æ¨™æº–è¼¸å‡º 1 (standard output.) æ¨™æº–éŒ¯èª¤ 2 (standard error.)   çœŸçš„å—? å“ªæ™‚å€™å‘€? scanf -\u0026gt; scanf() å¾æ¨™æº–è¼¸å…¥æµä¸­è®€å–è¼¸å…¥ scanf çš„å¯¦ä½œ int scanf(const char *fmt, ...){ int count; va_list ap; va_start(ap, fmt); count = vfscanf(stdin, fmt, ap); va_end(ap); return(count); }     File Descriptor  File descriptor ç‚ºè¼¸å‡ºå…¥çš„æ“ä½œæä¾›äº†åŸå§‹çš„ä½ç´šä»‹é¢(interface)ã€‚ åœ¨ Linux ä¸­ï¼Œä»»ä½•æ±è¥¿éƒ½å¯ä»¥è¢«è¦–ç‚ºä¸€å€‹æª”æ¡ˆã€‚  Network socker Device driver Inter-process communication   æ”¯æ´å“ªäº›æ“ä½œ?  openã€readã€writeã€close   å¦‚æœè¦æ§åˆ¶æŸäº›è©³ç´°çš„è¨­å®šï¼Œä½ éœ€è¦ä½¿ç”¨ file descriptor è€Œä¸æ˜¯ file streamã€‚  File Stream vs. File Descriptor  Structure:  Stream: FILE * Descriptor: int   å¯ä»¥ç”¨ file stream å¯¦ç¾çš„ï¼Œå°±ä¸€å®šå¯ä»¥ç”¨ file descriptor å¯¦ç¾ï¼Œå…¶é€†ä¸çœŸã€‚ File streams æœ‰æ›´å¤šæ–¹ä¾¿çš„ä»‹é¢(interface)çµ¦ä½ ä½¿ç”¨ã€‚  I/O Redirection stdout  \n \u0026gt; filename  é‡å°å‘ stdout åˆ°ä¸€å€‹æª”æ¡ˆ å¦‚æœæª”æ¡ˆä¸å­˜åœ¨å°±å‰µå»ºæ–‡ä»¶ï¼Œå¦å‰‡å°±å°‡å…¶è¦†è“‹   \u0026gt;\u0026gt; filename  é‡å°å‘ stdout åˆ°ä¸€å€‹æª”æ¡ˆ å¦‚æœæª”æ¡ˆä¸å­˜åœ¨å°±å‰µå»ºæ–‡ä»¶ï¼Œå¦å‰‡å°±åŠ åœ¨å¾Œæ–¹      \u0026gt; filename 1\u0026gt; filename  Redirect stdout to file \u0026ldquo;filename\u0026rdquo;   \u0026gt;\u0026gt; filename 1\u0026gt;\u0026gt; filename  Redirect and append stdout to file \u0026ldquo;filename\u0026rdquo;   2\u0026gt; filename  Redirect stderr to file â€filename.â€   2\u0026gt;\u0026gt; filename  Redirect and append stderr to file â€filename.â€   \u0026amp;\u0026gt; filename  Redirect stdout, stderr to file â€filename.â€    stdin $ . / abs \u0026lt; number.txt\nText File Processing fopen FILE *fopen(const char *path, const char *mode);\n pathï¼šæª”æ¡ˆè·¯å¾‘ modeï¼š  rï¼šread wï¼šwrite aï¼šappend æ›´å¤šçš„é¸é …åœ¨æ‰‹å†Šä¸­   Returnï¼šFILE *  æˆåŠŸçš„è©±ï¼ŒFILE pointer å°‡è¢«å›å‚³ å¦‚æœå¤±æ•—çš„è©±ï¼Œå°‡å›å‚³ NULL ä¸¦ä¸” errno è¢«è¨­ç½®ç‚ºè¡¨æ˜ error æ°¸é è¨˜å¾—ç¢ºèªå›å‚³çš„ pointer!    fprintf  å¹¾ä¹å’Œprintfç›¸åŒï¼Œé™¤äº†ä½ éœ€è¦çµ¦ FILE stream pointerã€‚  End-of-File Indicator  Linu/Mac OS X/UNIXï¼š\u0026lt;Ctrl\u0026gt; d Windowsï¼š\u0026lt;Ctrl\u0026gt; z + enter  fclose int fclose(FILE *stream);\n fclose() The fclose() function flushes the stream pointed to by stream (writing any buffered output data using fflush(3)) and closes the underlying file descriptor. ä¹Ÿå°±æ˜¯èªªï¼Œç•¶ä½  close æ™‚ï¼Œåœ¨ buffer ä¸­çš„è³‡æ–™å°‡è¢«å¯«å…¥æª”æ¡ˆ åœ¨é–‹æª”å¾Œè¨˜å¾—é—œä¸Šå®ƒ!! å› ç‚ºæœ‰åŒæ™‚é–‹æª”çš„æ•¸é‡ä¸Šé™ã€‚  fscanf  æ“ä½œå°±å¦‚åŒ fprintf ç•¶ç„¶ï¼Œæª”æ¡ˆæ‡‰è©²è¢«ä»¥ r çš„æ¨¡å¼æ‰“é–‹    ç•¶ä½ ä½¿ç”¨ fprintf æˆ– fscanf å»è™•ç†æ–‡å­—æª”æ™‚ï¼Œå®ƒè˜Šå«è‘—ä½ æ¸…æ¥šåœ°çŸ¥é“æª”æ¡ˆçš„æ ¼å¼ åœ¨é€™äº›æƒ…æ³ä¸‹ï¼Œè¼¸å…¥çš„æª¢æŸ¥ä¹Ÿè¨±å°±æ²’é‚£éº¼é‡è¦äº†ï¼Œå°å§?  Yesï¼šç•¢ç«Ÿæ ¼å¼ç”±ä½ æ±ºå®šã€‚ Noï¼šæœ‰äº›äººå¯èƒ½æœƒä¿®æ”¹æª”æ¡ˆï¼Œä¸¦ä½¿ä½ è®€å–å®ƒã€‚    File Position Pointer  \n æ‰€ä»¥æˆ‘å€‘å¯ä»¥è¿”å›åˆ°é–‹å§‹çš„ä½ç½®å—??  ç‚ºä»€éº¼æˆ‘å€‘éœ€è¦é€™éº¼åš? -\u0026gt; å½±ç‰‡å€’æ”¾ ç•¶ç„¶ï¼Œä½ å¯ä»¥é—œæ‰æª”æ¡ˆä¸¦é‡é–‹å®ƒã€‚ ä½†æˆ‘å€‘æœ‰å¦å¤–çš„å‡½å¼å¯ä»¥å¹«åŠ©æˆ‘å€‘ -\u0026gt; rewind    rewind void rewind(FILE *stream);\n å°‡ä½ç½®æŒ‡å›æª”æ¡ˆçš„é–‹é ­ã€‚ é‚£éº¼æˆ‘å€‘æƒ³è¦æ”¹è®Š file pointer åˆ°ä»»ä½•åœ°æ–¹å‘¢? -\u0026gt; fseek  fseek int fseek(FILE *stream, long offset, int whence);\n The fseek() function sets the file position indicator for the stream pointed to by stream. The new position, measured in bytes, is obtained by adding offset bytes to the position specified by whence. SEEK_SETï¼šæª”æ¡ˆé–‹é ­ SEEK_CURï¼šç•¶å‰ä½ç½® SEEK_ENDï¼šend-of-file    rewind() ç›¸ç•¶æ–¼ fseek(stream, 0L, SEEK_SET)  ftell long ftell(FILE *stream);\n å‘Šè¨´ä½ ç•¶å‰æ‰€åœ¨çš„ä½ç½®ã€‚  Binary File Processing Binary File  æ–‡å­—æª”ä»¥å­—å…ƒçš„æ–¹å¼å„²å­˜è³‡æ–™ï¼Œç„¶è€Œä¸¦ä¸æ˜¯æ‰€æœ‰çš„æª”æ¡ˆéƒ½æ˜¯æ–‡å­—æª”ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ç”¨æ–‡å­—ç·¨è¼¯å™¨æ‰“é–‹ä¸€å¼µåœ–ç‰‡ã€‚ æ­¤å¤–æ–‡å­—æª”çš„å„²å­˜æ•ˆç‡ä¸¦ä¸é«˜  éœ€è¦å¤šå°‘å¤§å°å»å„²å­˜æ•¸å­— 123 ? Text Fileï¼š3 bytes Binary Fileï¼š1 byte    fread size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n å¾ FILE * è®€å– nmemb å€‹è³‡æ–™ï¼Œæ¯å€‹ size bytes é•·ï¼Œä¸¦å°‡å®ƒå€‘å„²å­˜åœ¨ *ptrã€‚ æˆåŠŸæ™‚å›å‚³è³‡æ–™è®€å–çš„æ•¸é‡ã€‚å¦‚æœå¤±æ•—ï¼Œæˆ–åˆ°é”æ–‡ä»¶å°¾ç«¯æ™‚ï¼Œå‰‡å›å‚³æ˜¯ä¸€çŸ­é …è¨ˆæ•¸ (æˆ– 0)  fwrite size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n å¾ *ptr è®€å– nmemb å€‹è³‡æ–™ï¼Œæ¯å€‹ size bytes é•·ï¼Œä¸¦å°‡å®ƒå€‘å„²å­˜åœ¨ FILE *ã€‚ æˆåŠŸæ™‚å›å‚³è³‡æ–™å¯«å…¥çš„æ•¸é‡ã€‚å¦‚æœå¤±æ•—ï¼Œæˆ–åˆ°é”æ–‡ä»¶å°¾ç«¯æ™‚ï¼Œå‰‡å›å‚³æ˜¯ä¸€çŸ­é …è¨ˆæ•¸ (æˆ– 0)  BMP File Format  é€™è£¡å°‡ä½¿ç”¨ bmp æª”ä½œç‚ºç¤ºç¯„  ç‚ºä»€éº¼æ˜¯ bmp è€Œä¸æ˜¯ jpg ? -\u0026gt; å› ç‚º bmp æ˜¯ä¸€ç¨®æœªè¢«å£“ç¸®çš„ç…§ç‰‡æ ¼å¼ã€‚   é€£çµ  è®€å– bmp æª”  è®€å– bmp file header ä¸¦å°å‡ºè³‡è¨Š  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; struct _sBmpHeader { char bm[2]; uint32_t size; uint32_t reserve; uint32_t offset; uint32_t header_size; int32_t width; int32_t height; uint16_t planes; uint16_t bpp; uint32_t compression; uint32_t bitmap_size; int32_t hres; int32_t vres; uint32_t used; uint32_t important; }__attribute__ ((__packed__)); typedef struct _sBmpHeader sBmpHeader; void print_bmp_header( sBmpHeader *pHeader ) { printf( \u0026#34;ID: %c%c\\n\u0026#34;, pHeader -\u0026gt; bm[0], pHeader -\u0026gt; bm[1] ); printf( \u0026#34;Size: %u\\n\u0026#34;, pHeader -\u0026gt; size ); printf( \u0026#34;Reserve: %u\\n\u0026#34;, pHeader -\u0026gt; reserve ); printf( \u0026#34;Offset: %u\\n\u0026#34;, pHeader -\u0026gt; offset ); printf( \u0026#34;Header Size: %u\\n\u0026#34;, pHeader -\u0026gt; header_size ); printf( \u0026#34;Width: %u\\n\u0026#34;, pHeader -\u0026gt; width ); printf( \u0026#34;Height: %u\\n\u0026#34;, pHeader -\u0026gt; height ); printf( \u0026#34;Planes: %u\\n\u0026#34;, pHeader -\u0026gt; planes ); printf( \u0026#34;Bits Per Pixel: %u\\n\u0026#34;, pHeader -\u0026gt; bpp ); printf( \u0026#34;Compression: %u\\n\u0026#34;, pHeader -\u0026gt; compression ); printf( \u0026#34;Bitmap Data Size: %u\\n\u0026#34;, pHeader -\u0026gt; bitmap_size ); printf( \u0026#34;H-Resolution: %u\\n\u0026#34;, pHeader -\u0026gt; hres ); printf( \u0026#34;V-Resolution: %u\\n\u0026#34;, pHeader -\u0026gt; vres ); printf( \u0026#34;Used Colors: %u\\n\u0026#34;, pHeader -\u0026gt; used ); printf( \u0026#34;Important Colors: %u\\n\u0026#34;, pHeader -\u0026gt; important ); return; } int main() { FILE *pFile = NULL; if((pFile = fopen(\u0026#34;maldives_16.bmp\u0026#34;, \u0026#34;rb\u0026#34;)) == NULL) { printf(\u0026#34;File could not be opened!\\n\u0026#34;); return 0; } sBmpHeader header; printf(\u0026#34;%lu\\n\u0026#34;, sizeof(header)); fread(\u0026amp;header, 54, 1, pFile); print_bmp_header(\u0026amp;header); fclose(pFile); return 0; } ä¿®æ”¹ bmp æª”  ç¿»è½‰é¡è‰²  // ...ç•¥... int main() { FILE *pFile = NULL; FILE *pFile2 = NULL; if((pFile = fopen(\u0026#34;maldives.bmp\u0026#34;, \u0026#34;rb\u0026#34;)) == NULL) { printf( \u0026#34;File could not be opened!\\n\u0026#34; ); return 0; } if((pFile2 = fopen(\u0026#34;maldives_gray.bmp\u0026#34;, \u0026#34;wb\u0026#34;)) == NULL) { printf(\u0026#34;File could not be opened!\\n\u0026#34;); return 0; } sBmpHeader\theader; fread( \u0026amp;header, sizeof( header ), 1, pFile ); fwrite( \u0026amp;header, sizeof( header ), 1, pFile2 ); while(!feof(pFile)) { uint8_t\toriginal[1024] = {0}; uint8_t modified[1024] = {0}; size_t count = fread( original, 1, 1024, pFile ); for(size_t i = 0; i \u0026lt; count; ++i){ modified[i] = 255 - original[i]; } fwrite( modified, count, 1, pFile2 ); } fclose( pFile ); fclose( pFile2 ); return 0; }  è½‰æˆç°éš  // ...ç•¥... while(!feof(pFile)) { uint8_t\toriginal[999] = {0}; uint8_t modified[999] = {0}; size_t count = fread( original, 1, 999, pFile ); for(size_t i = 0; i \u0026lt; count; i = i + 3) { // BGR  uint8_t gray = 0.299 * original[i+2] + 0.587 * original[i+1] + 0.114 * original[i]; for(size_t j = 0; j \u0026lt; 3; ++j) { modified[i+j] = gray; } } fwrite(modified, count, 1, pFile2); } // ...ç•¥...  Hex ç·¨è¼¯å·¥å…·  Bless Hex Editor GHex  ","date":"2021-04-02T17:58:22+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-03/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-03ï¼šFile Processing-01"},{"content":"Structure  Structures å°±æ˜¯å°‡ä¸€å †ç›¸é—œçš„è®Šæ•¸æ•´åˆåœ¨ä¸€å€‹åå­—ä¸‹ã€‚  é—œéµå­—ï¼šstruct è³‡æ–™å‹åˆ¥ï¼šstruct _name_ æˆå“¡ï¼šåœ¨ struct çš„å¤§æ‹¬è™Ÿå…§å®£å‘Šçš„è®Šæ•¸ã€‚ åŒä¸€å€‹çµæ§‹é«”ä¸‹çš„æˆå“¡åç¨±æ˜¯å”¯ä¸€çš„ã€‚  struct _sCard{ uint8_t suit, face; };  åˆå§‹åŒ– struct _sCard a_card = {.suit = 1, .face = 2}; struct _sCard a_card = {1, 2};  structure member operator -\u0026gt; . structure pointer operator -\u0026gt; -\u0026gt; a_card_ptr = \u0026amp;a_card; a_card_ptr-\u0026gt;face = 5; // Equivalent to (*a_card_ptr).face = 5;   CPU Alignment  CPU æœ‰æ™‚å€™æœƒç‚ºäº†æ¸›å°‘å¾è¨˜æ†¶é«”å‘¼å«è®Šæ•¸çš„æ¬¡æ•¸ï¼Œè€Œä¸»å‹•å°‡è®Šæ•¸çš„è¨˜æ†¶é«”æ”¾åœ¨é€£çºŒçš„åœ°æ–¹ã€‚ ç‚ºäº†é¿å… alignmentï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å…©ç¨®æ–¹æ³•ï¼š  __attribute__((packed)) pragma #pragma pack(push) #pragma pack(1) #pragma pack(pop)   // æ³•ä¸€ struct st{ ... }__attribute__((packed)); // æ³•äºŒ #pragma pack(push) #pragma pack(1) struct st{ ... }; #pragma pack(pop)  Structure ä¸èƒ½åŒ…å«è‡ªå·±ï¼Œå¦‚æœéœ€è¦è«‹ç”¨ pointer ! struct student { char name [64]; uint8_t age; uint8_t gender; struct student *leader; };   typedef  ç”±æ–¼è»Ÿé«”é–‹ç™¼è€…ç›¡å¯èƒ½çš„ä¿æŒæ‡¶æƒ°ï¼Œå› æ­¤ä»–å€‘å˜—è©¦ç¸®çŸ­ç¨‹å¼ç¢¼ã€‚ ç‚ºäº†æé«˜å¯è®€æ€§  typedef struct card Card; typedef struct card { uint8_t suit; uint8_t face; } Card; Structure With Functions  ç‚ºä»€éº¼æˆ‘å€‘æ™‚å¸¸ä»¥å‚³å€çš„æ–¹å¼å‚³é€ Structures ?  å› ç‚ºæ•ˆç‡   å‚³å€¼ vs å‚³å€      const int *a; // declare a as pointer to int int const *a; // syntax error int * const a; // declare a as const pointer to int int const * const a; // syntax error const int *a; // declare a as pointer to const int const int * const a; // declare a as const pointer to const int  Although C and C++ read mostly from top-to-bottom and left-to-right, pointer declarations read, in a sense, backwards.  Union  Union æ˜¯æ‰€æœ‰æˆå“¡å…±äº«ç›¸åŒè¨˜æ†¶é«”ç©ºé–“çš„æ´¾ç”Ÿæ•¸æ“šé¡å‹ã€‚ è¨˜æ†¶é«”å¤§å°è¶³ä»¥å®¹ç´æœ€å¤§çš„æˆå“¡ã€‚ å¯¦éš›æ‡‰ç”¨  struct ip_addr { uint8_t fam; // socket family type  union { struct in_addr ipv4_sin_addr; struct in6_addr ipv6_sin_addr; }addr; }; Bitwise Operation  \u0026amp;ï¼šAND -\u0026gt; 0\u0026amp;0 = 0; 0\u0026amp;1 = 0; 1\u0026amp;0 = 0; 1\u0026amp;1 = 1. |ï¼šOR -\u0026gt; 0|0 = 0; 0|1 = 1; 1|0 = 1; 1|1 = 1. ^ï¼šXOR -\u0026gt; 0^0 = 0; 0^1 = 1; 1^0 = 1; 1^1 = 0. ~ï¼šComplement -\u0026gt; \\(\\text{\\textasciitilde}4_{10}\\) =\u0018 \\(\\text{\\textasciitilde}100_2\\) = \\(011_2\\) = \\(3_{10}\\). \u0026lt;\u0026lt;ï¼šLeft Shift 0012 \u0026laquo; 2 = 1002. \u0026gt;\u0026gt;ï¼šRight Shift 1002 \u0026raquo; 2 = 0012.    ç‚ºä»€éº¼æˆ‘å€‘éœ€è¦ bitwise operation ?  åœ¨å¤§å¤šæ•¸æƒ…æ³ä¸‹ï¼ŒæŒ‰ä½é‹ç®—æ¯”ç®—è¡“é‹ç®—è¦å¿«ã€‚  a = a * 2 a = a \u0026laquo; 1   ç”±æ–¼ç·¨è­¯å™¨å„ªåŒ–ï¼Œé€™å¯èƒ½ä¸æ˜¯æ­£ç¢ºçš„ã€‚   Mask with better memory utilization. Game Cheating Example  ï¼ï¼‘ â½•ç‚è¡“ ï¼‘ï¼ é›»æ“Šè¡“ ï¼ï¼’ çƒˆç‚è¡“ ï¼’ï¼ è½é›·è¡“ ï¼ï¼” ç‚â¿“è¡“ ï¼”ï¼ è½Ÿé›·è¡“ ï¼ï¼˜ å¤©â½•è¡“ ï¼˜ï¼ ç¥é›·è¡“    Bit Fields typedef union { struct { unsigned char b1:1; unsigned char b2:1; unsigned char b3:1; unsigned char b4:1; unsigned char b5:1; unsigned char b6:1; unsigned char b7:1; unsigned char b8:1; } bits; unsigned char byte; } uByte;  ç”±æ–¼ alignment å•é¡Œï¼Œè¨˜æ†¶é«”çš„ç©ºé–“å¯èƒ½ä¸æ˜¯å®‰å…¨çš„ï¼Œé€™å–æ±ºæ–¼ä½ å¦‚ä½•å„²å­˜ä½ çš„è³‡æ–™ã€‚ å¯¦éš›ä¸Šï¼Œbit fields å¯èƒ½æœƒå¢åŠ ç·¨ç¨‹æ™‚çš„é›£åº¦ã€‚æˆ‘ä¸å»ºè­°æ‚¨ä½¿ç”¨æ­¤åŠŸèƒ½ï¼Œä½†æ˜¯ï¼Œæ‚¨éœ€è¦äº†è§£æ­¤èªæ³•ï¼Œå› ç‚ºå…¶ä»–äººå¯èƒ½æœƒä½¿ç”¨å®ƒã€‚ Do not take the address of a bit field.  Enumeration  A set of integer enumeration constants represented by identifiers.  enum career { SABER, LANCER, ARCHER, RIDER, CASTER, ASSASSIN, BERSAKER, RULER, CAREER_MAX = 31 }; typedef struct player { char name[64]; enum career role; uint32_t role2; } Player;  ä½ ä¸èƒ½æ”¹è®Š enumeration constants çš„å€¼ã€‚ æˆ‘æ˜¯å¦å¯ä»¥ä½¿ç”¨ define æˆ– const è€Œä¸æ˜¯ enum?  æ˜¯ï¼Œå¯ä»¥çš„ã€‚ ä½†ä»–å€‘æœ‰ä»€éº¼ä¸åŒå‘¢?    ","date":"2021-04-02T16:24:46+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-02/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-02ï¼šStructure"},{"content":"å­—å…ƒ  åœ¨è¬›å­—ä¸²ä¹‹å‰æˆ‘å€‘å…ˆä¾†çœ‹ä»€éº¼æ˜¯å­—å…ƒã€‚  ASCII  American Standard Code for Information Interchange. é›»å­é€šè¨Šçš„å­—å…ƒç·¨ç¢¼æ¨™æº– åŸºæ–¼è‹±æ–‡å­—æ¯ï¼ŒASCII å°‡ 128 å€‹å­—å…ƒç·¨ç¢¼æˆ 7 å€‹ä½å…ƒé•·ã€‚  95 å€‹å¯å°å­—å…ƒï¼šA-Z, a-z, 0-9, æ¨™é»ç¬¦è™Ÿ ä¸å¯å°å­—å…ƒï¼šæ›è¡Œç¬¦è™Ÿ      åœ¨é›»è…¦ä¸­æˆ‘å€‘ä½¿ç”¨ 8-bit çš„è¨˜æ†¶é«”å„²å­˜å­—å…ƒã€‚ åœ¨ C èªè¨€ä¸­ï¼Œä½¿ç”¨ char é€™å€‹å‹åˆ¥ã€‚ %c -\u0026gt; è¼¸å‡ºå­—å…ƒ %x or %X -\u0026gt; å°å‡º hex or HEX çš„å€¼ã€‚    åœ¨ä»¥å‰ï¼Œè¨±å¤šæƒ…æ³ä¸‹ï¼Œæœ‰äº›äººä½¿ç”¨ unsigned char ä½œç‚º one byte çš„è³‡æ–™å‹åˆ¥ï¼Œä½†ç¾ä»Šä½ æ‡‰è©²ä½¿ç”¨çš„æ˜¯ uint8_tã€‚ è«‹æŠŠ char ç•™çµ¦å­—ä¸²ï¼Œç›¡ç®¡äº‹å¯¦ä¸Šå°é›»è…¦ä¾†èªªéƒ½æ˜¯ä¸€æ¨£çš„ã€‚ å…¶ä»–ç·¨ç¢¼ï¼šBig5ã€UTF-8  å­—ä¸²  äº‹å¯¦ä¸Šï¼Œå­—ä¸²å°±æ˜¯ä¸€é€£ä¸²çš„å¯å°å­—å…ƒã€‚ é€™æ¨£çœ‹èµ·ä¾†å¾ˆåƒé™£åˆ—å°å§? Yes!    \n åœ¨ C èªè¨€ä¸­ï¼Œå­—ä¸²æ˜¯ä¸€å€‹å­—å…ƒæŒ‡æ¨™ï¼Œä¸¦ä»¥ '\\0' ç‚ºçµå°¾ã€‚ å¸¸è¦‹çš„éŒ¯èª¤ï¼š  æ²’æœ‰åˆ†é…è¶³å¤ çš„ç©ºé–“ è¼¸å‡ºä¸€å€‹ä¸åŒ…å« '\\0' çš„å­—ä¸² åœ¨ C çš„æ¨™æº–ä¸­ï¼Œå­—å…ƒæŒ‡æ¨™æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œå¦‚æœè¦ä¿®æ”¹å­—ä¸²ï¼Œå¿…é ˆå„²å­˜åœ¨å­—å…ƒé™£åˆ—ä¸­ã€‚    å­—ä¸²è™•ç†å‡½å¼  é¦–å…ˆï¼Œé€™éƒ¨åˆ†æœ‰å°è±¡å°±å¥½ï¼Œä¸ç”¨è¨˜ï¼Œç•¢ç«Ÿåˆ°é€™é‚Šå¤§å®¶æ‡‰è©²éƒ½æœ‰èƒ½åŠ›è‡ªå·±å¯¦ä½œå‡ºä¾†å§!  å­—ä¸²è½‰æ•´æ•¸  å¾ˆä¹…å¾ˆä¹…ä»¥å‰ #include \u0026lt;stdlib.h\u0026gt;int atoi(const char *nptr); long atol(const char *nptr);  ç¾ä»Š #include \u0026lt;stdlib.h\u0026gt;// string to double double strtod(const char *nptr, char **endptr); // string to long int long int strtol(const char *nptr, char **endptr, int base);   è¼¸å‡ºå…¥å‡½å¼  è¼¸å‡º  #include \u0026lt;stdio.h\u0026gt;int putchar(int c); // è¼¸å‡ºå­—å…ƒ int puts(const char *s); // è¼¸å‡ºå­—ä¸² int snprintf(char *restrict buffer, size_t bufsz, const char *restrict format, ... );  è¼¸å…¥  #include \u0026lt;stdio.h\u0026gt;int getchar(void); // è¼¸å…¥å­—å…ƒ char *fgets(char *s, int size, FILE *stream); // è¼¸å…¥å­—ä¸² int sscanf(const char *restrict buffer, const char *restrict format, ... );   ä¸€äº›ä¸æ¨è–¦çš„å‡½å¼ï¼Œæ°¸é ä¸è¦ç”¨ä»–å€‘  char *gets(char *s); int sprintf(char *str, const char *format, ...);   æœ‰ buffer overflow çš„é¢¨éšª  å­—ä¸²æ“ä½œå‡½å¼ char *strncpy(char *dest, const char *src, size_t n); // è¤‡è£½å­—ä¸² char *strncat(char *dest, const char *src, size_t n); // ä¸²æ¥å­—ä¸²   å’Œä¸Šè¿°ç†ç”±ä¸€æ¨£ï¼Œä¸è¦ä½¿ç”¨ä¸‹æ–¹çš„å‡½å¼  char *strcpy(char *dest,const char *src); char *strcat(char *dest,const char *src);    å­—ä¸²æ¯”è¼ƒå‡½å¼ #include \u0026lt;string.h\u0026gt;int strcmp(const char *s1, const char *s2); int strncmp(const char *s1, const char *s2, size_t n);  å¦‚æœs1ï¼ˆæˆ–å…¶å‰nå€‹å­—ç¯€ï¼‰åˆ†åˆ¥å°æ–¼ã€åŒ¹é…æˆ–å¤§æ–¼s2ï¼Œå‰‡å‡½æ•¸å°‡è¿”å›å°æ–¼ã€ç­‰æ–¼æˆ–å¤§æ–¼é›¶çš„æ•´æ•¸ã€‚  å­—ä¸²æœå°‹å‡½å¼ #include \u0026lt;string.h\u0026gt;char *strchr(const char *s, int c); // å¾é ­æ‰¾å­—å…ƒ char *strrchr(const char *s, int c); // å¾å°¾æ‰¾å­—å…ƒ // è¨ˆç®— s çš„å‰ç¶´æœ‰å¤šå°‘å­—å…ƒåœ¨ accept ä¸­ size_t strspn(const char *s, const char *accept ); // è¨ˆç®— s çš„å‰ç¶´æœ‰å¤šå°‘å­—å…ƒä¸åœ¨ reject ä¸­ size_t strcspn(const char *s, const char *reject ); // å›å‚³åœ¨ accept ä¸­çš„ä»»ä½•å­—å…ƒåœ¨ s å­—ä¸²é¦–æ¬¡å‡ºç¾ä½ç½®çš„æŒ‡æ¨™ char *strpbrk(const char *s, const char *accept ); // å›å‚³ needle åœ¨ haystack ä¸­é¦–æ¬¡å‡ºç¾ä½ç½®çš„æŒ‡æ¨™ char *strstr(const char *haystack, const char *needle ); // ä¾ç…§ delim ä¸­çš„å­—å…ƒåˆ†å‰² str char *strtok(char *str, const char *delim ); strtok ç¯„ä¾‹ char str[] = \u0026#34;the value of pi is 3.14\u0026#34;; char *token = strtok(str, \u0026#34; \u0026#34;); while(token != NULL) { printf(\u0026#34;%d: %s\\n\u0026#34;, i, token); token = strtok(NULL, \u0026#34; \u0026#34;); }  ç‚ºä½•ç¬¬äºŒæ¬¡ä¹‹å¾Œå‘¼å«éƒ½æ˜¯ä»¥ NULL ä½œç‚ºè¼¸å…¥?  å› ç‚ºé€™æ˜¯ä¸€å€‹ static çš„è®Šæ•¸ã€‚å¦‚æœè¼¸å…¥ NULLï¼Œè©²å‡½å¼å°‡ç¹¼çºŒå¾æœ€å¾Œä¸€å€‹ä½ç½®åˆ‡å‰²å­—ä¸²ã€‚   ç‚ºç”šéº¼æˆ‘ä¸èƒ½ç›´æ¥ä½¿ç”¨ const char *str?  å› ç‚º strtok çš„å¯¦ä½œï¼Œå°‡æœƒç›´æ¥æ“ä½œåœ¨è¼¸å…¥çš„å­—ä¸²ä¸Šã€‚    å…¶ä»–å­—ä¸²å‡½å¼ #include \u0026lt;string.h\u0026gt;size_t strlen(const char *s); // è¨ˆç®—å­—ä¸²é•·åº¦ // è¼¸å‡ºéŒ¯èª¤è¨Šæ¯ char *strerror(int errnum); void perror(const char *str);  strerror æ­é… errno ä½¿ç”¨ (#include \u0026lt;errno.h\u0026gt;)  ","date":"2021-04-02T14:40:30+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-01/","title":"ç¨‹å¼è¨­è¨ˆ(äºŒ)-01ï¼šString"},{"content":"ç°¡ä»‹  é€™éƒ¨ä»½æ˜¯ç´€éŒ„æˆ‘ä¿®æ”¹çš„ä¸»é¡Œå…§å®¹ï¼Œä¸¦å°‡ codeblocks å€å¡Šç¾åŒ–ï¼Œä»¥åŠæ”¯æ´ KaTex å’Œ Google Analytics  æ•™å­¸é–‹å§‹  æˆ‘ä½¿ç”¨çš„ä¸»é¡Œç‚º Stack  ä¸»é¡Œå…§å®¹ä¿®æ”¹  æ‰¾åˆ° assets/scss/variables.scssï¼Œä¸¦ä¿®æ”¹ --link-background-color: 90, 240, 250; //189, 195, 199; --code-text-color: #ef3982; //rgba(255, 255, 255, 0.9);   Codeblocks å€å¡Šç¾åŒ–  åˆ° static/css/ ä¸‹å»ºç«‹ copy-to-clipboard.cssï¼Œå…§å®¹å¦‚ä¸‹ .highlight { position: relative; } .highlight .ln { -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; } .highlight-copy-btn { position: absolute; top: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; color: #fff; background-color: #777; min-width: 55px; text-align: center; } .highlight-copy-btn:hover { background-color: #666; }  åˆ° static/js/ ä¸‹å»ºç«‹ copy-to-clipboard.jsï¼Œå…§å®¹å¦‚ä¸‹ (function () { \u0026#39;use strict\u0026#39;; if (!document.queryCommandSupported(\u0026#39;copy\u0026#39;)) { return; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function selectText(node) { var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range); return selection; } function addCopyButton(containerEl) { var copyBtn = document.createElement(\u0026#34;button\u0026#34;); copyBtn.className = \u0026#34;highlight-copy-btn\u0026#34;; copyBtn.textContent = \u0026#34;Copy\u0026#34;; var codeEl = containerEl.firstElementChild; copyBtn.addEventListener(\u0026#39;click\u0026#39;, function () { try { var selection = selectText(codeEl); document.execCommand(\u0026#39;copy\u0026#39;); selection.removeAllRanges(); flashCopyMessage(copyBtn, \u0026#39;Copied!\u0026#39;) } catch (e) { console \u0026amp;\u0026amp; console.log(e); flashCopyMessage(copyBtn, \u0026#39;Failed :\\\u0026#39;(\u0026#39;) } }); containerEl.appendChild(copyBtn); } // Add copy button to code blocks  var highlightBlocks = document.getElementsByClassName(\u0026#39;highlight\u0026#39;); Array.prototype.forEach.call(highlightBlocks, addCopyButton); })();  ä¿®æ”¹ config.yaml custom_css:[\u0026#34;css/copy-to-clipboard.css\u0026#34;]pygmentsUseClasses:truemarkup:highlight:lineNos:truelineNumbersInTable:false ä¿®æ”¹ layouts/partials/head/custom.html {{ range .Site.Params.custom_css -}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt; {{- end }} {{ range .Site.Params.custom_js -}} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{- end }}  ä¿®æ”¹ layouts/partials/footer/custom.html \u0026lt;script src=\u0026#34;/js/copy-to-clipboard.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  é€™æ¨£ç¨‹å¼ç¢¼å€å¡Šå°±æœ‰ Copy Buttonï¼Œä¸¦ä¸”ç›´æ¥è¤‡è£½æ™‚ä¸æœƒé¸å–åˆ°è¡Œè™Ÿäº†  KaTex  åˆ° layouts/partials/ ä¸‹æ–°å¢ math.htmlï¼Œå…§å®¹å¦‚ä¸‹ {{ if or .Params.math .Site.Params.math }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true}, {left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true}, {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false}, {left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false} ] }); }); \u0026lt;/script\u0026gt; {{ end }}  ä¿®æ”¹ layouts/partials/head/custom.html {{ partial \u0026#34;math.html\u0026#34; . }}   Google Analytics  åˆ° Google Analytics å‰µå»ºä¸€å€‹è³‡æ–™ä¸²æµ ç”±æ–¼ Hugo å…§å»ºçš„ GA æ¨¡æ¿ï¼Œä¼¼ä¹é‚„ä¸æ”¯æ´ GA4ï¼Œå› æ­¤æˆ‘å€‘ä½¿ç”¨ gtag.js è¤‡è£½å‰›å‰›å»ºç«‹çš„è³‡æ–™ä¸²æµä¸­çš„ gtag.js å…§å®¹åˆ° layouts/partials/google_analytics.htmlä¸­ ä¿®æ”¹ layouts/partials/head/custom.html {{ if not .Site.IsServer }}{{ partial \u0026#34;google_analytics.html\u0026#34; . }}{{ end }}  é€™è£¡çš„ if æ˜¯é¿å…åœ¨ local æ¸¬è©¦æ™‚çš„æ•¸æ“šä¹Ÿè¢«ç´€éŒ„ä¸‹ä¾†     Hugo æ–¼ 0.82.0 ç‰ˆæœ¬å·²æ›´æ–°äº†å° GA4 çš„æ”¯æ´ï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¸‹\n  åŒä¸Š åœ¨ config.yaml ä¸­è¨­å®š googleAnalytics: G- ä¿®æ”¹ layouts/partials/head/custom.html {{ template \u0026#34;_internal/google_analytics.html\u0026#34; . }}   ","date":"2021-02-07T04:06:17+08:00","permalink":"https://blog.smallten.tk/p/hugo-02/","title":"Hugo-02ï¼šå„ªåŒ– Blog"},{"content":"ç°¡ä»‹  é€™ç¯‡å…§å®¹å°‡å¿«é€Ÿå¸¶ä½ å»ºç«‹ä¸€å€‹ Hugo Blog ä¸¦å°‡å…¶éƒ¨å±¬åˆ° GitHub ä¸Š  ç›¸é—œé€£çµ  Hugo - Hugo å®˜ç¶² Hugo Themes - é¸æ“‡è‡ªå·±å–œæ­¡çš„ä¸»é¡Œ Hugo Releases - ä¸‹è¼‰ Hugo ä¸¦å®‰è£é€²é›»è…¦  æ•™å­¸é–‹å§‹ å»ºç«‹ Hugo Blog  å®‰è£ Hugo  é€™è£¡ä»¥ Ubuntu ç‚ºç¤ºç¯„ å…ˆè‡³ Hugo Releases ä¸‹è¼‰è‡ªå·±æ‰€éœ€çš„ç‰ˆæœ¬ $ dpkg -i hugo_extended_0.79.0_Linux-64bit.deb # è¨˜å¾—ä¾ç…§æª”æ¡ˆè‡ªè¡Œæ›´æ”¹    å‰µå»ºä¸€å€‹ Hugo Site  é€™è£¡å‰µå»ºä¸€å€‹åç‚º blog $ cd ~ $ hugo new site blog # å¯è‡ªè¡Œä¿®æ”¹åç¨±    æ–°å¢ä¸»é¡Œ  é€™è£¡æˆ‘é¸æ“‡äº† Stack é€™å€‹ä¸»é¡Œ  $ cd ~/blog/ $ git init $ git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack  è·Ÿè‘—ä¸»é¡Œçš„æ•™å­¸æ–‡æª”ä¿®æ”¹ config file å¦‚è¦å»ºç«‹æ–°æ–‡ç« æ™‚ $ hugo new post/test.md  æ­¤æ™‚æœƒåœ¨ content/post/ ä¸‹ï¼Œå»ºç«‹æ–°æ–‡ç« ï¼Œæª”åç‚º test.md draft: è‰ç¨¿ slug: æ­¤æ–‡ç« çš„ url (å¯è‡ªè¡Œå»ºç«‹)   æœ¬æ©Ÿæ¸¬è©¦ $ hugo server -D  -D: å°‡æœƒé€£è‰ç¨¿éƒ½é¡¯ç¤ºå‡ºä¾†    éƒ¨ç½²åˆ° GitHub  åœ¨ GitHub ä¸Šå»ºç«‹ä¸€å€‹æ–°çš„ Repository  åç¨±ç‚º \u0026quot;Your account\u0026quot;.github.io (\u0026ldquo;Your account\u0026rdquo; ä½¿ç”¨è‡ªå·± GitHub çš„åç¨±)   å°‡å‰›æ‰å»ºç«‹å¥½çš„ Blog ä¸Šåˆ°é€™å€‹ Repo $ cd ~/blog/ $ git add --all $ git commit -m \u0026#34;blog init\u0026#34; $ git branch -M main $ git remote add origin git@github.com... #é€™è£¡ä½¿ç”¨äº† ssh çš„æ–¹å¼ $ git push -u origin main  ä½¿ç”¨ GitHub Actions  å»ºç«‹ä¸€å€‹ workflows åå« hugo_publish.yml (æœ‰äº›åœ°æ–¹é ˆè‡ªè¡Œä¾ç…§æƒ…æ³ä¿®æ”¹) å…§å®¹ï¼šhugo_publish.yml   ä¿®æ”¹ Repo çš„è¨­å®š  å…ˆæ‰¾åˆ° GitHub Pages çš„åœ°æ–¹ å°‡ Source æ”¹æˆ Branch: gh-pages æœ‰ custom domain çš„è¨˜å¾—å¡«å…¥ Enforce HTTPS æ‰“å‹¾   é€™æ¨£å°±å®Œæˆäº†ï¼Œä¹‹å¾Œåªè¦ push æ™‚ï¼Œä¾¿æœƒè‡ªå‹•æ›´æ–°ç¶²ç«™äº†  ","date":"2021-02-07T03:22:22+08:00","permalink":"https://blog.smallten.tk/p/hugo-01/","title":"Hugo-01ï¼šå»ºç«‹ä¸€å€‹Hugo Blog"},{"content":"Pointer  è¨±å¤šäººä¸å–œæ­¡Cæ˜¯å› ç‚ºæœ‰ã€ŒæŒ‡æ¨™ã€ é€™å¯èƒ½æ˜¯Cä¸­æœ€å›°é›£çš„ä¸€å€‹éƒ¨åˆ†    æŒ‡æ¨™æ˜¯ä¸€å€‹è®Šæ•¸ï¼Œå…¶å€¼ç‚ºè¨˜æ†¶é«”ä½ç½®   å®£å‘Šï¼šint32_t *p  p æ˜¯ä¸€å€‹æŒ‡æ¨™ æŒ‡å‘çš„è¨˜æ†¶é«”å€å¡Šè¢«è¦–ç‚ºæ•´æ•¸   åˆå§‹åŒ–ï¼šint32_t *p = NULL address operator \u0026amp;ï¼šè¿”å›å…¶è®Šæ•¸çš„è¨˜æ†¶é«”ä½ç½®  å¦‚æœæƒ³è¦å°å‡ºè¨˜æ†¶é«”ä½ç½®ï¼Œä½ å¯ä»¥ä½¿ç”¨%p   indirection operator *ï¼šä¹Ÿè¢«ç¨±ç‚ºdereferencing operatorï¼Œè¿”å›æŒ‡å‘å°è±¡çš„å€¼   void *ï¼šæ˜¯ä¸€å€‹é€šç”¨çš„æŒ‡æ¨™å‹åˆ¥(generic pointer type)ï¼Œå¯ä»¥ä¸é€éexplicit castè½‰æ›æˆä»»æ„æŒ‡æ¨™çš„å‹åˆ¥  å‚³åƒæ•¸è‡³å‡½å¼  åœ¨Cèªè¨€ä¸­ï¼Œargument passing ç¨±ç‚º call-by-value  é›»è…¦å°‡æœƒåˆ†é…å¦ä¸€å€‹è¨˜æ†¶é«”å€å¡Š è¤‡è£½è¼¸å…¥çš„åƒæ•¸åˆ°è¨˜æ†¶é«”å€å¡Š å‡½å¼å°‡æœƒåœ¨æ–°çš„è¨˜æ†¶é«”å€å¡ŠåŸ·è¡Œ   é€™å°±æ˜¯ç‚ºä»€éº¼ä¿®æ”¹å‡½å¼ä¸­çš„è®Šæ•¸ï¼Œä¸¦ä¸æœƒä¿®æ”¹åˆ°åŸæœ¬å¤–éƒ¨çš„è®Šæ•¸äº†ã€‚ åœ¨C++æœ‰å¦ä¸€ç¨®å‚³é€æ–¹å¼ç¨±ç‚º call-by-referenceï¼Œé€™é‚Šæˆ‘å€‘ä¸å¤šåŠ ä»‹ç´¹ã€‚ æ™®éä¾†èªªï¼Œå‚³å€æœƒæ¯”å‚³å€¼æ›´å¿«ã€‚  é™£åˆ—èˆ‡æŒ‡æ¨™  åœ¨å¤§éƒ¨åˆ†çš„æƒ…æ³ä¸‹ï¼Œæˆ‘å€‘å¯ä»¥æŠŠarrayè¦–ç‚ºç¬¬ä¸€å€‹å…ƒç´ çš„æŒ‡æ¨™  ç¾åœ¨ä½ æ‡‰è©²æ˜ç™½ç‚ºä»€éº¼é™£åˆ—çš„å€¼æœƒåœ¨å‡½å¼ä¸­è¢«ä¿®æ”¹   ç‚ºäº†é¿å…æ¨¡æ£±å…©å¯(ææ··)ï¼Œæˆ‘è¼ƒå–œæ­¡\u0026amp;(array[0])è€Œä¸æ˜¯arrayã€\u0026amp;array ç„¶è€Œä½ ä¸èƒ½å¯«å‡º array = \u0026amp;a int32_t   int16_t   int8_t   ptr++  ç§»å‹•çš„å¤§å°æ˜¯æ ¹æ“šæŒ‡æ¨™çš„å‹åˆ¥ é€™åœ¨è¦è®€å–æ¯ä¸€byteçš„è©³ç´°è³‡æ–™æ™‚éå¸¸å¥½ç”¨   äº‹å¯¦ä¸Šï¼Œarray[n] = *(ptr + n)  Endian Issue  \nå‡½å¼æŒ‡æ¨™  æŒ‡æ¨™ä¸éæ˜¯ä¸€å€‹è¨˜æ†¶é«”ä½å€ã€‚ ç•¶æˆ‘å€‘å®£å‘ŠæŸç¨®é¡å‹çš„æŒ‡æ¨™æ™‚ï¼Œé€™æ„å‘³è‘—é›»è…¦å°‡å°‡è¨ªå•è¨˜æ†¶é«”ä¸¦æ ¹æ“šçµ¦å®šçš„é¡å‹è§£é‡‹å­˜å„²åœ¨è©²ä½å€çš„å€¼ã€‚ æ‚¨æ˜¯å¦çŸ¥é“å‡½å¼ä¹Ÿå­˜å„²åœ¨è¨˜æ†¶é«”ä¸­ï¼Ÿ ä½¿ç”¨å‡½å¼æŒ‡æ¨™æ™‚ï¼Œè¿”å›çš„å‹åˆ¥å’Œåƒæ•¸æ‡‰è©²è¦å’Œå¯¦éš›çš„å®šç¾©ç›¸åŒã€‚  Really??ç‚ºä»€éº¼åœ¨ç·¨è­¯æ™‚ä¸æœƒç”¢ç”Ÿerrors? é€™æ˜¯å€‹æª¢æŸ¥definitionçš„å¥½ç¿’æ…£ã€‚   å›å‘¼å‡½å¼ (Callback function) ä½ å¯ä»¥ç”¨é™£åˆ—ä¾†å„²å­˜å‡½å¼æŒ‡æ¨™ void (*f[3])(int32_t) = {f1, f2, f3};    ä½¿ç”¨äº†å‡½å¼æŒ‡æ¨™çš„ä¾‹å­  Menu Driven Driver struct file_operations scull_fops = { .owner = THIS_MODULE , .llseek = scull_llseek , .read = scull_read , .write = scull_write , .ioctl = scull_ioctl , .open = scull_open , .release = scull_release , };  Firewall  static unsigned int hook_func( const struct nf_hook_ops *ops , struct sk_buff *skb , const struct net_device *in , const struct net_device *out , int (*okfn)( struct sk_buff *) )   è¨˜æ†¶é«”ç®¡ç†  è¨˜æ†¶é«”ç®¡ç†  åˆ†é…è¨˜æ†¶é«”ç•¶ä½ å®£å‘Šä¸€å€‹è®Šæ•¸ åƒåœ¾å›æ”¶ ( GC )   ç‚ºä»€éº¼è¨±å¤šç¾ä»£çš„ç¨‹å¼èªè¨€ä¸æ”¯æ´è¨˜æ†¶é«”ç®¡ç†  è»Ÿé«”å·¥ç¨‹å¸«æ˜¯äººé¡ äººæ˜¯ä¸å¯è¢«ä¿¡ä»»çš„   ç„¶è€Œï¼Œå¦‚æœè»Ÿé«”å·¥ç¨‹å¸«çŸ¥é“ä»–å€‘åœ¨åšä»€éº¼ï¼Œé‚£éº¼ä»–å€‘å¯ä»¥æ›´æœ‰æ•ˆç‡çš„ç®¡ç†è¨˜æ†¶é«” å¦‚æœä¸è€ƒæ…®è¨˜æ†¶é«”ï¼Œè«‹ä½¿ç”¨é™£åˆ— å¦‚æœä½ æƒ³é™£åˆ—çš„å¤§å°å¯ä»¥è¢«å‹•æ…‹çš„æ”¹è®Šï¼Œé‚£éº¼å»è®€ C++ ä¸¦å­¸ç¿’å¦‚ä½•ä½¿ç”¨ container   malloc #include \u0026lt;stdlib.h\u0026gt;ptr = malloc( sizeof(int) * size);  malloc() åˆ†é… size bytes ä¸¦å›å‚³ä¸€å€‹æŒ‡å‘æ‰€åˆ†é…çš„è¨˜æ†¶é«”çš„æŒ‡æ¨™ è¨˜æ†¶é«”æ²’æœ‰åˆå§‹åŒ– è‹¥è¦åˆå§‹åŒ–ï¼Œè«‹ä½¿ç”¨ memset  #include \u0026lt;string.h\u0026gt;memset(ptr, 0, sizeof(int) * size); calloc #include \u0026lt;stdlib.h\u0026gt;ptr = calloc(size, sizeof(int));  åœ¨ç¾ä»£çš„ C ä¸­ï¼Œä½ æ‡‰è©²ä½¿ç”¨ calloc ç¬¬ä¸€å€‹åƒæ•¸ï¼šå¤šå°‘å€‹å€å¡Šä½ æƒ³å»åˆ†é…? ç¬¬äºŒå€‹åƒæ•¸ï¼šæ¯å€‹å€å¡Šçš„å¤§å°ã€‚ è¨˜æ†¶é«”è¢«åˆå§‹åŒ–æˆ 0  free  \n free(ptr)ï¼šé‡‹æ”¾ ptr æŒ‡å‘çš„è¨˜æ†¶é«”ç©ºé–“ï¼Œè©²è¨˜æ†¶é«”ç©ºé–“å¿…é ˆæ˜¯ç”±ä¹‹å‰ä½¿ç”¨ malloc()ã€calloc()ã€realloc() æ‰€å›å‚³çš„ã€‚ æ­¤å¤–ï¼Œè‹¥å·²ç¶“ free(ptr)ï¼Œå†æ¬¡ä½¿ç”¨æœƒç™¼ç”Ÿæœªå®šç¾©è¡Œç‚ºã€‚  Double Pointer  \n ä½¿ç”¨å ´æ™¯ï¼š  åœ¨å‡½å¼ä¸­åˆ†é…è¨˜æ†¶é«”  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void table(int32_t **pp, int32_t n){ *pp = (int32_t *)calloc(n * n, sizeof(int32_t)); for(int32_t i=1; i\u0026lt;=n; ++i){ for(int32_t j=1; j\u0026lt;=n; ++j){ *(*pp + (i-1) * n + (j-1)) = i * j; } } } int main(){ int32_t number = 0; scanf(\u0026#34;%d\u0026#34;, number); int32_t *ptr = NULL; table(\u0026amp;ptr, number); return 0; }  åˆ†é…ä¸€å€‹äºŒç¶­é™£åˆ—  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main() { size_t size_row = 0, size_column = 0; printf(\u0026#34;Please enter two integers for row and column: \u0026#34;); scanf( \u0026#34;%lu %lu\u0026#34;, \u0026amp;size_row, \u0026amp;size_column ); int32_t **ptr = NULL; ptr = (int32_t **)calloc( sizeof( int32_t * ), size_row ); for( size_t i = 0 ; i \u0026lt; size_row ; i++ ) { *( ptr + i ) = (int32_t *)calloc( sizeof( int32_t ), size_column ); for( size_t j = 0 ; j \u0026lt; size_column ; j++ ) { *( *( ptr + i ) + j ) = ( i + 1 ) * ( j + 1 ); } } for( size_t i = 0 ; i \u0026lt; size_row ; i++ ) { for( size_t j = 0 ; j \u0026lt; size_column; j++ ) { printf( \u0026#34;%4d \u0026#34;, *( *( ptr + i ) + j ) ); } printf( \u0026#34;\\n\u0026#34; ); } return 0; }    å°å·¥å…· cdecl  å®‰è£ï¼šsudo apt install cdecl ä½¿ç”¨ï¼šcdecl -\u0026gt; explain int ***a;  è³‡æºæŸ¥çœ‹  top / htop vmstat ( è¼ƒè¼•é‡åŒ– )  vmstat -n 1 ( -n 1 ç‚ºä¸€ç§’è¼¸å‡ºä¸€æ¬¡ )    ","date":"2020-12-23T19:38:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-08/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-08ï¼šPointer"},{"content":"ç¬¬ä¸€å€‹ Hugo Blog â€ƒç”±æ–¼ç§‰æŒè‘—ã€Œäººç”Ÿç¸½æŠ˜é¨°ã€çš„é“ç†ï¼Œæˆ‘ä¾†è½‰ç§» Blog äº†(èª¤///)ï¼Œå¥½å•¦ï¼Œå…¶å¯¦æ˜¯å–®ç´”å¸Œæœ›æœ‰å€‹ç©©å®šä¸”åˆèƒ½å…¨å¤©å€™ä¾›æ‡‰çš„ Blog è€Œå·²ï¼Œç”±æ–¼æˆ‘çš„éšŠå‹å…©äººåˆ†åˆ¥ä½¿ç”¨äº† Hexo åŠ Hugo ï¼Œå› æ­¤ä¸€é–‹å§‹è®“æˆ‘æœ‰é»é›£æŠ‰æ“‡ï¼Œä½†æœ€çµ‚æˆ‘é‚„æ˜¯é¸æ“‡äº† Hugo ã€‚\nâ€ƒè‡³æ–¼ç¬¬äºŒå€‹é¸æ“‡çš„é›£é—œå°±æ˜¯ä¸»é¡Œäº†ï¼ŒæŒ‘äº†å¥½ä¹…éƒ½æ²’çœ‹åˆ°é †çœ¼çš„ï¼Œå·®é»å°±è¦è½å³æ–‡å…ƒèªªçš„æ²’æœ‰å–œæ­¡çš„å°±è‡ªå·±å¯«å‘€(æ€•///)ï¼Œæœ€çµ‚é‚„æ˜¯æŒ‘åˆ°äº†ä¸€å€‹ç¨å¾®æ»¿æ„çš„ä¸»é¡Œ Stackã€‚\nâ€ƒè‡³æ–¼æ¶è¨­çš„éç¨‹åˆ°ç›®å‰ç‚ºæ­¢é‚„ç®—æ˜¯è »é †åˆ©çš„ï¼Œå¸Œæœ›ä¹‹å¾Œä¹Ÿä¸æœƒé‡åˆ°ä»€éº¼å¤§å‘ã€‚\n","date":"2020-12-18T01:16:06+08:00","permalink":"https://blog.smallten.tk/p/first-hugo-blog/","title":"First Hugo Blog"},{"content":"è“„æ°´æ± æŠ½æ¨£æ³• (Reservoir Sampling)  å¾ N å€‹æ¨£æœ¬ä¸­ï¼Œéš¨æ©ŸæŠ½å– K å€‹æ¨£æœ¬ï¼Œå…¶ä¸­ N éå¸¸å¤§(ä¸èƒ½å°‡æ‰€æœ‰æ•¸æ“šéƒ½æ”¾é€²è¨˜æ†¶é«”æˆ–æ˜¯ä¸€å€‹æœªçŸ¥æ•¸)ï¼Œè€Œæ¯å€‹è¢«æŠ½å‡ºä¾†çš„æ©Ÿç‡è¦ç›¸ç­‰ã€‚  å®šç† è©²ç®—æ³•ä¿è­‰æ¯å€‹å…ƒç´ ä»¥ \\( k \\over n \\) çš„æ©Ÿç‡è¢«é¸å…¥è“„æ°´æ± ä¸­ã€‚\nè­‰æ˜  ç¬¬ i å€‹å…ƒç´ é€²å…¥è“„æ°´æ± çš„æ©Ÿç‡ç‚º \\( k \\over i \\)ï¼Œè“„æ°´æ± å…§æ¯å€‹å…ƒç´ è¢«æ›¿æ›çš„æ©Ÿç‡ç‚º\\( 1 \\over k \\) å› æ­¤åœ¨ç¬¬ i è¼ªç¬¬ j å€‹å…ƒç´ è¢«æ›¿æ›çš„æ©Ÿç‡ç‚º \\( {k \\over i}\\times{1 \\over k} = {1 \\over i} \\)ï¼Œæ¥ä¸‹ä¾†ç”¨ M.I. (æ•¸å­¸æ­¸ç´æ³•)ä¾†è­‰æ˜ï¼Œç•¶ n æ¬¡å¾ªç’°çµæŸæ™‚æ¯å€‹å…ƒç´ é€²å…¥è“„æ°´æ± çš„æ©Ÿç‡ç‚º \\( k \\over n \\) å‡è¨­åœ¨ (i-1) æ¬¡è¿­ä»£å¾Œï¼Œä»»æ„ä¸€å€‹å…ƒç´ é€²å…¥ è“„æ°´æ± çš„æ¦‚ç‡ç‚º \\( k \\over i-1 \\)ã€‚ç”±ä¸Šé¢çš„çµè«–ï¼Œåœ¨ç¬¬ i æ¬¡è¿­ä»£æ™‚ï¼Œè©²å…ƒç´ è¢«æ›¿æ›çš„æ¦‚ç‡ç‚º \\( 1 \\over i \\)ï¼Œ é‚£éº¼å…¶ä¸è¢«æ›¿æ›çš„æ¦‚ç‡å‰‡ç‚º \\( 1 - {1 \\over i} = {i - 1 \\over i} \\) æ•…åœ¨ç¬¬ i æ¬¡è¿­ä»£å¾Œï¼Œè©²å…ƒç´ åœ¨è“„æ°´æ± å…§çš„æ¦‚ç‡ç‚º \\( {k \\over i-1} \\times {i-1 \\over i} = {k \\over i} \\)ï¼Œæ­¸ç´çµæŸã€‚ å› æ­¤ç•¶å¾ªç’°çµæŸæ™‚ï¼Œæ¯å€‹å…ƒç´ é€²å…¥è“„æ°´æ± çš„æ¦‚ç‡ç‚º \\( k \\over n \\)ï¼Œå‘½é¡Œå¾—è­‰ã€‚  ä¾‹é¡Œ  Leetcode 382.Linked List Random Node è§£æ³•ï¼š Cpp  class Solution { ListNode *p; public: Solution(ListNode* head) { p = head; } int getRandom() { int ans = p-\u0026gt;val; ListNode *t = p-\u0026gt;next; for(int i=2; t; ++i){ if(rand()%i == 0) ans = t-\u0026gt;val; t = t-\u0026gt;next; } return ans; } }; ","date":"2020-12-08T16:02:25+08:00","permalink":"https://blog.smallten.tk/p/algorithm-01/","title":"æ¼”ç®—æ³•-01ï¼šè“„æ°´æ± æŠ½æ¨£æ³•"},{"content":"Array  é™£åˆ—æ˜¯ä¸€ç¨®å¯ä»¥å„²å­˜å¤§é‡ç›¸åŒå‹åˆ¥è³‡æ–™çš„æ–¹æ³•ã€‚ é€£çºŒçš„è¨˜æ†¶é«”ä½ç½®ã€‚ æ°¸é å¾0é–‹å§‹  int32_t a[10] -\u0026gt; a[0] ~ a[9]   è¨ˆæ•¸è®Šæ•¸ i çš„å‹åˆ¥å¯ä»¥å®£å‘Šç‚º size_tï¼Œå®ƒæ˜¯ä¸€å€‹ç„¡è™Ÿçš„æ•´æ•¸å‹åˆ¥ã€‚ åˆå§‹åŒ–  int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0};   å­˜å–é™£åˆ—å…ƒç´ ä½¿ç”¨ variable[index] å°ˆæ¥­èªªæ˜ï¼šé›»è…¦å°‡æ‰¾åˆ°ç¬¬ä¸€å€‹å…ƒç´ çš„åœ°å€ï¼Œç„¶å¾Œæ ¹æ“šç´¢å¼•ç§»å‹•è¨˜æ†¶é«”ä½ç½®ä»¥è¨ªå•æ•¸æ“šã€‚ äº‹å¯¦ä¸Šä¸€ç¶­é™£åˆ—å¯ä»¥è™•ç†æ‰€æœ‰æƒ…æ³ï¼Œè‡³æ–¼å¤šç¶­é™£åˆ—åªæ˜¯çµ¦äººé¡æ–¹ä¾¿é–±è®€çš„ã€‚   define  æ˜¯é‡è™•ç†æŒ‡ä»¤ï¼Œä¸æ˜¯Cçš„è©(statement) æˆ‘å€‘å¯ä»¥ä½¿ç”¨ #define å»åšå·¨é›†(MACRO)  ç•¶é–‹ç™¼æ™‚MACROæœ‰äº›åƒfunctionï¼Œç„¶è€Œå°é›»è…¦è€Œè¨€ä»–å€‘æ˜¯ä¸åŒçš„ã€‚ ç•¶é‡åˆ°MACROï¼Œç·¨è­¯å™¨å°‡ç°¡å–®çš„ä¾å®šç¾©æ›¿æ›æ‰ç¨‹å¼ç¢¼ã€‚ å‡½å¼æ“æœ‰è‡ªå·±çš„æ¨™è¨˜ã€‚    åŸºæœ¬æ’åº æ°£æ³¡æ’åºæ³• for(int i = 0; i \u0026lt; n; ++i) { for(int j = i; j \u0026lt; n; ++j) { if(a[j] \u0026lt; a[i]) { a[i] = a[i] ^ a[j]; a[j] = a[i] ^ a[j]; a[i] = a[i] ^ a[j]; } } } qsort #include \u0026lt;stdlib.c\u0026gt;int cmp(const void *a, const void *b) { return (*(int*)a - *(int*)b); } qsort(a, n, sizeof(int), cmp); å‚³é™£åˆ—è‡³å‡½å¼ int f(int [][n], int); f(a, 10); int f(int a[][n], int size){ }  é™¤äº†ç¬¬ä¸€å€‹[]å¤–ï¼Œå‰©ä¸‹çš„éƒ½å¿…é ˆè¦çµ¦å¤§å°ã€‚(é›»è…¦æ‰èƒ½è¨ˆç®—åç§»é‡) ç‚ºç”šéº¼è¦çµ¦size? å› ç‚ºå‚³éå»çš„åªæ˜¯é™£åˆ—çš„è¨˜æ†¶é«”èµ·å§‹ä½ç½®è€Œå·²ã€‚ åœ¨å‡½å¼ä¸­ä¾ç„¶æœƒæ”¹åˆ°æœ¬èº«çš„å€¼ã€‚  const  constant read-only  å¯è®Šé•·åº¦é™£åˆ—  Variable Length Array é›–ç„¶æœ‰äº›ç·¨è­¯å™¨æ”¯æ´äº†ä»¥ä¸‹å¯«æ³•(C99ä¹‹å¾Œ)ï¼Œä½†æœ‰äº›ä¾ç„¶ä¸æ”¯æ´  int n = 5; int a[n] = {0};  ä½†ä½ æ‡‰è©²ä½¿ç”¨ malloc  æº–ç¢ºä¾†èªªï¼Œä½ æ‡‰è©²ä½¿ç”¨ callocï¼Œè€Œä¸æ˜¯ `mallocã€‚   æˆ‘çš„å»ºè­°ï¼šç•¶è€ƒè©¦çš„æ™‚å€™ä¸è¦ä½¿ç”¨é€™åŠŸèƒ½( a[n] )ï¼Œå› ç‚ºä½ ä¸çŸ¥é“ç·¨è­¯å™¨çš„ç‰ˆæœ¬ã€‚  ","date":"2020-12-07T19:38:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-07/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-07ï¼šArray"},{"content":"Makefile for ç¨‹è¨­ä¸€ CC = gcc CFLAGS = -Wall -Wextra -O2 -std=c11 LDFLAGS = -lm TARGETS = main01 main02 main01_OBJ = main01.o func01.o main02_OBJ = main02.o func02.o .PHONY = all clean all: $(TARGETS) .SECONDEXPANSION: $(TARGETS): $$($$@_OBJ) $(CC) $^ -o $@ $(LDFLAGS) %.o: $@.c clean: -$(RM) $(TARGETS) $(foreach targ,$(TARGETS),$(foreach obj, $($(targ)_OBJ), $(obj))) ","date":"2020-12-02T21:45:51+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-06/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-06ï¼šMakefile"},{"content":"Function å‡½å¼ double  double æ˜¯ä¸€ç¨®æµ®é»æ•¸å‹åˆ¥ï¼Œå°±åƒæ˜¯ float å°±å¦‚åŒå®ƒçš„åå­—ï¼Œå®ƒä½¿ç”¨çš„è¨˜æ†¶é«”å¤§å°ç‚º float çš„å…©å€ å»ºè­°: ç•¶ä½ éœ€è¦æµ®é»æ•¸çš„è©±ï¼Œä¸€å¾‹ä½¿ç”¨ double    åˆ°ç›®å‰ç‚ºæ­¢æˆ‘å€‘æœ€å¸¸ä½¿ç”¨åˆ°çš„å‡½å¼ç‚º printf æˆ‘å€‘ç¨±é€™äº›å‡½å¼ç‚º C standard functions (Cæ¨™æº–å‡½å¼) æ‰€æœ‰çš„å‡½å¼éƒ½è¢«å„²å­˜åœ¨librariesä¸­  å¦‚æœä½ æƒ³è¦è®€æ›¸ï¼Œä½ éœ€è¦çŸ¥é“æ›¸åœ¨å“ªï¼Œç„¶å¾Œå»åœ–æ›¸é¤¨å€Ÿæ›¸ å¦‚æœä½ æƒ³è¦ä½¿ç”¨å‡½å¼ï¼Œä½ éœ€è¦çŸ¥é“å‡½å¼åœ¨å“ªï¼Œç„¶å¾Œinclude libraryå»ä½¿ç”¨å‡½å¼ ä¾‹å¦‚: stdio.h \u0026lt;-\u0026gt; printf   ä½¿ç”¨ math.h æ™‚ï¼Œéœ€ä¸‹ç·¨è­¯åƒæ•¸ -lm    æ°¸ä¸é‡æ–°ç™¼æ˜è¼ªå­ åœ¨é–‹ç™¼å‰è«‹å…ˆæœå°‹   //åŸå‹å®£å‘Š Return-Value-Type Function-Name (parameter-Type-list); Return-Value-Type Function-Name (parameter-list){ Statements }  ä½¿ç”¨åŸå‹å®£å‘Šä¸¦å°‡è‡ªè¨‚å‡½å¼ç½®æ–¼main functionä¹‹å¾Œçš„å¥½è™•?  ä¸ç”¨ç®¡functionä¹‹é–“çš„å…ˆå¾Œé †åºã€‚     void  æ²’æœ‰å‹åˆ¥ åœ¨é€™è£¡ï¼Œä»£è¡¨ä¸éœ€è¦å›å‚³å€¼  æ¨™é ­æª” (Header Files)  ç”šéº¼æ˜¯header file?  æ˜¯ä¸€å€‹åŒ…å«å‡½å¼çš„åŸå‹å®£å‘Š(prototypes)å’Œå…¶ä»–å®šç¾©(definitions)çš„æª”æ¡ˆ   ç‚ºç”šéº¼æˆ‘å€‘éœ€è¦header file?  æŠ½è±¡å±¤ æœ‰æ™‚æˆ‘å€‘æƒ³ä¿è­·æˆ‘å€‘çš„å¯¦ä½œ(implementation)     #ifndef #define ... #endif  å¦‚åŒæˆ‘æ‰€èªªï¼Œè»Ÿé«”å·¥ç¨‹å¸«æ˜¯æ‡¶æƒ°çš„  #pragma once å¦‚ä½•ç·¨è­¯å¤šå€‹æª”æ¡ˆ #static gcc -c library.c -o library.o gcc main.c library.o -o main #dynamic gcc -shared test.o -o libtest.so gcc main.c -o main -L. -ltest #åŸ·è¡Œ LD_LIBRARY_PATH=. ./main Link  Static link: Static linking is the process of copying all library modules used in the program into the final executable image. Dynamic link: In dynamic linking the names of the external libraries (shared libraries) are placed in the final executable file while the actual linking takes place at run time when both executable file and libraries are placed in the memory. .a æ˜¯ä¸€å † .o åŒ…åœ¨ä¸€èµ·  Random #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; srand(time(0)); n = rand % 6 //n: 0 ~ 5  æœ‰å®‰å…¨è¦æ±‚æ™‚ï¼Œè«‹å‹¿ä½¿ç”¨ random()  Global, Static, Extern Variable global  è®Šæ•¸çš„ç”Ÿå‘½é€±æœŸç‚ºæ•´å€‹ç¨‹å¼ã€‚ ä¹Ÿå¯è¢«externæ‰€å­˜å–åˆ°ã€‚  static  è®Šæ•¸åªæœƒåœ¨ç¨‹å¼é–‹å§‹ä¹‹å‰åˆ†é…å’Œåˆå§‹åŒ–ä¸€æ¬¡ã€‚ åœ¨ç¨‹å¼çµ‚æ­¢ä¹‹å‰ï¼Œå„²å­˜ç©ºé–“éƒ½ä¸æœƒè¢«é‡‹æ”¾ã€‚ åŠ ä¸Š static å¾Œï¼Œ externä¾¿ç„¡æ³•å­˜å–äº†ã€‚  extern  ä½¿ç”¨å¤–éƒ¨çš„è®Šæ•¸ã€‚  éè¿´ Recursive  éè¿´å®šç¾©å¦‚ä¸‹  éè¿´: åƒè¦‹ã€Œéè¿´ã€ã€‚   ä»€éº¼?é€™å€‹å®šç¾©ä»€éº¼ä¹Ÿæ²’æœ‰èªªå•Š!å¥½å§ï¼Œæ”¹ä¸€ä¸‹:  éè¿´: å¦‚æœä½ é‚„æ˜¯æ²’æ˜ç™½éè¿´æ˜¯ä»€éº¼æ„æ€çš„è©±ï¼Œåƒè¦‹ã€Œéè¿´ã€ã€‚    Return-Value-Type Function-Name ( parameter-list ) { if ( Base case ) { Return pre-defined value. } else { Call itself with parameter modification. } }  æ‰€æœ‰èƒ½ä½¿ç”¨éè¿´è¡¨é”çš„æ•˜è¿°ï¼Œçš†èƒ½ä»¥è¿´åœˆçš„æ–¹å¼ç·¨å¯«ã€‚ To iterate is human, to recurse, divine. â€” L. Peter Deutsch éè¿´åªæ‡‰å¤©ä¸Šæœ‰ï¼Œäººé–“è©²ç•¶ç”¨è¿´åœˆ æˆ‘çš„è§€é»:  å¦‚æœä½ æ‰¾åˆ°é—œä¿‚å¼ï¼Œéè¿´æ˜¯ç°¡å–®çš„ã€‚ æ™‚å¸¸ç”¨åœ¨è™›æ“¬ç¢¼(pseudo-code)ä¸­ã€‚ æ€§èƒ½æ•ˆç‡å¯èƒ½æ¯”è¿­ä»£å·®ã€‚    ","date":"2020-11-21T21:48:47+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-05/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-05ï¼šFunction"},{"content":"Loop - `while` - `for` - `do while`  While Loop while(æ¢ä»¶){ åŸ·è¡Œå€å¡Š }  %.200f æœƒç™¼ç”Ÿä»€éº¼äº‹? -\u0026gt; ç²¾åº¦ä¸å¤ æ²’æœ‰æ„ç¾© while(1) -\u0026gt; ç„¡çª®è¿´åœˆ  For Loop for(åˆå§‹åŒ–; æ¢ä»¶; åŸ·è¡Œå¾Œæ“ä½œ){ åŸ·è¡Œå€å¡Š }  i++ -\u0026gt; Use the current value of i. -\u0026gt; i = i + 1 ++i -\u0026gt; i = i + 1 -\u0026gt; Use the new value of i. {} -\u0026gt; è®Šæ•¸ç”Ÿå‘½é€±æœŸç¯„åœ %4d ( %# ) -\u0026gt; çµ¦æœ€å°çš„ä½æ•¸å»é¡¯ç¤º åœ¨ ANSI C, è®Šæ•¸åªèƒ½è¢«å®£å‘Šåœ¨å‡½å¼çš„é–‹é ­ï¼Œè€Œ Modern C æ²’æœ‰ä»»ä½•é™åˆ¶  Do While Loop do{ åŸ·è¡Œå€å¡Š }while(æ¢ä»¶)  ä¸‰ç¨®ä¸åŒé¡å‹çš„è¿´åœˆæ¯«ç„¡ç–‘å•çš„éƒ½å¯ä»¥äº’ç›¸è½‰æ›  é™¤äº† do while è‡³å°‘æœƒåŸ·è¡Œä¸€æ¬¡   å¤§å¤šæ•¸ä¾†èªªï¼Œå¦‚æœä½ çŸ¥é“è¦åŸ·è¡Œå¹¾æ¬¡è¿´åœˆçš„è©±ï¼Œæœƒä½¿ç”¨ for breakï¼šé›¢é–‹ç•¶å‰çš„å€æ®µ continueï¼šè·³éå‰©é¤˜çš„æ•˜è¿°ï¼Œç›´æ¥åŸ·è¡Œä¸‹ä¸€æ¬¡è¿­ä»£ ç„¡çª®è¿´åœˆä¸æ˜¯å€‹å¥½æ±è¥¿? -\u0026gt; ä¸ï¼Œæˆ–è¨±ä½ æœƒéœ€è¦ä»–ï¼Œä¾‹å¦‚ï¼šWeb server   #include \u0026lt;unistd.h\u0026gt;sleep(sec); ","date":"2020-10-18T20:33:18+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-04/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-04ï¼šLoop"},{"content":"Condition Control ç°¡ä»‹  æˆ‘å€‘æƒ³è¦è®“é›»è…¦å»åšåŸºç¤çš„åˆ¤æ–·  if switch    If if (condition1) { statements; } else if (condition2){ ... } else { ... }  å¦‚æœæ¢ä»¶ä¸æ˜¯éŒ¯èª¤ï¼Œé‚£éº¼å°‡æœƒåŸ·è¡Œå¤§æ‹¬è™Ÿè£¡çš„æ•˜è¿°  ç°¡è€Œè¨€ä¹‹ï¼Œfalse è¢«å®šç¾©ç‚º 0   \u0026gt; -\u0026gt; å¤§æ–¼ \u0026lt; -\u0026gt; å°æ–¼ \u0026gt;= -\u0026gt; å¤§æ–¼ç­‰æ–¼ \u0026lt;= -\u0026gt; å°æ–¼ç­‰æ–¼ == -\u0026gt; ç­‰æ–¼ != -\u0026gt; ä¸ç­‰æ–¼ \u0026amp;\u0026amp; -\u0026gt; and || -\u0026gt; or  Boolean  åœ¨ Cpp è£¡ï¼Œæœ‰å€‹å‹åˆ¥ç¨±ç‚º bool  å®ƒåªæœ‰å…©å€‹å€¼ï¼štrue, false é‚£éº¼ bool ä½¿ç”¨çš„è¨˜æ†¶é«”å¤§å°ç‚ºä½•èƒ½?( 1 bit or 1 byte ??)   åœ¨ ANSI C è£¡ï¼Œæ²’æœ‰ä¸€å€‹å‹åˆ¥ç‚ºbooleançš„ å¾ C99 é–‹å§‹ï¼Œæœ‰ä¸€å€‹æ¨™é ­æª”å¯ä»¥ä½¿ç”¨ï¼Œstdbool.h  Switch  ä½ å¯ä»¥ä½¿ç”¨ if-else ä¾†åšæ¯å€‹æ¢ä»¶åˆ¤æ–·ï¼Œä½†æ˜¯æœ‰æ™‚å€™å¯èƒ½æœƒå¯«ä¸€å€‹å·¨å¤§çš„å·¢ç‹€ç¨‹å¼ï¼Œå› æ­¤å°‡ä»‹ç´¹å¦ä¸€å€‹æ–¹æ³• switch  switch (){ case 1: ... break; ... default: ... }  breakï¼šå¾æ­¤è™•çµæŸ  é‚£éº¼å¦‚æœä¸ä½¿ç”¨ break å‘¢??   defaultï¼šå¦‚æœæ²’æœ‰ case ç¬¦åˆï¼ŒåŸ·è¡Œé€™æ®µ  æµ®é»æ•¸æ¯”è¼ƒ #include \u0026lt;stdio.h\u0026gt;int main() { float a = 0.3; if (a == 0.3) printf(\u0026#34;if01\\n\u0026#34;); else printf(\u0026#34;else01\\n\u0026#34;); if (a == 0.3f) printf(\u0026#34;if02\\n\u0026#34;); else printf(\u0026#34;else02\\n\u0026#34;); return 0; }  çµæœï¼š else01 if02 è«‹ä½¿ç”¨ sizeof() æŸ¥çœ‹ç™¼ç”Ÿäº†ä»€éº¼!(IEEE 754) çµè«–ï¼šæµ®é»æ•¸çš„æ¯”è¼ƒæ˜¯ç›¸ç•¶å±éšªçš„!!  ","date":"2020-10-15T20:53:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-03/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-03ï¼šCondition Control"},{"content":"Arithmetic #include \u0026lt;stdio.h\u0026gt;int main(){ int a = 1, b = 2, sum = 0; sum = a + b; printf(\u0026#34;%d\u0026#34;, sum); return 0; }  è®Šæ•¸  æ¯å€‹è®Šæ•¸éƒ½å¿…é ˆæœ‰å®ƒçš„å‹åˆ¥ åœ¨ä½¿ç”¨è®Šæ•¸å‰å¿…é ˆå…ˆå®£å‘Šå®ƒ   åœ¨Cè£¡é¢ï¼Œ = æ„æ€ç‚ºâ€æŒ‡å®šâ€ï¼Œè€Œä¸æ˜¯â€ç›¸ç­‰â€ï¼ŒæŒ‡æ´¾å³é‚Šçš„æ•¸å€¼çµ¦å·¦é‚Šçš„è®Šæ•¸ ä¸€å€‹å¥½ç¿’æ…£ï¼Œç¸½æ˜¯åˆå§‹åŒ–è®Šæ•¸ C Spec:  C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero.      In C99: a == (a / b) * b + a % b printf æ˜¯ä¸€å€‹å‡½å¼å»å°å‡ºæ ¼å¼åŒ–å­—ä¸²  %d -\u0026gt; æœ‰è™Ÿåé€²ä½æ•´æ•¸ %f -\u0026gt; åé€²ä½æµ®é»æ•¸ %u -\u0026gt; ç„¡è™Ÿåé€²ä½æ•´æ•¸ ç•¶ç„¶ä¸åªé€™äº›   å°æŠ€å·§  a += b -\u0026gt; a = a + b a -= b -\u0026gt; a = a - b a *= b -\u0026gt; a = a * b a /= b -\u0026gt; a = a / b a %= b -\u0026gt; a = a % b   æŸ¥çœ‹è¨˜æ†¶é«”ä½¿ç”¨å¤§å°ï¼š sizeof()ï¼Œå›å‚³å–®ä½ç‚º byte ( printf(\u0026quot;%lu\u0026quot;, sizeof()); ) #include \u0026lt;stdint.h\u0026gt;  int8_t: 8-bit signed interger int16_t: 16-bit signed interger int32_t: 32-bit signed interger int64_t: 64-bit signed interger uint8_t: 8-bit unsigned interger uint16_t: 16-bit unsigned interger uint32_t: 32-bit unsigned interger uint64_t: 64-bit unsigned interger      è¼¸å…¥ï¼šscanf(\u0026quot;%d\u0026quot;, \u0026amp;a);  è‡³æ–¼ç‚ºç”šéº¼éœ€è¦ \u0026amp;ï¼Œä¹‹å¾Œæœƒåœ¨æŒ‡æ¨™çš„ç« ç¯€ä»‹ç´¹åˆ° scanf æ˜¯å¦æœ‰å›å‚³å€¼? ( man 3 scanf )      æœ€å¾Œä¹Ÿæœ€é‡è¦çš„æŠ€èƒ½ï¼šRTFM and STFG  ","date":"2020-10-15T11:19:09+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-02/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-02ï¼šArithmetic"},{"content":"ç°¡ä»‹ â€ƒé€™ç¯‡å°‡å¸¶ä½ ä¸‹è¼‰m3u8æª”ä¸¦åˆ†æå‡ºtsçš„æª”æ¡ˆï¼Œå†é€éå¤šç·šç¨‹ä¾†åŠ é€Ÿä¸‹è¼‰ï¼Œä¹‹å¾Œå†ç”±FFmpegåˆä½µæˆmp4ã€‚\nPython ä¸‹è¼‰m3u8 m3u8Url = \u0026#39;https://.../index.m3u8\u0026#39; def downloadM3u8(url): r = requests.get(url) with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) åˆ†æm3u8  é€™éƒ¨ä»½è«‹ä¾ç…§ä½ æ‰€å–å¾—çš„m3u8æª”é€²è¡Œåˆ†æï¼Œä¸¦å°‡å®Œæ•´çš„tsæª”çš„urlæ”¾é€²tsListå³å¯ã€‚  tsList = [] tsCnt = 0 def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;r\u0026#39;) as f: text = f.read() textList = text.split(\u0026#39;\\n\u0026#39;) while textList[-1] != \u0026#39;#EXT-X-ENDLIST\u0026#39;: textList.pop(-1) for i in textList: if i[0] != \u0026#39;#\u0026#39;: tsList.append(tempUrl + i) global tsCnt tsCnt = len(tsList) ä¸‹è¼‰tsæª” q = queue.Queue() def downloadts(): global tsList while q.qsize() \u0026gt; 0: num = q.get() r = requests.get(tsList[num]) with open(\u0026#39;./ts/\u0026#39; + str(num+1) + \u0026#39;.ts\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) if __name__ == \u0026#34;__main__\u0026#34;: if not os.path.isdir(\u0026#39;./ts/\u0026#39;): os.mkdir(\u0026#39;./ts/\u0026#39;) for i in range(tsCnt): q.put(i) thList = [] for i in range(tsCnt): th = threading.Thread(target=downloadts) th.start() thList.append(th) for th in thList: th.join() print(\u0026#39;ä¸‹è¼‰tså®Œæˆ\u0026#39;) åˆä½µtsæˆmp4 def merge(tsCnt, output): for i in range(tsCnt): with open(\u0026#39;./ts/ts.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;file \u0026#39; + str(i+1) + \u0026#39;.ts\\n\u0026#39;) command = \u0026#39;ffmpeg -y -f concat -i %s-bsf:a aac_adtstoasc -c copy %s\u0026#39; % (\u0026#39;./ts/ts.txt\u0026#39;, output) os.system(command) print(\u0026#39;åˆä½µæˆåŠŸ\u0026#39;) ç§»é™¤ç„¡ç”¨æª”æ¡ˆ def remove(): shutil.rmtree(\u0026#39;./ts/\u0026#39;) os.remove(\u0026#39;./index.m3u8\u0026#39;)  å®Œæ•´ç¨‹å¼ç¢¼ # -*- coding: UTF-8 -*- import requests, os, threading, queue, shutil m3u8Url = \u0026#39;https://.../index.m3u8\u0026#39; tsList = [] tsCnt = 0 q = queue.Queue() def downloadM3u8(url): r = requests.get(url) with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;r\u0026#39;) as f: text = f.read() textList = text.split(\u0026#39;\\n\u0026#39;) while textList[-1] != \u0026#39;#EXT-X-ENDLIST\u0026#39;: textList.pop(-1) for i in textList: if i[0] != \u0026#39;#\u0026#39;: tsList.append(tempUrl + i) global tsCnt tsCnt = len(tsList) def downloadts(): global tsList while q.qsize() \u0026gt; 0: num = q.get() r = requests.get(tsList[num]) with open(\u0026#39;./ts/\u0026#39; + str(num+1) + \u0026#39;.ts\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) def merge(tsCnt, output): for i in range(tsCnt): with open(\u0026#39;./ts/ts.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;file \u0026#39; + str(i+1) + \u0026#39;.ts\\n\u0026#39;) command = \u0026#39;ffmpeg -y -f concat -i %s-bsf:a aac_adtstoasc -c copy %s\u0026#39; % (\u0026#39;./ts/ts.txt\u0026#39;, output) os.system(command) print(\u0026#39;åˆä½µæˆåŠŸ\u0026#39;) def remove(): shutil.rmtree(\u0026#39;./ts/\u0026#39;) os.remove(\u0026#39;./index.m3u8\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: downloadM3u8(m3u8Url) analyzeM3u8() print(\u0026#39;m3u8ä¸‹è¼‰ä¸”åˆ†æå®Œç•¢\u0026#39;) if not os.path.isdir(\u0026#39;./ts/\u0026#39;): os.mkdir(\u0026#39;./ts/\u0026#39;) for i in range(tsCnt): q.put(i) thList = [] for i in range(tsCnt): th = threading.Thread(target=downloadts) th.start() thList.append(th) for th in thList: th.join() print(\u0026#39;ä¸‹è¼‰tså®Œæˆ\u0026#39;) merge(tsCnt, \u0026#39;./test.mp4\u0026#39;) remove() ","date":"2020-10-04T16:36:35+08:00","permalink":"https://blog.smallten.tk/p/python-04/","title":"Python-04ï¼šå¤šç·šç¨‹-tsä¸‹è¼‰ä¸¦åˆä½µæˆmp4"},{"content":"ç°¡ä»‹  ç¾ä»Šä½ æ™‚å¸¸èƒ½åœ¨å½±éŸ³åª’é«”ç¶²ç«™çœ‹åˆ° .m3u8 çš„æª”æ¡ˆï¼Œä»¥åŠè¨±å¤š .ts çš„åˆ†æ®µåª’é«”ï¼Œæœ¬ç¯‡å°‡æ•™ä½ å¦‚ä½•ç°¡å–®çš„ä¸‹è¼‰æˆ .mp4 æª”ã€‚ é€™ç¯‡ä¸¦ä¸è©³åŠ æ•˜è¿° HLS ä¹‹é¡çš„è§€å¿µï¼Œè‹¥æœ‰èˆˆè¶£æ·±å…¥äº†è§£è«‹è‡ªè¡ŒæŸ¥æ‰¾è³‡æ–™ã€‚  FFmpeg  FFmpegå®˜ç¶² ä¸‹è¼‰å®‰è£å®Œå¾Œï¼Œè‹¥ç‚º windows ç”¨æˆ¶è«‹å°‡ %ffmpeg%\\bin çš„è·¯å¾‘åŠ å…¥ç’°å¢ƒè®Šæ•¸ä¸­ï¼Œä¸¦æ–¼terminalä¸­åŸ·è¡Œ ffmpeg -version ä¾†æŸ¥çœ‹æ˜¯å¦æˆåŠŸåŠ å…¥ã€‚ ä¸‹è¼‰æª”æ¡ˆï¼Œç›´æ¥åœ¨ terminal è¼¸å…¥ ffmpeg -i m3u8URL -c copy filname.mp4ï¼Œå³å¯å®Œæˆä¸‹è¼‰ã€‚(ä¸‹é¢å°‡æä¾›Pythonçš„å¯«æ³•)  Python # -*- coding: UTF-8 -*- import ffmpeg_streaming from ffmpeg_streaming import Formats url = \u0026#39;https://.../index.m3u8\u0026#39; filename = \u0026#39;test.mp4\u0026#39; def ffmpeg_download(input_path, output_path): video = ffmpeg_streaming.input(input_path) stream = video.stream2file(Formats.h264()) stream.output(output_path) if __name__ == \u0026#34;__main__\u0026#34;: ffmpeg_download(url, \u0026#39;./\u0026#39; + filename)  ä¸‹ä¸€ç¯‡å°‡æ•™ä½ å¦‚ä½•ç›´æ¥å¾ m3u8 è£¡è®€å–ç›®éŒ„ï¼Œä¸¦ä½¿ç”¨å¤šç·šç¨‹ä¸‹è¼‰ ts ä¸¦åˆä½µæˆ mp4  ","date":"2020-10-04T11:07:24+08:00","permalink":"https://blog.smallten.tk/p/python-03/","title":"Python-03ï¼šm3u8å½±ç‰‡ä¸‹è¼‰"},{"content":"Hello World #include \u0026lt;stdio.h\u0026gt;//Your first code. int main(){ printf(\u0026#34;Hello World\\n\u0026#34;); return 0; }  mainæ˜¯æ¯å€‹Cç¨‹å¼çš„é€²å…¥é»ï¼Œæˆ‘å€‘ç¨±å®ƒç‚ºmain function(ä¸»å‡½å¼) int åŠ return æ˜¯Cè£¡é¢çš„Keywords  intä»£è¡¨é€™å€‹å‡½å¼å°‡æœƒå›å‚³ä¸€å€‹æ•´æ•¸ æ¯å€‹å‡½å¼éƒ½æ‡‰è©²æœ‰ä¸€å€‹å›å‚³å€¼   æ¯å€‹æ•˜è¿°çš„çµå°¾éƒ½æ‡‰è©²è¦æœ‰ ; printf æ˜¯ä¸€å€‹æœƒé¡¯ç¤ºæ ¼å¼åŒ–å­—ä¸²çš„å‡½å¼ \\n -\u0026gt; æ›è¡Œ \\t -\u0026gt; tab \\\\ -\u0026gt; \\ \\\u0026quot; -\u0026gt; â€œ # çš„é‚£ä¸€è¡Œæ˜¯Cçš„é è™•ç†å™¨ä¸¦ä¸”ä¸éœ€è¦;çµå°¾ stdio.h -\u0026gt; standard input / output header(æ¨™æº–è¼¸å‡º/è¼¸å…¥æ¨™é ­æª”) è¨»è§£ -\u0026gt; æ˜¯çµ¦é–‹ç™¼è€…çœ‹çš„  //Your code -\u0026gt; å–®è¡Œ /*Your code*/ -\u0026gt; å¤šè¡Œ      ä½¿ç”¨ç·¨è­¯å™¨å°‡ç¨‹å¼ç¢¼ç·¨è­¯æˆçµ„åˆèªè¨€ï¼Œå†ç”±çµ„è­¯å™¨çµ„è­°æˆæ©Ÿæ¢°ç¢¼æˆ–å¯åŸ·è¡Œçš„äºŒé€²åˆ¶æª” IDE -\u0026gt; Integrated Development Environmentï¼Œä¸æ˜¯ç·¨è­¯å™¨ gccæ˜¯æœ€å—æ­¡è¿çš„Cç·¨è­¯å™¨ä¹‹ä¸€(ä¸å®Œå…¨å°!!å› ç‚ºå®ƒä¸åªåšäº†ç·¨è­¯çš„å‹•ä½œâ€¦) ä¸€äº›åŸºæœ¬çš„Linuxçš„æ“ä½œæŒ‡ä»¤  man -\u0026gt; ä¸æœƒå°±å•é‚£å€‹ç”·äººå§ï¼Œç”·äººä¸æœƒå°±Google ls cd rm pwd   gcc main.c ä¸€äº›åƒæ•¸  -o -v -g -Wall -Wextra -O2 or -Og    Makefile all: gcc main.c -o main clean: rm -rf main  make å°‡åŸ·è¡Œallä¸‹çš„æŒ‡ä»¤ ä¸­é–“ç¸®æ’æ‡‰ç‚ºTabè€Œä¸æ˜¯Space make clean é è¨­å¯åŸ·è¡Œçš„æª”åç‚º makefileï¼ŒMakefileï¼ŒGNUmakefileï¼Œè‹¥ç‚ºå…¶ä»–å¯ä¸‹ -f çš„åƒæ•¸  ","date":"2020-10-04T11:00:48+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-01/","title":"ç¨‹å¼è¨­è¨ˆ(ä¸€)-01ï¼šYour first program"},{"content":"ç°¡ä»‹  æ¥çºŒä¸Šä¸€ç¯‡Python-01ï¼šçˆ¬èŸ²-åœ–ç‰‡ä¸‹è¼‰çš„å…§å®¹ï¼Œé€™ç¯‡æ–‡ç« å°‡å¸¶é ˜å¤§å®¶ä½¿ç”¨å¤šç·šç¨‹ä¾†åŠ é€Ÿåœ–ç‰‡çš„ä¸‹è¼‰  æ•™å­¸é–‹å§‹  é¦–å…ˆæˆ‘å€‘å…ˆçœ‹å€‹ç°¡å–®çš„å¤šç·šç¨‹ç¯„ä¾‹  import time, threading # å­åŸ·è¡Œç·’çš„å·¥ä½œå‡½æ•¸ def job(): for i in range(5): print(\u0026#34;Child thread:\u0026#34;, i) time.sleep(1) # å»ºç«‹ä¸€å€‹å­åŸ·è¡Œç·’ t = threading.Thread(target = job) # åŸ·è¡Œè©²å­åŸ·è¡Œç·’ t.start() # ä¸»åŸ·è¡Œç·’ç¹¼çºŒåŸ·è¡Œè‡ªå·±çš„å·¥ä½œ for i in range(3): print(\u0026#34;Main thread:\u0026#34;, i) time.sleep(1) # ç­‰å¾… t é€™å€‹å­åŸ·è¡Œç·’çµæŸ t.join() print(\u0026#34;Done.\u0026#34;) import time, threading # å­åŸ·è¡Œç·’çš„å·¥ä½œå‡½æ•¸ def job(num): print(\u0026#34;Thread\u0026#34;, num) time.sleep(1) # å»ºç«‹ 5 å€‹å­åŸ·è¡Œç·’ threads = [] for i in range(5): threads.append(threading.Thread(target = job, args = (i,))) threads[i].start() # ä¸»åŸ·è¡Œç·’ç¹¼çºŒåŸ·è¡Œè‡ªå·±çš„å·¥ä½œ # ç­‰å¾…æ‰€æœ‰å­åŸ·è¡Œç·’çµæŸ for i in range(5): threads[i].join() print(\u0026#34;Done.\u0026#34;)  æ¥ä¸‹ä¾†æˆ‘å€‘ä¿®æ”¹Python-01ï¼šçˆ¬èŸ²-åœ–ç‰‡ä¸‹è¼‰ä¸­ä¸‹è¼‰åœ–ç‰‡é‚£éƒ¨åˆ†çš„ç¨‹å¼ç¢¼  th_list = [] for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; th = threading.Thread(target=download_img, args=(img, i)) th.start() th_list.append(th) for th in th_list: th.join() å®Œæ•´ç¨‹å¼ç¢¼ # -*- coding: UTF-8 -*- from selenium import webdriver from bs4 import BeautifulSoup import requests, threading def download_img(img, num): r = requests.get(img) with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) if __name__ == \u0026#34;__main__\u0026#34;: save_url = \u0026#39;./test/\u0026#39; url = \u0026#39;https://www.ohmanhua.com/13621/1/1.html\u0026#39; chop = webdriver.ChromeOptions() chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) soup = BeautifulSoup(browser.page_source, \u0026#39;lxml\u0026#39;) img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) if img_url[0] == \u0026#39;/\u0026#39;: img_url = \u0026#39;https:\u0026#39; + img_url m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; th_list = [] for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; th = threading.Thread(target=download_img, args=(img, i)) th.start() th_list.append(th) for th in th_list: th.join() browser.quit() ","date":"2020-08-03T00:56:43+08:00","permalink":"https://blog.smallten.tk/p/python-02/","title":"Python-02ï¼šå¤šç·šç¨‹-åŠ é€Ÿåœ–ç‰‡ä¸‹è¼‰"},{"content":"ç°¡ä»‹  é€™ä¸€ç¯‡å°‡å¸¶é ˜å¤§å®¶é€éPythonçš„çˆ¬èŸ²è‡ªå‹•åŒ–çš„ä¸‹è¼‰åœ–ç‰‡  å®‰è£  æ‰“é–‹çµ‚ç«¯æ©Ÿï¼Œå®‰è£ä¸‹åˆ—å¥—ä»¶  pip install requests pip install BeautifulSoup4 pip install lxml pip install selenium   è‡³ Chrome Driver ä¸‹è¼‰ç•¶å‰é›»è…¦ä¸­Chromeæ‰€å°æ‡‰ç‰ˆæœ¬çš„Driver  æ•™å­¸é–‹å§‹  é¦–å…ˆå› ç‚ºé€™æ¬¡çš„ä¸»é¡Œç‚ºåœ–ç‰‡ä¸‹è¼‰ï¼Œå› æ­¤æˆ‘å€‘æ‰¾äº†ä¸€å€‹æ“æœ‰å¤§é‡åœ–ç‰‡çš„æ¼«ç•«ç¶²é ä¾†é€²è¡Œæ•™å­¸ã€‚ ç”±æ–¼é€™å€‹ç¶²é çš„åœ–ç‰‡æ˜¯ç”±JavaScriptåŠ è¼‰çš„ï¼Œå› æ­¤ä¸€é–‹å§‹æˆ‘å€‘ä½¿ç”¨Seleniumä¾†é–‹å•Ÿç¶²é  from selenium import webdriver url = \u0026#39;https://www.ohmanhua.com/13621/1/1.html\u0026#39; #ä½¿ç”¨crxæ’ä»¶ chop = webdriver.ChromeOptions() chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url)  ç•¶ç„¶è‹¥ä¸æƒ³é¡¯ç¤ºç€è¦½å™¨çš„è¦–çª—å¯ä»¥ä½¿ç”¨headlessæ¨¡å¼  chop.add_argument(\u0026#39;--headless\u0026#39;) #è¦é¿google bug chop.add_argument(\u0026#39;--disable-gpu\u0026#39;)  æ¥ä¸‹ä¾†ä½¿ç”¨BeautifulSoup4ä¾†åˆ†æé é¢ï¼Œä¸¦å–å¾—åœ–ç‰‡ç¶²å€ï¼Œå’Œå…±å¹¾å¼µåœ–ç‰‡  img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) if img_url[0] == \u0026#39;/\u0026#39;: img_url = \u0026#39;https:\u0026#39; + img_url m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39;  æœ€å¾Œä¾¿æ˜¯ä¸‹è¼‰åœ–ç‰‡å’Œé—œé–‰ç€è¦½å™¨  def download_img(img, num): r = requests.get(img) with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; download_img(img, i) browser.quit() å®Œæ•´ç¨‹å¼ç¢¼ # -*- coding: UTF-8 -*- from selenium import webdriver from bs4 import BeautifulSoup import requests def download_img(img, num): r = requests.get(img) with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) if __name__ == \u0026#34;__main__\u0026#34;: save_url = \u0026#39;./download/\u0026#39; url = \u0026#39;\u0026#39; chop = webdriver.ChromeOptions() chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) soup = BeautifulSoup(browser.page_source, \u0026#39;lxml\u0026#39;) img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) if img_url[0] == \u0026#39;/\u0026#39;: img_url = \u0026#39;https:\u0026#39; + img_url m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; download_img(img, i) browser.quit() ","date":"2020-08-03T00:39:24+08:00","permalink":"https://blog.smallten.tk/p/python-01/","title":"Python-01ï¼šçˆ¬èŸ²-åœ–ç‰‡ä¸‹è¼‰"},{"content":"ç°¡ä»‹  é€™ç³»åˆ—ä¸»é¡Œå°‡å¸¶é ˜å¤§å®¶å»ºç«‹ä¸€å€‹ç°¡æ˜“çš„æ°£è±¡è§€æ¸¬ç«™ï¼Œè€Œé€™ä¸€å°ç¯€å°‡è£½ä½œåœ¨Raspberry piç”¨Pythonè®€å–Arduino Serialçš„æ•¸å€¼ï¼Œä¸¦ä¸”è£½ä½œä¸€å€‹ç°¡æ˜“çš„UIå¯¦æ™‚é¡¯ç¤ºå‡ºæ•¸å€¼ã€‚  ç¡¬é«”  ä¸Šä¸€å°ç¯€çš„æˆå“ Raspberry pi * 1  æ•™å­¸é–‹å§‹  æ‰“é–‹Raspberry piçš„Terminalï¼Œä¸¦è¼¸å…¥ ls /dev/tty* å°‡Arduinoçš„Usbæ¥ä¸ŠRaspberry pi å†æ¬¡æ–¼Terminalä¸­è¼¸å…¥ ls /dev/tty*ï¼Œæ¯”è¼ƒå…©æ¬¡çš„å·®ç•°ï¼Œå³å¯çŸ¥Arduinoä½¿ç”¨çš„åºåˆ—åŸ ç‚ºä½•(ä¾‹å¦‚æ­¤æ™‚ç‚º/ dev/ttyACM0ï¼Œè«‹ä¾ç…§æƒ…æ³è‡ªè¡Œä¿®æ”¹) æ–¼Terminalä¸­è¼¸å…¥ python3 -m pip install pyserial å°‡ä»¥ä¸‹ç¨‹å¼ç¢¼å»ºç«‹æˆä¸€å€‹pythonæª”ï¼Œå†ä»¥python3åŸ·è¡Œå³å¯  # -*- coding: UTF-8 -*- import serial import tkinter as tk def getData(): ser = serial.Serial(\u0026#39;/dev/ttyACM0\u0026#39;, 9600, timeout=1) ser.flush() while True: flag = False if ser.in_waiting\u0026gt;0: arduinoData = ser.readline().decode(encoding=\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;).rstrip().split(\u0026#39;;\u0026#39;) if len(arduinoData)!=4 or arduinoData==\u0026#39;\u0026#39;: continue for i in range(0,3): if arduinoData[i]==\u0026#39;0\u0026#39;: flag = True break if flag: continue else: temperature_value[\u0026#39;text\u0026#39;] = arduinoData[0] + \u0026#39; åº¦C\u0026#39; humidity_value[\u0026#39;text\u0026#39;] = arduinoData[1] + \u0026#39; %\u0026#39; pmat25_value[\u0026#39;text\u0026#39;] = arduinoData[2] + \u0026#39; ug/m^3\u0026#39; wind_value[\u0026#39;text\u0026#39;] = arduinoData[3] + \u0026#39; ç´š\u0026#39; break window.after(1000, getData) if __name__==\u0026#39;__main__\u0026#39;: window = tk.Tk() window.title(\u0026#39;Weather\u0026#39;) window.geometry(\u0026#39;500x250\u0026#39;) window.resizable(False, False) header_label = tk.Label(window, text=\u0026#39;ç’°å¢ƒç›£æ¸¬\u0026#39;, font=(\u0026#39;Arial\u0026#39;, 20), width=30, height=2, borderwidth=2, relief=\u0026#39;solid\u0026#39;) header_label.pack(side=tk.TOP) temperature_frame = tk.Frame(window) temperature_frame.pack(side=tk.TOP) temperature_label = tk.Label(temperature_frame, text=\u0026#39;æº«åº¦: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) temperature_label.pack(side=tk.LEFT) temperature_value = tk.Label(temperature_frame, font=(\u0026#39;Arial\u0026#39;, 16)) temperature_value.pack(side=tk.LEFT) humidity_frame = tk.Frame(window) humidity_frame.pack(side=tk.TOP) humidity_label = tk.Label(humidity_frame, text=\u0026#39;æ¿•åº¦: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) humidity_label.pack(side=tk.LEFT) humidity_value = tk.Label(humidity_frame, font=(\u0026#39;Arial\u0026#39;, 16)) humidity_value.pack(side=tk.LEFT) pmat25_frame = tk.Frame(window) pmat25_frame.pack(side=tk.TOP) pmat25_label = tk.Label(pmat25_frame, text=\u0026#39;PM2.5: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) pmat25_label.pack(side=tk.LEFT) pmat25_value = tk.Label(pmat25_frame, font=(\u0026#39;Arial\u0026#39;, 16)) pmat25_value.pack(side=tk.LEFT) wind_frame = tk.Frame(window) wind_frame.pack(side=tk.TOP) wind_label = tk.Label(wind_frame, text=\u0026#39;é¢¨é€Ÿ: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) wind_label.pack(side=tk.LEFT) wind_value = tk.Label(wind_frame, font=(\u0026#39;Arial\u0026#39;, 16)) wind_value.pack(side=tk.LEFT) getData() window.mainloop()  æœ€çµ‚æˆæœåœ–    ","date":"2020-07-12T09:31:38+08:00","permalink":"https://blog.smallten.tk/p/weather-02/","title":"ç°¡æ˜“æ°£è±¡ç«™-02"},{"content":"ç°¡ä»‹  é€™ç³»åˆ—ä¸»é¡Œå°‡å¸¶é ˜å¤§å®¶å»ºç«‹ä¸€å€‹ç°¡æ˜“çš„æ°£è±¡è§€æ¸¬ç«™ï¼Œè€Œé€™ä¸€å°ç¯€å°‡è£½ä½œç”±ArduinoæŠ“å–æ„Ÿæ¸¬å™¨æ•¸å€¼çš„éƒ¨åˆ†ã€‚  ç¡¬é«”  Arduino Uno R3 * 1 æ”€è—¤ G5 PMS5003 * 1 DFrobot ä¸‰æ¯å¼é¢¨é€Ÿæ„Ÿæ¸¬å™¨ * 1  æ•™å­¸é–‹å§‹ é€£çµé›»è·¯  \nUnoç¨‹å¼ç¢¼ #include \u0026lt;SoftwareSerial.h\u0026gt;#define windPin A0 SoftwareSerial pmsSerial(2, 3); long pmValue=0; long pmcf25=0; long pmat25=0; unsigned int temperature = 0; unsigned int humandity = 0; void retrievepm25(){ int count = 0; unsigned char c; unsigned char high; while (pmsSerial.available()) { c = pmsSerial.read(); if((count==0 \u0026amp;\u0026amp; c!=0x42) || (count==1 \u0026amp;\u0026amp; c!=0x4d)) break; if(count \u0026gt; 27) break; else if(count == 4 || count == 6 || count == 8 || count == 10 || count == 12 || count == 14 || count == 24 || count == 26) high = c; else if(count == 7){ pmcf25 = 256*high + c; pmValue = pmcf25; } else if(count == 13){ pmat25 = 256*high + c; pmValue = pmat25; } else if(count == 25) temperature = (256*high + c)/10; else if(count == 27) humandity = (256*high + c)/10; count++; } while(pmsSerial.available()) pmsSerial.read(); } void setup() { Serial.begin(9600); pmsSerial.begin(9600); } void loop() { retrievepm25(); Serial.print(temperature); Serial.print(\u0026#34;;\u0026#34;); Serial.print(humandity); Serial.print(\u0026#34;;\u0026#34;); Serial.print(pmat25); int windValue = analogRead(windPin); int Level = 6 * windValue * (5.0 / 1023.0); Serial.print(\u0026#34;;\u0026#34;); Serial.print(Level); Serial.println(); delay(1000); } ","date":"2020-07-12T09:02:34+08:00","permalink":"https://blog.smallten.tk/p/weather-01/","title":"ç°¡æ˜“æ°£è±¡ç«™-01"},{"content":"ç°¡ä»‹  é€™ç¯‡å…§å®¹å°‡æ•™å¤§å®¶é€éArduinoçš„åºåˆ—åŸ è¨­å®šHC-05çš„ATå‘½ä»¤  ç¡¬é«”  Arduino Uno * 1 HC-05è—èŠ½æ¨¡çµ„ * 1  æ•™å­¸ è…³ä½é€£æ¥    Arduino HC-05     5V VCC   GND GND   8 TX   9 RX    ç¨‹å¼ç¢¼ #include \u0026lt;SoftwareSerial.h\u0026gt; SoftwareSerial BT(8, 9); char val; void setup() { Serial.begin(9600); BT.begin(38400); } void loop() { if(Serial.available()){ val = Serial.read(); BT.print(val); } if(BT.available()){ val = BT.read(); Serial.print(val); } }  é€£æ¥è…³ä½ï¼Œä¸¦ä¸Šå‚³ç¨‹å¼ç¢¼ï¼Œæœ€å¾Œçµ¦HC-05ä¾›é›»å‰ï¼Œå…ˆæŒ‰ä½ä¸Šé¢çš„æŒ‰éˆ•ï¼Œå†æä¾›é›»æºï¼Œç‡ˆè™Ÿå°‡è®Šæˆç´„å…©ç§’ä¸€é–ƒï¼ŒåŠè¡¨ç¤ºé€²å…¥äº†ATå‘½ä»¤æ¨¡å¼ æ¥ä¸‹ä¾†æ‰“é–‹åºåˆ—åŸ ç›£æ§è¦–çª—ï¼Œå°‡è¨­å®šèª¿æˆ\u0026quot;9600 baud\u0026quot;å’Œ\u0026quot;NLèˆ‡CR\u0026quot;ï¼Œæœ€å¾Œä¾éœ€æ±‚è¼¸å…¥ä»¥ä¸‹å‘½ä»¤å³å¯   AT -\u0026gt; é¡¯ç¤ºOKè¡¨ç¤ºé€£æ¥æˆåŠŸ æŸ¥çœ‹éŸŒé«”ç‰ˆæœ¬ -\u0026gt; AT+VERSION æŸ¥çœ‹åç¨± -\u0026gt; AT+NAME? ä¿®æ”¹åç¨± -\u0026gt; AT+NAME=ä½ è¦çš„åå­— æŸ¥çœ‹å¯†ç¢¼ -\u0026gt; AT+PSWD? ä¿®æ”¹å¯†ç¢¼ -\u0026gt; AT+PSWD=ä½ è¦çš„å¯†ç¢¼  ","date":"2020-05-10T21:56:45+08:00","permalink":"https://blog.smallten.tk/p/arduino-05/","title":"Arduino-05ï¼šHC-05 ATå‘½ä»¤"},{"content":"ç°¡ä»‹  é€™ç¯‡å…§å®¹å°‡å¸¶é ˜å¤§å®¶è£½ä½œè—èŠ½çš„é™æ§è»Šï¼Œä¸¦ä¸”ç”¨Blynkçš„Joystickæ“æ§å®ƒ  ç¡¬é«”  Arduino nano * 1 L298N é¦¬é”æ§åˆ¶æ¿ * 1 HC-05 è—èŠ½æ¨¡çµ„ * 1 äºŒè¼ªç›´æµé¦¬é”é™æ§è»Š * 1  ä¸‹è¼‰  è‡³æ‰‹æ©Ÿæ‡‰ç”¨å•†åº—ä¸‹è¼‰Blynkçš„Appï¼Blynkå®˜ç¶² ä¸‹è¼‰Blynkå‡½å¼åº«  æ•™å­¸é–‹å§‹  å…ˆä¸Šå‚³ç¨‹å¼ç¢¼è‡³Nanoæ¿ä¸­ ä¾ç…§ä¸‹æ–¹åœ–ç¤ºé€£æ¥è…³ä½ï¼Œä¸¦ä¸”è¨­å®šBlynk Appå…§çš„ç‰©ä»¶  é€£æ¥è…³ä½  \nè¨­å®šBlynk  å‰µå»º3å€‹å…ƒä»¶ï¼Œåˆ†åˆ¥ç‚ºButtonã€Bluetoothã€Joystickï¼Œä¸¦ä¸”ä¾ä¸‹åœ–é€²è¡Œè¨­ç½®      nanoç¨‹å¼ç¢¼ #include \u0026lt;BlynkSimpleSerialBLE.h\u0026gt;#define BLYNK_USE_DIRECT_CONNECT  char auth[] = \u0026#34;Blynk Auth\u0026#34;; int d[2] = {0}; int car[2][2] = { {5, 6}, {11, 10} }; //in 1,2,4,3 int en[2] = {3, 9}; void Controller(); void Move(int, int, int, int, int, int); BLYNK_WRITE(V0){ for(int i=0; i\u0026lt;2; ++i){ d[i] = param[i].asInt(); if(d[i]\u0026lt;=64) d[i] = d[i]*2-255; else if(d[i]\u0026gt;64 \u0026amp;\u0026amp; d[i]\u0026lt;=192) d[i]=0; } } void setup() { Serial.begin(9600); Blynk.begin(Serial, auth); for(int i=0; i\u0026lt;2; ++i){ pinMode(en[i], OUTPUT); for(int j=0; j\u0026lt;2; ++j){ pinMode(car[i][j], OUTPUT); } } } void loop() { Blynk.run(); Controller(); } void Controller() { if(d[0]\u0026gt;0){ if(d[1]\u0026gt;0) Move(0, 1, 1, 0, min(d[0], d[1]), max(d[0], d[1])); else if(d[1]==0) Move(0, 0, 1, 0, 0, d[0]); else Move(1, 0, 0, 1, min(d[0], abs(d[1])), max(d[0], abs(d[1]))); } else if(d[0]==0){ if(d[1]\u0026gt;0) Move(1, 0, 1, 0, d[1], d[1]); else if(d[1]==0) Move(0, 0, 0, 0, 0, 0); else Move(0, 1, 0, 1, abs(d[1]), abs(d[1])); } else{ if(d[1]\u0026gt;0) Move(1, 0, 0, 1, max(abs(d[0]), d[1]), min(abs(d[0]), d[1])); else if(d[1]==0) Move(1, 0, 0, 0, abs(d[0]), 0); else Move(0, 1, 1, 0, max(abs(d[0]), abs(d[1])), min(abs(d[0]), abs(d[1]))); } } void Move(int a1,int a2, int a3, int a4, int e1, int e2) { digitalWrite(car[0][0], a1); digitalWrite(car[0][1], a2); digitalWrite(car[1][0], a3); digitalWrite(car[1][1], a4); analogWrite(en[0], e1); analogWrite(en[1], e2); } è£œå……  ç”±æ–¼é€™é‚Šæˆ‘å€‘å°‡HC-05å’ŒNanoæ¿çš„RXã€TXå°æ¥ï¼Œå› æ­¤è‡ªè¡Œä¿®æ”¹ç¨‹å¼ç¢¼å¾Œè¦é‡æ–°ä¸Šå‚³æ™‚ï¼Œè¨˜å¾—å…ˆç§»é™¤é€£æ¥Nanoæ¿çš„é‚£å…©æ¢ç·šï¼Œç•¶ç„¶ä¹Ÿå¯ä½¿ç”¨SoftwareSerial Libraryä¾†é€²è¡Œï¼Œå°±ä¸ç”¨æ‹”é™¤ç·šè·¯äº† è‹¥è¦è‡ªè¡Œä¿®æ”¹HC-05çš„è¨­å®šï¼Œå¯åƒè€ƒä¸‹ä¸€ç¯‡æ–‡ç«  ARDUINO-05ï¼šHC-05 ATå‘½ä»¤  ","date":"2020-05-03T16:29:01+08:00","permalink":"https://blog.smallten.tk/p/arduino-04/","title":"Arduino-04ï¼šè—èŠ½é™æ§è»Š"},{"content":"ç°¡ä»‹  é€™ç¯‡å…§å®¹å°‡å¸¶é ˜å¤§å®¶è£½ä½œé»é™£è·‘é¦¬ç‡ˆï¼Œä¸¦ä¸”ç”¨Blynkä¾†æ“æ§å®ƒ  ç¡¬é«”  WeMos D1R2 * 1 MAX7219 8*8LEDé»é™£æ¨¡çµ„ * 2  ä¸‹è¼‰  è‡³æ‰‹æ©Ÿæ‡‰ç”¨å•†åº—ä¸‹è¼‰Blynkçš„Appï¼Blynkå®˜ç¶² ä¸‹è¼‰Blynkå‡½å¼åº« maxmatrixï¼ä¸‹è¼‰ä¸¦åŠ å…¥å‡½å¼åº«  æ•™å­¸é–‹å§‹ é€£æ¥è…³ä½    MAX7219 D1R2     VCC 5V   GND GND   DIN MOSI/D7   CS SS/D8   CLK SCK/D5     è‹¥è¦ä¸²è¯å¤šå¡ŠMAX7219çš„è©±ï¼Œè«‹å°‡ä¸‹ä¸€å¡Šçš„DINæ¥è‡³ä¸Šä¸€å¡Šçš„DOUTé€£æ¥è…³ä½  è¨­å®šBlynk  è«‹ç…§ä¸‹åœ–æ‹‰å‡ºä¸‰å€‹ç‰©ä»¶ï¼Œä¸¦è¨­å®šå…¶ç›¸é—œåƒæ•¸      D1R2ç¨‹å¼ç¢¼ #include \u0026lt;MaxMatrix.h\u0026gt;#include \u0026lt;avr/pgmspace.h\u0026gt;#include \u0026lt;ESP8266WiFi.h\u0026gt;#include \u0026lt;BlynkSimpleEsp8266.h\u0026gt; char auth[] = \u0026#34;Blynk auth\u0026#34;; char ssid[] = \u0026#34;Wifi ssid\u0026#34;; char pass[] = \u0026#34;Wifi password\u0026#34;; PROGMEM const unsigned char CH[] = { 3, 8, B0000000, B0000000, B0000000, B0000000, B0000000, // space  1, 8, B1011111, B0000000, B0000000, B0000000, B0000000, // !  3, 8, B0000011, B0000000, B0000011, B0000000, B0000000, // \u0026#34;  5, 8, B0010100, B0111110, B0010100, B0111110, B0010100, // #  4, 8, B0100100, B1101010, B0101011, B0010010, B0000000, // $  5, 8, B1100011, B0010011, B0001000, B1100100, B1100011, // %  5, 8, B0110110, B1001001, B1010110, B0100000, B1010000, // \u0026amp;  1, 8, B0000011, B0000000, B0000000, B0000000, B0000000, // \u0026#39;  3, 8, B0011100, B0100010, B1000001, B0000000, B0000000, // (  3, 8, B1000001, B0100010, B0011100, B0000000, B0000000, // )  5, 8, B0101000, B0011000, B0001110, B0011000, B0101000, // *  5, 8, B0001000, B0001000, B0111110, B0001000, B0001000, // +  2, 8, B10110000, B1110000, B0000000, B0000000, B0000000, // ,  4, 8, B0001000, B0001000, B0001000, B0001000, B0000000, // -  2, 8, B1100000, B1100000, B0000000, B0000000, B0000000, // .  4, 8, B1100000, B0011000, B0000110, B0000001, B0000000, // /  4, 8, B0111110, B1000001, B1000001, B0111110, B0000000, // 0  3, 8, B1000010, B1111111, B1000000, B0000000, B0000000, // 1  4, 8, B1100010, B1010001, B1001001, B1000110, B0000000, // 2  4, 8, B0100010, B1000001, B1001001, B0110110, B0000000, // 3  4, 8, B0011000, B0010100, B0010010, B1111111, B0000000, // 4  4, 8, B0100111, B1000101, B1000101, B0111001, B0000000, // 5  4, 8, B0111110, B1001001, B1001001, B0110000, B0000000, // 6  4, 8, B1100001, B0010001, B0001001, B0000111, B0000000, // 7  4, 8, B0110110, B1001001, B1001001, B0110110, B0000000, // 8  4, 8, B0000110, B1001001, B1001001, B0111110, B0000000, // 9  2, 8, B01010000, B0000000, B0000000, B0000000, B0000000, // :  2, 8, B10000000, B01010000, B0000000, B0000000, B0000000, // ;  3, 8, B0010000, B0101000, B1000100, B0000000, B0000000, // \u0026lt;  3, 8, B0010100, B0010100, B0010100, B0000000, B0000000, // =  3, 8, B1000100, B0101000, B0010000, B0000000, B0000000, // \u0026gt;  4, 8, B0000010, B1011001, B0001001, B0000110, B0000000, // ?  5, 8, B0111110, B1001001, B1010101, B1011101, B0001110, // @  4, 8, B1111110, B0010001, B0010001, B1111110, B0000000, // A  4, 8, B1111111, B1001001, B1001001, B0110110, B0000000, // B  4, 8, B0111110, B1000001, B1000001, B0100010, B0000000, // C  4, 8, B1111111, B1000001, B1000001, B0111110, B0000000, // D  4, 8, B1111111, B1001001, B1001001, B1000001, B0000000, // E  4, 8, B1111111, B0001001, B0001001, B0000001, B0000000, // F  4, 8, B0111110, B1000001, B1001001, B1111010, B0000000, // G  4, 8, B1111111, B0001000, B0001000, B1111111, B0000000, // H  3, 8, B1000001, B1111111, B1000001, B0000000, B0000000, // I  4, 8, B0110000, B1000000, B1000001, B0111111, B0000000, // J  4, 8, B1111111, B0001000, B0010100, B1100011, B0000000, // K  4, 8, B1111111, B1000000, B1000000, B1000000, B0000000, // L  5, 8, B1111111, B0000010, B0001100, B0000010, B1111111, // M  5, 8, B1111111, B0000100, B0001000, B0010000, B1111111, // N  4, 8, B0111110, B1000001, B1000001, B0111110, B0000000, // O  4, 8, B1111111, B0001001, B0001001, B0000110, B0000000, // P  4, 8, B0111110, B1000001, B1000001, B10111110, B0000000, // Q  4, 8, B1111111, B0001001, B0001001, B1110110, B0000000, // R  4, 8, B1000110, B1001001, B1001001, B0110010, B0000000, // S  5, 8, B0000001, B0000001, B1111111, B0000001, B0000001, // T  4, 8, B0111111, B1000000, B1000000, B0111111, B0000000, // U  5, 8, B0001111, B0110000, B1000000, B0110000, B0001111, // V  5, 8, B0111111, B1000000, B0111000, B1000000, B0111111, // W  5, 8, B1100011, B0010100, B0001000, B0010100, B1100011, // X  5, 8, B0000111, B0001000, B1110000, B0001000, B0000111, // Y  4, 8, B1100001, B1010001, B1001001, B1000111, B0000000, // Z  2, 8, B1111111, B1000001, B0000000, B0000000, B0000000, // [  4, 8, B0000001, B0000110, B0011000, B1100000, B0000000, // backslash  2, 8, B1000001, B1111111, B0000000, B0000000, B0000000, // ]  3, 8, B0000010, B0000001, B0000010, B0000000, B0000000, // hat  4, 8, B1000000, B1000000, B1000000, B1000000, B0000000, // _  2, 8, B0000001, B0000010, B0000000, B0000000, B0000000, // `  4, 8, B0100000, B1010100, B1010100, B1111000, B0000000, // a  4, 8, B1111111, B1000100, B1000100, B0111000, B0000000, // b  4, 8, B0111000, B1000100, B1000100, B0101000, B0000000, // c  4, 8, B0111000, B1000100, B1000100, B1111111, B0000000, // d  4, 8, B0111000, B1010100, B1010100, B0011000, B0000000, // e  3, 8, B0000100, B1111110, B0000101, B0000000, B0000000, // f  4, 8, B10011000, B10100100, B10100100, B01111000, B0000000, // g  4, 8, B1111111, B0000100, B0000100, B1111000, B0000000, // h  3, 8, B1000100, B1111101, B1000000, B0000000, B0000000, // i  4, 8, B1000000, B10000000, B10000100, B1111101, B0000000, // j  4, 8, B1111111, B0010000, B0101000, B1000100, B0000000, // k  3, 8, B1000001, B1111111, B1000000, B0000000, B0000000, // l  5, 8, B1111100, B0000100, B1111100, B0000100, B1111000, // m  4, 8, B1111100, B0000100, B0000100, B1111000, B0000000, // n  4, 8, B0111000, B1000100, B1000100, B0111000, B0000000, // o  4, 8, B11111100, B0100100, B0100100, B0011000, B0000000, // p  4, 8, B0011000, B0100100, B0100100, B11111100, B0000000, // q  4, 8, B1111100, B0001000, B0000100, B0000100, B0000000, // r  4, 8, B1001000, B1010100, B1010100, B0100100, B0000000, // s  3, 8, B0000100, B0111111, B1000100, B0000000, B0000000, // t  4, 8, B0111100, B1000000, B1000000, B1111100, B0000000, // u  5, 8, B0011100, B0100000, B1000000, B0100000, B0011100, // v  5, 8, B0111100, B1000000, B0111100, B1000000, B0111100, // w  5, 8, B1000100, B0101000, B0010000, B0101000, B1000100, // x  4, 8, B10011100, B10100000, B10100000, B1111100, B0000000, // y  3, 8, B1100100, B1010100, B1001100, B0000000, B0000000, // z  3, 8, B0001000, B0110110, B1000001, B0000000, B0000000, // {  1, 8, B1111111, B0000000, B0000000, B0000000, B0000000, // |  3, 8, B1000001, B0110110, B0001000, B0000000, B0000000, // }  4, 8, B0001000, B0000100, B0001000, B0000100, B0000000, // ~ }; const byte data = D7; const byte cs = D8; const byte clk = D5; const byte maxInUse = 2; //ä½¿ç”¨çš„é»é™£æ¨¡å¡Šæ•¸é‡ MaxMatrix m(data, cs, clk, maxInUse); byte buffer[8]; String str; int speed = 100; //ç§»å‹•çš„é€Ÿåº¦ï¼Œå–®ä½ms int light = 5; bool islight = false; void printChar(char); BLYNK_WRITE(V0){ str = param.asStr(); for(int i=0; i\u0026lt;maxInUse; ++i) str+=\u0026#34; \u0026#34;; } BLYNK_WRITE(V1){ light = param.asInt(); islight = true; } BLYNK_WRITE(V2){ speed = param.asInt(); } void setup() { Serial.begin(115200); //Blynk  Blynk.begin(auth, ssid, pass); Blynk.virtualWrite(V1, light); Blynk.virtualWrite(V2, speed); //8*8 led  m.init(); m.setIntensity(light); //é»é™£æ¨¡çµ„çš„äº®åº¦ } void loop() { if(Blynk.connected()){ Blynk.run(); if(islight){ m.setIntensity(light); islight = false; } int len = str.length(); for(int i=0; i\u0026lt;len; ++i){ printChar(str[i]); } } else{ Blynk.begin(auth, ssid, pass); Serial.println(\u0026#34;Reconnected!\u0026#34;); } } void printChar(char c) { if(c\u0026lt;32) return; c-=32; memcpy_P(buffer, CH+7*c, 7); m.writeSprite(32, 0, buffer); m.setColumn(32+buffer[0], 0); for(int i=0; i\u0026lt;=buffer[0]; ++i){ delay(speed); /*å¾€å·¦ä½ç§»ï¼Œç¬¬ä¸€å€‹åƒæ•¸falseï¼Œä»£è¡¨ä¸æ—‹è½‰ï¼› ç¬¬äºŒå€‹åƒæ•¸falseï¼Œä»£è¡¨ä¸æ¸…ç©ºé¡¯ç¤ºï¼›è‹¥è¨­æˆtrueï¼Œé¡¯ç¤ºå™¨å°‡ä¸å‘ˆç¾è³‡æ–™ã€‚*/ m.shiftLeft(false, false); } } è£œå……  è‹¥æ˜¯è¦ºå¾—Blynkçš„èƒ½é‡å¤ªå°‘ï¼Œå¯è‡ªè¡Œæ¶è¨­ Server  ","date":"2020-04-09T14:50:56+08:00","permalink":"https://blog.smallten.tk/p/arduino-03/","title":"Arduino-03ï¼šè·‘é¦¬ç‡ˆ"},{"content":"ç°¡ä»‹  é€™ç¯‡å…§å®¹å°‡å¸¶é ˜å¤§å®¶æŠŠArduinoæ‰‹æŠŠè®Šæˆé›»è…¦æ‰‹æŠŠ  æ‰€éœ€ç¡¬é«”  Arduino Uno R3 * 1 JoyStick é›™è»¸æŒ‰éµæ–æ¡¿æ¨¡çµ„ * 1  ä¸‹è¼‰æª”æ¡ˆ  FLIP ï¼ è«‹ä¸‹è¼‰åŒ…å«JREçš„æª”æ¡ˆ(Java Runtime Environment included) UnoJoy ï¼ å°‡Unoè®Šæˆé›»è…¦æ‰‹æŠŠ x360ce ï¼ å°‡æ‰‹æŠŠæ¨¡æ“¬æˆxbox 360çš„æ‰‹æŠŠ  æ•™å­¸é–‹å§‹  å°‡ä¸‹è¼‰å¥½çš„FLIPå®‰è£è‡³é›»è…¦ ç¢ºå®šé›»è…¦å·²å®‰è£Arduino IDEï¼Œä¸¦å·²é€£æ¥Unoæ¿è‡³é›»è…¦ï¼Œå¯åœ¨è£ç½®ç®¡ç†å“¡æŸ¥çœ‹ç‹€æ…‹ï¼ˆå¦‚ä¸‹åœ–ï¼‰   æ‰“é–‹å‰›å‰›ä¸‹è¼‰çš„UnoJoyè³‡æ–™å¤¾ä¸‹çš„æª”æ¡ˆï¼Œä¸¦å°‡å®ƒä¸Šå‚³é€²Unoæ¿ä¸­ UnoJoy-master\\UnoJoy\\UnoJoyArduinoSample\\UnoJoyArduinoSample.ino é—œé–‰Arduino IDEï¼Œé€²å…¥DFU Modeï¼Œé€²å…¥æ–¹å¼ï¼šç”¨å°ç·šåŒæ™‚æ¥è§¸ä¸‹åœ–æ¡†èµ·è™•çš„å…©æ ¹é‡è…³   ç¢ºèªå·²é€²å…¥ DFU Modeï¼Œå¦‚ä¸‹åœ–    è‹¥æ‰¾ä¸åˆ°é©…å‹•å¯æ‰‹å‹•æ–°å¢é©…å‹•ï¼Œé¸æ“‡è³‡æ–™å¤¾ç‚º C:\\Program Files (x86)\\Atmel\\Flip 3.4.7\\usb   æ‰“é–‹UnoJoyè³‡æ–™å¤¾ï¼Œå•Ÿå‹•TurnIntoAJoystickçš„æ‰¹æ¬¡æª”ï¼Œæª”æ¡ˆè·¯å¾‘ UnoJoy-master\\UnoJoy\\TurnIntoAJoystick.batï¼ŒåŸ·è¡ŒæˆåŠŸçµæœå¦‚ä¸‹åœ–   è‡³æ­¤å·²å®Œæˆå°‡Unoè®Šæˆé›»è…¦æ–æ¡¿ï¼Œä¹‹å¾Œæ’ä¸ŠUnoæ¿çš†ç‚ºUnoJoy Joystickï¼Œå¯åœ¨ä»¥ä¸‹è·¯å¾‘æŸ¥çœ‹ æ§åˆ¶å°\\ç¡¬é«”å’ŒéŸ³æ•ˆ\\è£ç½®å’Œå°è¡¨æ©Ÿ å°‡æ–æ¡¿çš„vrxå’Œvryåˆ†åˆ¥é€£æ¥è‡³Unoæ¿çš„A0å’ŒA1ï¼Œåœ¨ æ§åˆ¶å°\\ç¡¬é«”å’ŒéŸ³æ•ˆ\\è£ç½®å’Œå°è¡¨æ©Ÿ è£¡çš„UnoJoy Joystickåœ–ç¤ºä¸Šå³éµ-\u0026gt;éŠæˆ²æ§åˆ¶å™¨-\u0026gt;å…§å®¹ï¼Œå¯æŸ¥çœ‹æ–æ¡¿ç‹€æ…‹ï¼Œå¦‚ä¸‹åœ–   æœ€å¾Œé€²å…¥èµ·å‹•x360ceï¼Œæ–°å»ºç«‹ä¸€å€‹æ–æ¡¿çš„è¨­å®šæª”ï¼Œä¸¦é¸å–æ¨¡æ“¬çš„ä½ç½®ï¼Œé»é¸[Record]ï¼Œä¾åœ–ç¤ºç§»å‹•æ–æ¡¿æ–¹å‘å³è¨­å®šå®Œæˆ  è£œå……  å¦‚ä½•å°‡UnoJoy Joystickè®Šå›ä¸€èˆ¬çš„Arduino Unoæ¿  é€£æ¥UnoJoy Joystickï¼Œä¸¦é€²å…¥DFU Mode æ‰“é–‹UnoJoyè³‡æ–™å¤¾ï¼Œå•Ÿå‹•TurnIntoAnArduinoçš„æ‰¹æ¬¡æª”ï¼Œæª”æ¡ˆè·¯å¾‘ UnoJoy-master\\UnoJoy\\TurnIntoAnArduino.bat å°‡Unoçš„usbé‡æ–°æ¥ä¸Šé›»è…¦ï¼Œå³å¯çœ‹åˆ°å·²è®Šå›   å¦‚æœUnoJoyæª”æ¡ˆä¸‹è¼‰å¤ªæ…¢ï¼Œå¯è‡³ é€™è£¡ ä¸‹è¼‰ï¼Œä½†æ­¤è¼‰é»å…§å®¹åƒ…åŒ…å«unoæ¿çš„æª”æ¡ˆï¼ˆGithubçš„æª”æ¡ˆè£¡åŒ…å«å…¶ä»–æ¿å­è®Šæˆæ‰‹æŠŠçš„æª”æ¡ˆï¼Œæ•…æª”æ¡ˆç›¸å°è¼ƒå¤§ï¼‰ å¦‚ä½•åœ¨é›»è…¦éŠæˆ²ä¸­ä½¿ç”¨æ­¤æ‰‹æŠŠ  å°‡å‰›å‰›x360ceå‰µå»ºçš„å…©å€‹æª”æ¡ˆï¼ˆx360ce.ini/xinput.dllï¼‰æ”¾é€²éŠæˆ²è³‡æ–™å¤¾çš„æ ¹ç›®éŒ„å³å¯   æ­¤ç¯„ä¾‹æª”æ¡ˆé è¨­æ–æ¡¿è³‡è¨Š  A0~A1 ï¼ ç‚ºå·¦æ–æ¡¿çš„xï¼Œy A2~A3 ï¼ ç‚ºå³æ–æ¡¿çš„xï¼Œy D2~D5 ï¼ ç‚ºPSæ–æ¡¿çš„å³å´åŠŸèƒ½éµ D6~D9 ï¼ ç‚ºPSæ–æ¡¿çš„å·¦å´æ–¹å‘éµ D10~D11 ï¼ ç‚ºPSæ–æ¡¿çš„L1R1 D12 ï¼ select A4 ï¼ start A5 ï¼ home ä½†ç”±æ–¼æ˜¯æ¨¡æ“¬æˆxboxçš„æ‰‹æŠŠï¼Œæ•…å¯è‡ªç”±æ¥ç·šï¼Œå†ç”±x360ceä¸­ç›´æ¥[Record]å³å¯ è‹¥æ˜¯è…³ä½ä¸å¤ å¯è‡ªè¡Œæ›¿æ›æˆmegaæ¿    ","date":"2020-04-09T08:16:57+08:00","permalink":"https://blog.smallten.tk/p/arduino-02/","title":"Arduino-02ï¼šUNOJOY"},{"content":"å®˜æ–¹IDE  æ­¤IDEç”±å®˜æ–¹æä¾›ï¼Œå¯åœ¨æ­¤æŸ¥çœ‹å®˜ç¶² ä¸‹è¼‰ï¼å®˜æ–¹è¼‰é»    VSCode + PlatformIO  å…ˆä¸‹è¼‰ VSCode å†å®‰è£ PlatformIO çš„æ’ä»¶    ","date":"2020-04-09T08:08:43+08:00","permalink":"https://blog.smallten.tk/p/arduino-01/","title":"Arduino-01ï¼šå®‰è£IDE"}]