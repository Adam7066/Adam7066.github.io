[{"content":"競賽簡介  NCPC 初賽日期：2021/10/02  成績  校內：7 / 12 全體：26 / 166  心得文  \n  這段時間真的有點忙過頭了\n 安排 CTF 讀書會的課表（嘿嘿，還去跟 L紀 教授要到了一堂課，希望到時他不會有突發的事情，而是能正常的出席講課），也跟學長一起參加了社團幹部培訓的研習。 協助以前的高中辦理了學科能力競賽的校內初賽，不只從報名簡章到表單，還有競賽的平台以及題目，這裡要特別的感謝一起陪我瘋狂的朋朋 蘇子權，但不得不說，學弟們還得多多加油呀，有機會、時間的話再回去辦研習課程吧！ 我要小小的抱怨一下，學校的選課系統  到底要多久才有機會看到它更新？(有時間去弄那一點都不友善的手機版，不如去重構整個系統。) 不要再人工分流了，很智障。 好好做防 Bot 不行嗎？用那讓人很無言的驗證碼設計，整個傻眼。（打英文還會比打數字的多打幾個字） 系統分發的部份，到底為什麼要那麼久才公佈，又不是用上古年代的電腦，有內幕嗎？（求八卦 二階選課以前是不是直接搶課的呀，教程一階生，最高能選 6 學分，但用志願分發的，但志願只能填到 6 學分，這樣根本分不到呀，傻眼～～ 最重要的是，我第一個選課，比我晚搶課的同學都一一搶到（他們在不同的 server 上，就智障的人工分流問題），我卻只能看你寫登記中，然後慢慢等，直到最後跟我說滿額，是想怎樣啦 😡😡 ，但感謝身旁的朋朋們願意跟我一起去修早八的課程（把大學念到變高中）。 我真的變學分孤兒了😭😭   終於搶到疫苗了，但週日回臺南，禮拜一打疫苗，禮拜三一退燒就又重回北部，週六又打 NCPC 的初賽，整個瘋了～～    終於要來認真打該有的心得文了，這次的競賽我們隊伍終於好不容易組成了（文元原本因為身心狀態問題沒有要打了），但到比賽的前一天，我們的子權朋朋卻腸胃炎(尷尬)，而文元本來就是被我們抓來一起玩的而已(畢竟他依然得吃葡萄口味的曼陀珠？)，而我前一晚也想到一堆不想去想的東西，也沒睡到特別好\u0026hellip;唉，整個發芬（文元語，咦？\n  好啦，雖然這次又跟 NCPC 的決賽擦身而過，我是不是真的有萬年老二的命呀？（初賽校內取到第六名），但是這一次的競賽是真的打的非常的開心（賽前測機部份、沒有印表機以及點心除外），水題我依舊是穩穩的 1 try 就解掉費時也不長，其中有一題文元提出模運算，我想到如何搭配前綴和使用，就 AC 了，撒花（但有些隊伍有寫過一樣的題目了，所以非常的早就解出來了 QAQ)，有一題我的想法是對的了，但子權刻後半的部份時一個迴圈寫錯了，最後也有除錯除出來，棒棒的～～（這次有看的所有題目都有好好的解出來呢！）\n  整體來說，這次競賽讓我享受到了不只有緊張的氣氛，還有團隊解出題時的愉悅，所以雖然沒有進決賽一樣很可惜，但我們志在參與嘛（弱者的發言😭😭），不久後的 TOPC 也得繼續加油呢！\n  後記  到底為什麼要在生日當天打比賽呢，生日不就應該好好的躺在床上耍廢到極致嗎？真是的。好啦，這邊也要感謝我家饅頭頭的生日禮物，雖然遲了一天，原因是卡片沒寫好，（咦～），但都是我喜歡的東西呢(有最可愛的小十，還有史萊姆)，太開心了吧！！我自己也送了自己不少東西（單純找理由買東西，誤///）其中有大小兩隻可愛的小十呦，開心～～     ","date":"2021-10-04T09:15:29+08:00","permalink":"https://blog.smallten.tk/p/experience-02/","title":"2021 NCPC 初賽"},{"content":"主題  最短路徑  最短路徑模板 Dijkstra’s  不能有負邊  int vn; // vertex num struct Edge { int w, idx; bool operator \u0026lt; (const Edge \u0026amp;r) const { return w \u0026gt; r.w; } }; vector\u0026lt;Edge\u0026gt; adj[maxv]; void dijkstra(int s) { vector\u0026lt;bool\u0026gt; vis(vn, false); vector\u0026lt;int\u0026gt; dist(vn, INF); dist[s] = 0; priority_queue\u0026lt;Edge\u0026gt; pq; pq.emplace(0, s); while(!pq.empty()) { int u = pq.top().idx; pq.pop(); if(vis[u]) continue; vis[u] = true; for(auto v : adj[u]) { if(dist[v.idx] \u0026gt; dist[u] + v.w) { dist[v.idx] = dist[u] + v.w; pq.emplace(dist[v.idx], v.idx); } } } } Bellman-Ford  可以檢查是否有環  int vn; // vertex num struct Edge { int idx, w; }; vector\u0026lt;Edge\u0026gt; adj[maxv]; bool bellmanford(int s) { //return true if negative cycle exists;  int cnt = 0; bool update = false; vector\u0026lt;int\u0026gt; dist(vn, INF); dist[s] = 0; do { if(++cnt == vn) return true; update = false; for(int u = 0; u \u0026lt; vn; ++u) { if(dist[u] == INF) continue; for(auto v : adj[u]) { if(dist[v.idx] \u0026gt; dist[u] + v.w) { update = true; dist[v.idx] = dist[u] + v.w; } } } } while(update); return false; } Floyd-Warshall int dist[MAX_V][MAX_V]; for(int k = 0; k \u0026lt; vn; ++k) for(int i = 0; i \u0026lt; vn; ++i) for(int j = 0; j \u0026lt; vn; ++j) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); 題目  Virtual Judge 題目列表與提示    題目 題目需求 難度     UVa 929 給一個二維迷宮，求左上走到右下的最少成本（最短路徑）。 單源模板題   UVa 10986 給一個無向帶權圖，求指定兩點間的最短路徑長。 單源模板題   UVa 10000 給一個有向無環圖，求指定兩點間的最長路徑。 多種作法   UVa 558 給定一個有向帶權圖（黑洞通道為邊），問是否存在負環（可回到無限遠的過去）。 BF   UVa 10801 給定電梯系統與移動時間，若轉換電梯需 60 秒，問去某樓的最短時間。 單源小變化   UVa 821 給一個無向無權圖，求所有兩點間最短路徑長的平均值。 FW 模板題   UVa 10048 給一個無向帶權圖，求指定兩點間路徑上最大邊權的最小值。 FW 變化   UVa 658 給一堆修補程式的安裝前後狀態，問最少要安裝多少次修補程式可以修好所有 bug。 變化題   UVa 11374 給經濟線和商業線兩套捷運路線圖的行駛時間，在商業線只能搭一段的限制下，求指定兩點間的最快路線。 變化題   UVa 10917 題目不長，自己讀讀看。 變化題      參考作法 A - Number Maze #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using tiii = tuple\u0026lt;int, int, int\u0026gt;; int d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(m, 0)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; val(n, vector\u0026lt;int\u0026gt;(m, -1)); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; vis(n, vector\u0026lt;bool\u0026gt;(m, false)); priority_queue\u0026lt;tiii, vector\u0026lt;tiii\u0026gt;, greater\u0026lt;tiii\u0026gt;\u0026gt; pq; for(int i = 0; i \u0026lt; n; ++i) for(int j = 0; j \u0026lt; m; ++j) cin \u0026gt;\u0026gt; g[i][j]; val[0][0] = g[0][0]; pq.push(make_tuple(g[0][0], 0, 0)); while(!pq.empty()) { int v, x, y; tie(v, x, y) = pq.top(); pq.pop(); vis[x][y] = true; for(int i = 0; i \u0026lt; 4; ++i) { int nx = x + d[i][0], ny = y + d[i][1]; if(nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; n \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; m \u0026amp;\u0026amp; !vis[nx][ny]) { int tmp = v + g[nx][ny]; if(val[nx][ny] == -1 || val[nx][ny] \u0026gt; tmp) { val[nx][ny] = tmp; pq.push(make_tuple(tmp, nx, ny)); } } } } cout \u0026lt;\u0026lt; val[n - 1][m - 1] \u0026lt;\u0026lt; endl; } return 0; } B - Sending email #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using pii = pair\u0026lt;int, int\u0026gt;; using plli = pair\u0026lt;long long, int\u0026gt;; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; for(int ca = 1; ca \u0026lt;= T; ++ca) { cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; int n, m, s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; vector\u0026lt;pii\u0026gt; g[n]; vector\u0026lt;long long\u0026gt; val(n, INF); vector\u0026lt;bool\u0026gt; vis(n, false); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; g[a].push_back({b, c}); g[b].push_back({a, c}); } priority_queue\u0026lt;plli, vector\u0026lt;plli\u0026gt;, greater\u0026lt;plli\u0026gt;\u0026gt; pq; val[s] = 0; pq.push({0, s}); while(!pq.empty()) { int v = pq.top().first, x = pq.top().second; pq.pop(); if(val[x] \u0026lt; v) continue; for(auto it : g[x]) { if(val[it.first] \u0026gt; val[x] + it.second) { val[it.first] = val[x] + it.second; pq.push({val[it.first], it.first}); } } } if(val[t] == INF) cout \u0026lt;\u0026lt; \u0026#34;unreachable\\n\u0026#34;; else cout \u0026lt;\u0026lt; val[t] \u0026lt;\u0026lt; endl; } return 0; } C - Longest Paths #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct edge { int u, v; }; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int n, cnt = 0; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { int s; cin \u0026gt;\u0026gt; s; int p, q; vector\u0026lt;edge\u0026gt; g; vector\u0026lt;int\u0026gt; val(n + 1, INF); while(cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; q \u0026amp;\u0026amp; !(p == 0 \u0026amp;\u0026amp; q == 0)) g.push_back({p, q}); val[s] = 0; for(int i = 0; i \u0026lt; n; ++i) { for(auto it : g) { if(val[it.v] \u0026gt; val[it.u] - 1 \u0026amp;\u0026amp; val[it.u] != INF) val[it.v] = val[it.u] - 1; } } int en, ans = 0; for(int i = 1; i \u0026lt;= n; ++i) { if(val[i] \u0026lt; ans) { ans = val[i]; en = i; } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++cnt \u0026lt;\u0026lt; \u0026#34;: The longest path from \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34; has length \u0026#34; \u0026lt;\u0026lt; -1 * ans \u0026lt;\u0026lt; \u0026#34;, finishing at \u0026#34; \u0026lt;\u0026lt; en \u0026lt;\u0026lt; \u0026#34;.\\n\\n\u0026#34;; } return 0; } D - Wormholes #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n, m; struct edge { int u, v, w; }; bool Bellman_Ford(vector\u0026lt;edge\u0026gt; \u0026amp;ve, vector\u0026lt;int\u0026gt; val) { for(int i = 0; i \u0026lt; n; ++i) { bool flag = false; for(int j = 0; j \u0026lt; m; ++j) { if(val[ve[j].v] \u0026gt; val[ve[j].u] + ve[j].w \u0026amp;\u0026amp; val[ve[j].u] != INF) { val[ve[j].v] = val[ve[j].u] + ve[j].w; flag = true; } } if(!flag) return true; if(i == n - 1 \u0026amp;\u0026amp; flag) return false; } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; val(n, INF); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; ve.push_back({a, b, c}); } val[0] = 0; if(Bellman_Ford(ve, val)) cout \u0026lt;\u0026lt; \u0026#34;not possible\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;possible\\n\u0026#34;; } return 0; } E - Lift Hopping #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int n, tar; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; tar) { vector\u0026lt;int\u0026gt; vt(n), va; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; w(100, vector\u0026lt;int\u0026gt;(100, INF)); for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; vt[i]; cin.ignore(100, \u0026#39;\\n\u0026#39;); for(int i = 0; i \u0026lt; n; ++i) { va.clear(); string s; getline(cin, s); stringstream ss(s); int tmp; while(ss \u0026gt;\u0026gt; tmp) va.push_back(tmp); for(int j = 0; j \u0026lt; va.size(); ++j) { for(int k = j + 1; k \u0026lt; va.size(); ++k) { int dis = abs(va[j] - va[k]) * vt[i]; if(dis \u0026lt; w[va[j]][va[k]]) w[va[j]][va[k]] = w[va[k]][va[j]] = dis; } } } vector\u0026lt;bool\u0026gt; vis(n, false); vector\u0026lt;int\u0026gt; d(100, INF); d[0] = 0; for(int i = 0; i \u0026lt; 100; ++i) { int x, m = INF; for(int y = 0; y \u0026lt; 100; ++y) { if(!vis[y] \u0026amp;\u0026amp; d[y] \u0026lt; m) { m = d[y]; x = y; } } vis[x] = true; for(int y = 0; y \u0026lt; 100; ++y) { if(d[y] \u0026gt; d[x] + w[x][y] + 60) d[y] = d[x] + w[x][y] + 60; } } if(d[tar] == INF) cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\\n\u0026#34;; else { if(tar == 0) cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34;; else cout \u0026lt;\u0026lt; d[tar] - 60 \u0026lt;\u0026lt; endl; } } return 0; } F - Page Hopping #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 map\u0026lt;int, int\u0026gt; m; void memNum(int n) { if(m.find(n) == m.end()) m[n] = m.size(); } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int ca = 1, x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026amp;\u0026amp; !(x == 0 \u0026amp;\u0026amp; y == 0)) { m.clear(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(110, vector\u0026lt;int\u0026gt;(110, INF)); for(int i = 0; i \u0026lt; 110; ++i) g[i][i] = 0; memNum(x); memNum(y); g[m[x]][m[y]] = 1; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026amp;\u0026amp; !(x == 0 \u0026amp;\u0026amp; y == 0)) { memNum(x); memNum(y); g[m[x]][m[y]] = 1; } int cnt = 0, sz = m.size(); for(int k = 0; k \u0026lt; sz; ++k) { for(int i = 0; i \u0026lt; sz; ++i) { for(int j = 0; j \u0026lt; sz; ++j) { g[i][j] = min(g[i][j], g[i][k] + g[k][j]); } } } for(int i = 0; i \u0026lt; sz; ++i) { for(int j = 0; j \u0026lt; sz; ++j) { if(g[i][j] != INF) cnt += g[i][j]; } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ca++ \u0026lt;\u0026lt; \u0026#34;: average length between pages = \u0026#34;; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; (double)cnt / (sz * (sz - 1)) \u0026lt;\u0026lt; \u0026#34; clicks\\n\u0026#34;; } return 0; } G - Audiophobia #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int c, s, q, ca = 1; while(cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; s \u0026gt;\u0026gt; q \u0026amp;\u0026amp; !(c == 0 \u0026amp;\u0026amp; s == 0 \u0026amp;\u0026amp; q == 0)) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; path(1005, vector\u0026lt;int\u0026gt;(1005, INF)); int c1, c2, d; for(int i = 0; i \u0026lt; s; ++i) { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; c2 \u0026gt;\u0026gt; d; path[c1][c2] = path[c2][c1] = d; } for(int k = 1; k \u0026lt;= c; ++k) { for(int i = 1; i \u0026lt;= c; ++i) { for(int j = 1; j \u0026lt;= c; ++j) { path[i][j] = min(path[i][j], max(path[i][k], path[k][j])); } } } if(ca \u0026gt; 1) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; ca++ \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; q; ++i) { cin \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; c2; if(path[c1][c2] != INF) cout \u0026lt;\u0026lt; path[c1][c2] \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;no path\\n\u0026#34;; } } return 0; } H - It\u0026rsquo;s not a Bug, it\u0026rsquo;s a Feature! #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 #define maxn (1\u0026lt;\u0026lt;20) + 10 #define maxm 110 int n, m, minTime; bool vis[maxn]; struct node { int time; int a1, a2, b1, b2; } a[maxm]; struct pqNode { int u, d; bool operator \u0026lt; (const pqNode \u0026amp;r) const { return d \u0026gt; r.d; } }; bool dijkstra() { priority_queue\u0026lt;pqNode\u0026gt; pq; pq.push({(1 \u0026lt;\u0026lt; n) - 1, 0}); while(!pq.empty()) { pqNode x = pq.top(); pq.pop(); if(x.u == 0) { minTime = x.d; return true; } if(vis[x.u]) continue; vis[x.u] = true; for(int i = 0; i \u0026lt; m; ++i) { if((x.u \u0026amp; a[i].a1) == a[i].a1 \u0026amp;\u0026amp; (~x.u \u0026amp; a[i].a2) == a[i].a2) { int t = x.u | a[i].b1; t = t \u0026amp; ~a[i].b2; pq.push({t, x.d + a[i].time}); } } } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int ca = 1; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; !(n == 0 \u0026amp;\u0026amp; m == 0)) { cout \u0026lt;\u0026lt; \u0026#34;Product \u0026#34; \u0026lt;\u0026lt; ca++ \u0026lt;\u0026lt; endl; memset(vis, false, sizeof(vis)); for(int i = 0; i \u0026lt;= m; ++i) a[i].time = a[i].a1 = a[i].a2 = a[i].b1 = a[i].b2 = 0; for(int i = 0; i \u0026lt; m; ++i) { int t; string s1, s2; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; for(int j = 0; j \u0026lt; n; ++j) { a[i].time = t; if(s1[n - 1 - j] == \u0026#39;+\u0026#39;) a[i].a1 = (a[i].a1 | (1 \u0026lt;\u0026lt; j)); if(s1[n - 1 - j] == \u0026#39;-\u0026#39;) a[i].a2 = (a[i].a2 | (1 \u0026lt;\u0026lt; j)); if(s2[n - 1 - j] == \u0026#39;+\u0026#39;) a[i].b1 = (a[i].b1 | (1 \u0026lt;\u0026lt; j)); if(s2[n - 1 - j] == \u0026#39;-\u0026#39;) a[i].b2 = (a[i].b2 | (1 \u0026lt;\u0026lt; j)); } } if(dijkstra()) cout \u0026lt;\u0026lt; \u0026#34;Fastest sequence takes \u0026#34; \u0026lt;\u0026lt; minTime \u0026lt;\u0026lt; \u0026#34; seconds.\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Bugs cannot be fixed.\\n\u0026#34;; cout \u0026lt;\u0026lt; endl; } return 0; } I - Airport Express #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 #define maxn 505 struct edge { int u, v, dist; }; struct node { int d, u; bool operator \u0026lt; (const node \u0026amp;r) const { return d \u0026gt; r.d; } }; vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; g[maxn], path1[maxn], path2[maxn]; bool done[maxn]; int d[maxn], p[maxn], d1[maxn], d2[maxn]; int ca = 0, n, s, e, m, k; void dijkstra(int s, int *dist, vector\u0026lt;int\u0026gt; *paths) { priority_queue\u0026lt;node\u0026gt; pq; for(int i = 0; i \u0026lt; n; ++i) d[i] = INF; d[s] = 0; memset(done, 0, sizeof(done)); pq.push({0, s}); while(!pq.empty()) { node x = pq.top(); pq.pop(); if(done[x.u]) continue; done[x.u] = true; for(int i = 0; i \u0026lt; g[x.u].size(); ++i) { edge \u0026amp;e = ve[g[x.u][i]]; if(d[e.v] \u0026gt; d[x.u] + e.dist) { d[e.v] = d[x.u] + e.dist; p[e.v] = g[x.u][i]; pq.push({d[e.v], e.v}); } } } for(int i = 0; i \u0026lt; n; ++i) { dist[i] = d[i]; paths[i].clear(); int t = i; paths[i].push_back(t); while(t != s) { paths[i].push_back(ve[p[t]].u); t = ve[p[t]].u; } reverse(paths[i].begin(), paths[i].end()); } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; m) { for(int i = 0; i \u0026lt; n; ++i) g[i].clear(); ve.clear(); --s; --e; for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; --a; --b; ve.push_back({a, b, c}); g[a].push_back(ve.size()-1); ve.push_back({b, a, c}); g[b].push_back(ve.size()-1); } dijkstra(s, d1, path1); dijkstra(e, d2, path2); int ans = d1[e]; vector\u0026lt;int\u0026gt; pp = path1[e]; int midpoint = -1; cin \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; k; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; --a; --b; for(int j = 0; j \u0026lt; 2; ++j) { if(d1[a] + d2[b] + c \u0026lt; ans) { ans = d1[a] + d2[b] + c; pp = path1[a]; for(int p = path2[b].size() - 1; p \u0026gt;= 0; --p) pp.push_back(path2[b][p]); midpoint = a; } swap(a, b); } } if(ca++ != 0) cout \u0026lt;\u0026lt; endl; for(int i = 0; i \u0026lt; pp.size() - 1; ++i) cout \u0026lt;\u0026lt; pp[i] + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; e + 1 \u0026lt;\u0026lt; endl; if(midpoint == -1) cout \u0026lt;\u0026lt; \u0026#34;Ticket Not Used\\n\u0026#34;; else cout \u0026lt;\u0026lt; midpoint + 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } J - Walk Through the Forest #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; link[1001]; vector\u0026lt;int\u0026gt; rebuild[1001]; int distant[1001]; int dp[1001]; bool vis[1001]; int n, m; struct node { int dis, index; bool operator \u0026lt; (const node \u0026amp;r) const { return dis \u0026gt; r.dis; } }; int dfs(int now) { if(now == 1) return 1; if(dp[now] == -1) { dp[now] = 0; for(auto i : rebuild[now]) dp[now] += dfs(i); } return dp[now]; } void dijkstra() { priority_queue\u0026lt;node\u0026gt; pq; pq.push({0, 1}); int cur; distant[1] = 0; while(!pq.empty()) { cur = pq.top().index; pq.pop(); if(vis[cur]) continue; vis[cur] = 1; for(auto i : link[cur]) { int next = i.first; int dis = i.second; if(distant[next] \u0026gt; distant[cur] + dis) { distant[next] = distant[cur] + dis; pq.push({distant[next], next}); } } } } void build() { memset(dp, -1, sizeof(dp)); int next, dis; for(int i = 0; i \u0026lt; n; ++i) { rebuild[i].clear(); for(auto j : link[i]) if(distant[i] \u0026gt; distant[j.first]) rebuild[i].emplace_back(j.first); } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n) { memset(link, 0, sizeof(link)); memset(vis, 0, sizeof(vis)); for(int i = 0; i \u0026lt; n; ++i) distant[i] = INF; while(m--) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; link[--a].push_back({--b, c}); link[b].push_back({a, c}); } dijkstra(); build(); cout \u0026lt;\u0026lt; dfs(0) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":"2021-08-18T16:02:47+08:00","permalink":"https://blog.smallten.tk/p/star_coder-07/","title":"StarCoder2021暑訓：Week06"},{"content":"前言  有了桌面環境，軟體也不可以缺少吧，因此這裡會紀錄一下用到的軟體的安裝方式\n教學開始 Yay  Yay 的 Github  pacman -S --needed base-devel git go git clone https://aur.archlinux.org/yay.git cd yay makepkg -si 中文輸入法  中文輸入法 Wiki 這邊我選擇了之前在 Ubuntu 用習慣的 ibus (IBus (简体中文) Wiki)  安裝注音輸入法：pacman -S ibus ibus-chewing vim /etc/environment GTK_IM_MODULE=ibus QT_IM_MODULE=ibus XMODIFIERS=@im=ibus  vim ~/.xprofile export CTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -drxR  重新啟動    Oh My Zsh  Oh My Zsh 的 官網、Github 安裝 zsh：pacman -S zsh 看系統是否裝了 zsh：cat /etc/shells 切換 Shell 為 zsh：chsh -s /bin/zsh 安裝 Git 以及 Curl：pacman -S git curl 安裝 oh-my-zsh：sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 配置主題，我選擇的是 powerlevel10k  安裝 Nerd Fonts字體 # 下載字體 mkdir -p ~/.local/share/fonts cd ~/.local/share/fonts \u0026amp;\u0026amp; curl -fLo \u0026#34;Droid Sans Mono for Powerline Nerd Font Complete.otf\u0026#34; https://github.com/ryanoasis/nerd-fonts/raw/master/patched-fonts/DroidSansMono/complete/Droid%20Sans%20Mono%20Nerd%20Font%20Complete.otf # 快取字體 fc-cache -vf ~/.local/share/fonts/ # 查看是否安裝成功 fc-list | grep -i droid  設定終端字體  設定 -\u0026gt; 編輯目前的設定檔\u0026hellip; -\u0026gt; 外觀 -\u0026gt; 字型 -\u0026gt; DroidSansMono Nerd Font   下載 powerlevel10k：git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k 修改主題：vim ~/.zshrc  修改 ZSH_THEME 為：ZSH_THEME=\u0026quot;powerlevel10k/powerlevel10k\u0026quot;   更新配置：source .zshrc   安裝插件  下載 zsh-autosuggestion：git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 下載 zsh-syntax-highlighting：git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 修改 .zshrc：vim ~/.zshrc plugins=( git extract archlinux colored-man-pages zsh-syntax-highlighting zsh-autosuggestions )  更新配置：source .zshrc    Vim 配置  請查看 Use Vim as IDE  藍芽設置  使用 Sony WH-1000XM4 測試可行 pacman -S bluez bluez-utils systemctl start bluetooth.service systemctl enable bluetooth.service pacman -S pulseaudio-bluetooth reboot   其他軟體  TLP pacman -S tlp systemctl enable --now tlp  Google Chrome：yay -S google-chrome 1password：yay -S 1password Neofetch： pacman -S neofetch Keyring：pacman -S gnome-keyring  Seahorse：pacman -S seahorse   Visual Studio Code：yay -S visual-studio-code-bin  增加在資料夾上右鍵開啟的選項：vim /usr/share/kservices5/vscodehere.desktop [Desktop Entry] Type=Service X-KDE-ServiceTypes=KonqPopupMenu/Plugin MimeType=inode/directory; X-KDE-Priority=TopLevel Actions=openVSCodeHere; X-KDE-AuthorizeAction=shell_access [Desktop Action openVSCodeHere] TryExec=code Exec=code %f Icon=visual-studio-code Name=Open VS Code Here Comment=Opens a VS Code Instance in the current folder    Discord：pacman -S discord LibreOffice：pacman -S libreoffice-still libreoffice-still-zh-tw Hugo-Extended：yay -S hugo-bin UxPlay：用於 iPad 的螢幕共享  安裝： yay -S uxplay-git systemctl start avahi-daemon.service systemctl enable avahi-daemon.service  使用：uxplay    ","date":"2021-08-11T22:18:09+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-04/","title":"Arch Linux-04：基本軟體安裝"},{"content":"前言  在安裝完了系統，也設定了基本配置後，想當然爾，該來安裝一個桌面環境了吧，因此接下來將告訴你怎麼安裝 KDE。\n教學開始 基本安裝  安裝 KDE  Arch Linux 的 meta package 與 package group 安裝 Plasma：pacman -S plasma-meta 安裝 KDE applications：pacman -S kde-applications   安裝顯示管理器  這邊我們將使用 SDDM：pacman -S sddm 設定自動啟動：systemctl enable sddm.service   安裝終端模擬器  這邊我們使用 konsole：pacman -S konsole 喜歡 kitty 的也可安裝：pacman -S kitty   安裝文件管理器  這邊我們使用 Dolphin：pacman -S dolphin   一些基本軟體  中文字體：pacman -S adobe-source-han-sans-tw-fonts   重新啟動：reboot  KDE 美化  切換系統語言  系統設定 -\u0026gt; 區域設定 -\u0026gt;  語言 -\u0026gt; 增加語言\u0026hellip; -\u0026gt; 繁體中文 -\u0026gt; 設為預設 -\u0026gt; 套用 Formats -\u0026gt; 區域 -\u0026gt; 選擇 台灣 - 繁體中文 (zh_TW)     調整顯示設定  系統設定 -\u0026gt; 顯示與螢幕 -\u0026gt;  顯示設定 -\u0026gt; 全域縮放比例 -\u0026gt; 125% 組合器 -\u0026gt;  縮放方式：平滑 成像後端介面：OpenGL 3.1 Latency：Prefer smoother animations       更換系統主題  系統設定 -\u0026gt; 外觀 -\u0026gt;  Global Theme -\u0026gt; 取得新全域主題 -\u0026gt; Layan look and feel theme Icons -\u0026gt; 取得新圖示 -\u0026gt; Tela dark     更換桌布  在桌面右鍵 -\u0026gt; Configure Desktop and Wallpaper\u0026hellip; -\u0026gt; 桌布 -\u0026gt; 取得新桌布\u0026hellip; -\u0026gt; 桌布型態：影像 -\u0026gt; HD NO LOGO PL1591   Konsole 美化  設定 -\u0026gt;  顯示工具列 -\u0026gt; 取消 主工具列、Session Toolbar 的勾選 編輯目前設定檔 -\u0026gt; 外觀 -\u0026gt; 配色與字形 -\u0026gt; 取得更多 -\u0026gt; Sweet      ","date":"2021-08-11T21:55:25+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-03/","title":"Arch Linux-03：KDE"},{"content":"前言  在 Arch Linux-01：系統安裝 中，已經介紹了如何完整的安裝一個基礎的 Arch Linux 系統，而這部分將去介紹一些基本的設定或是驅動的安裝。\n教學開始 新增使用者  由於不應該一直使用 root 帳號，因此我們來新增一個使用者吧。   新增使用者：useradd -m \u0026lt;user\u0026gt; ( \u0026lt;user\u0026gt; 為你要新增的用戶名稱，請自行更改 ) 設置密碼：passwd \u0026lt;user\u0026gt;  Sudo  Sudo Wiki 安裝：pacman -S sudo 將使用者加入：usermod -aG wheel \u0026lt;user\u0026gt; 使用 visudo  由於預設使用 vi，但我們之前是用安裝 vim，因此臨時的更改它吧：EDITOR=vim visudo 進去後，找到 %wheel ALL=(ALL) ALL 這行，然後消掉註解並且儲存離開。    Xorg  Xorg Wiki 安裝 ：pacman -S xorg-server 驅動安裝  查看顯卡類型：lspci -v | grep -A1 -e VGA -e 3D 安裝對應驅動，請依照情況自行更改 以下為我的筆電的安裝方式 (參考至此文章) 開啟 multilib 倉庫：vim /etc/pacman.conf  找到下方兩行，並消掉註解 [multilib] Include = /etc/pacman.d/mirrorlist    安裝 mesa 包：pacman -S mesa lib32-mesa 若之前已安裝 xf86-video-intel，請卸載掉：pacman -Rsc xf86-video-intel nvidia 驅動：pacman -S nvidia lib32-nvidia-utils 安装 nvidia-prime：pacman -S nvidia-prime (Prime Wiki) 重新啟動：reboot    ","date":"2021-08-11T17:26:15+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-02/","title":"Arch Linux-02：基本設置"},{"content":"前言  在被吳文元朋朋洗腦、推坑、直銷 Arch Linux 的各種好之後，我終於也入坑了，而這一系列將紀錄整個的安裝過程，避免未來再踩一次坑。\n安裝設備  筆電：Zenbook 14 UX433FN 顯卡：  GPU0 Intel UHD 620 GPU1 Nvidia MX150    開始安裝  完整官方導覽：Installation guide  前置作業  製作開機碟  到 Arch Linux Download 下載映像檔 (.iso)  NCHC、NCTU   使用 Rufus 寫入隨身碟   壓縮磁碟區  由於我要在一塊已有 Windows 10 的硬碟上安裝 Arch linux，因此得來切磁區。\n  在 Windows 10 中開啟硬碟管理員 以壓縮磁碟區的方式創造出未分配的空間。    安裝系統  插上隨身碟，並以隨身碟開機 檢查硬碟、分配磁區  由於新手上路，這邊我們就分配單一磁區給 / 就好。 至於其他像是 [SWAP] 之類的，有需要就自行處理。\n  fdisk -l: 查看硬碟狀態 cfdisk /dev/nvme0n1 選擇硬碟(依照情況自行更改名稱)  進去後選取 Free space -\u0026gt; New -\u0026gt; 輸入 Size (例如: 200G) -\u0026gt; Write -\u0026gt; 輸入 yes -\u0026gt; Quit   格式化為 ext4 格式：mkfs.ext4 /dev/nvme0n1p5 選擇磁區(依照情況自行更改名稱)   掛載硬碟  掛載 root 分區：mount /dev/nvme0n1p5 /mnt 先創建 boot 資料夾：mkdir /mnt/boot 掛載 efi 分區：mount /dev/nvme0n1p1 /mnt/boot (依照情況自行更改名稱)  這邊我們選擇跟 Windows 10 共用 efi 分區     連接網路，以下為 Wifi 連接方式  輸入 iwctl 查詢設備：device list (以下依照情況自行更改名稱，這邊以 wlan0 為例) 掃描 wifi：station wlan0 scan 列出 wifi：station wlan0 get-networks 連接 wifi：station wlan0 connect Wifi-Name 有密碼的話輸入密碼 輸入 exit 離開 輸入 ping www.google.com 檢查是否連接成功   更新系統時間  timedatectl set-ntp true 可以執行 timedatectl status 檢查時間同步服務的狀態。   安裝必要的軟體包  必要：pacstrap /mnt base linux linux-firmware 依照需求安裝：pacstrap /mnt vim iwd man-db man-pages texinfo   配置系統   生成 fstab 文件\n genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 檢查生成的 fstab 文件：cat /mnt/etc/fstab    切換到裝好的系統：arch-chroot /mnt\n  設定時區：ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\n  同步硬體時鐘：hwclock --systohc\n  在地化\n vim /etc/locale.gen  取消註解 en_US.UTF-8 UTF-8、zh_TW.UTF-8 UTF-8   生成 locale 訊息：locale-gen vim /etc/locale.conf  添加設定：LANG=en_US.UTF-8      配置網路\n 創建 hostname 文件：vim /etc/hostname  輸入你要的名稱，例如：myhostname   修改 hosts：vim /etc/hosts，內容如下 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyhostname.localdomain\tmyhostname     設定 DHCP\n vim /etc/systemd/network/20-wired.network，內容如下  enp1s0 為網卡名稱，請用 ip a 自行查看更改  [Match] Name=enp1s0 [Network] DHCP=yes  啟用：systemctl enable --now systemd-networkd.service    啟用 DNS：systemctl enable --now systemd-resolved\n  修改 root 密碼：passwd\n   開機引導，這邊我們使用 systemd-boot  將 systemd-boot 安裝到 efi 分區：bootctl --path=/boot install 手動更新 systemd-boot：bootctl --path=/boot update 啟動選單配置  vim /boot/loader/loader.conf，內容如下 default arch-* # arch 那裡應為一字串不用更改 timeout 10 console-mode max editor no  vim /boot/loader/entries/arch.conf，內容如下  UUID 請自行填入，可於 /etc/fstab 中查看，請選擇 / 目錄的。  title Arch Linux linux /vmlinuz-linux initrd /initramfs-linux.img options root=\u0026quot;UUID=XXX-XXX-XXX\u0026quot; rw  cp /boot/loader/entries/arch.conf /boot/loader/entries/arch-fallback.conf vim /boot/loader/entries/arch-fallback.conf  將 /initramfs-linux.img 更改為 /initramfs-linux-fallback.img 即可       重新啟動  退出 chroot 環境：輸入 exit 或是按下 Ctrl+d 卸載分區：umount -R /mnt 重新啟動：reboot 記得重開時要移除隨身碟呀    補充  這台電腦進 BIOS 方法：按住 F2，再按電源，直到進入 BIOS 再放開 F2 在 BIOS 新增開機選項  Boot -\u0026gt; Add New Boot Option Add boot option：輸入選項名稱 Path for boot option：\\EFI\\systemd\\systemd-bootx64.efi Create -\u0026gt; Ok   開機選單消失問題：Windows_changes_boot_order 字體太小問題  HiDPI - Linux Console Linux_console - Fonts    ","date":"2021-08-11T13:50:32+08:00","permalink":"https://blog.smallten.tk/p/arch_linux-01/","title":"Arch Linux-01：系統安裝"},{"content":"主題  最小生成樹  MST 模板 Kruskal\u0026rsquo;s Algorithm  時間複雜度 O(ElogE)  struct edge { int u, v, w; bool operator \u0026lt; (const edge \u0026amp;r) const { return w \u0026lt; r.w; } }; int vn, en; // vertex num, edge num vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = x; } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int Kruskal() { for(int i = 0; i \u0026lt; vn; ++i) dsu.push_back(i); sort(ve.begin(), ve.end()); int cnt = 0, ans = 0; for(int i = 0; i \u0026lt; en \u0026amp;\u0026amp; cnt \u0026lt; vn; ++i) { if(Union(ve[i].u, ve[i].v)) { ans += ve[i].w; ++cnt; } } return ans; } Prim\u0026rsquo;s Algorithm  時間複雜度 O(VlogE)  struct edge { int idx, w; bool operator \u0026lt; (const edge \u0026amp;r) const { return w \u0026gt; r.w; } }; int prim() { int vn; // vertex num  vector\u0026lt;edge\u0026gt; adj[vn]; int ans = 0; priority_queue\u0026lt;edge\u0026gt; pq; vector\u0026lt;bool\u0026gt; vis(vn, false); vis[0] = true; for(auto v : adj[0]) pq.emplace(v); while(!pq.empty()) { edge mn = pq.top(); pq.pop(); if(vis[mn.idx]) continue; vis[mn.idx] = true; ans += mn.w; for(auto v : adj[mn.idx]) pq.emplace(v); } } 題目  Virtual Judge 題目列表與提示    題目 題目需求 難度     UVa 10034 給定平面上各點座標，求最小生成樹的邊權總和。(裸) 模板題   UVL 7001 讀懂題目的三項性質，便知道題意為求最小生成樹。 模板題   UVa 1208 讀懂題目便知題意。 模板題   UVa 10369 讀懂題目，自行思考和最小生成樹演算法的關係。 小變化   UVL 6437 讀懂題目，自行思考該作什麼樣的小修改。 小變化   UVa 534 讀懂題目，自行思考和最小生成樹演算法的關係。(最小瓶頸路) 經典變化   Uva 11733 讀懂題目，自行思考和最小生成樹演算法的關係。 小變化   Uva 1395 給定圖，對該圖所有生成樹計算最大邊權減最小邊權，輸出該差距之最小值。 小變化   Uva 1151 給定圖以及 q 組已知購買成本的子網路，問連通所有點的最小成本。 小變化      參考作法 A - Freckles #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n; struct Point { int group; double x, y; } p[105]; struct Line { int aIdx, bIdx; double len; }; double pD(const Point \u0026amp;a, const Point \u0026amp;b) { double dx = a.x - b.x, dy = a.y - b.y; return sqrt(dx * dx + dy * dy); } bool cmpLen(const Line \u0026amp;a, const Line \u0026amp;b) { return a.len \u0026lt; b.len; } bool isMSTEnd() { for(int i = 0; i \u0026lt; n - 1; ++i) if(p[i].group != p[i + 1].group) return false; return true; } void Union(int a, int b) { int minG = min(a, b); for(int i = 0; i \u0026lt; n; ++i) { if(p[i].group == a || p[i].group == b) p[i].group = minG; } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++i) { p[i].group = i; cin \u0026gt;\u0026gt; p[i].x \u0026gt;\u0026gt; p[i].y; } vector\u0026lt;Line\u0026gt; lines; for(int i = 0; i \u0026lt; n; ++i) { for(int j = i + 1; j \u0026lt; n; ++j) { lines.push_back({i, j, pD(p[i], p[j])}); } } sort(lines.begin(), lines.end(), cmpLen); double ans = 0.0; for(int i = 0; !isMSTEnd(); ++i) { if(p[lines[i].aIdx].group == p[lines[i].bIdx].group) continue; ans += lines[i].len; Union(p[lines[i].aIdx].group, p[lines[i].bIdx].group); } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; if(T) cout \u0026lt;\u0026lt; endl; } return 0; } B - Bus Problem #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n, m; long long sumO, sumM; vector\u0026lt;int\u0026gt; dsu; struct edge { int s, e, v; }; vector\u0026lt;edge\u0026gt; ve; bool cmp(const edge \u0026amp;a, const edge \u0026amp;b) { return a.v \u0026lt; b.v; } int Find(int x) { if(dsu[x] == x) return x; return dsu[x] = Find(dsu[x]); } int merge(int x, int y, int t) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; sumM += ve[t].v; } } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; sumO = sumM = 0; dsu.clear(); ve.clear(); for(int i = 0; i \u0026lt; m; ++i) { int a, b, d; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; d; ve.push_back({a, b, d}); sumO += d; } for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); sort(ve.begin(), ve.end(), cmp); for(int i = 0; i \u0026lt; m; ++i) { merge(ve[i].s, ve[i].e, i); } cout \u0026lt;\u0026lt; sumO - sumM \u0026lt;\u0026lt; endl; } return 0; } C - Oreon #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n; struct edge { int u, v, w; }; vector\u0026lt;edge\u0026gt; g; vector\u0026lt;int\u0026gt; dsu; bool cmp(const edge \u0026amp;a, const edge \u0026amp;b) { if(a.w == b.w){ if(a.u == b.u) return a.v \u0026lt; b.v; else return a.u \u0026lt; b.u; } return a.w \u0026lt; b.w; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  int T; cin \u0026gt;\u0026gt; T; for(int ca = 1; ca \u0026lt;= T; ++ca) { cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; \u0026#34;:\\n\u0026#34;; cin \u0026gt;\u0026gt; n; g.clear(); cin.ignore(100, \u0026#39;\\n\u0026#39;); for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { int t; char c; scanf(\u0026#34;%d%c\u0026#34;, \u0026amp;t, \u0026amp;c); if(i == j || t == 0) continue; g.push_back({i, j, t}); } } sort(g.begin(), g.end(), cmp); dsu.clear(); for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); int sz = g.size(); for(int i = 0; i \u0026lt; sz; ++i) { int a = Find(g[i].u), b = Find(g[i].v); if(a != b) { Union(a, b); cout \u0026lt;\u0026lt; (char)(\u0026#39;A\u0026#39; + g[i].u) \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; (char)(\u0026#39;A\u0026#39; + g[i].v) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; g[i].w \u0026lt;\u0026lt; endl; } } } return 0; } D - Arctic Network #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct Point { int x, y; }; vector\u0026lt;Point\u0026gt; vp; struct edge { int u, v; double len; }; vector\u0026lt;edge\u0026gt; ve; vector\u0026lt;int\u0026gt; dsu; bool cmpVE(const edge \u0026amp;a, const edge \u0026amp;b) { return a.len \u0026lt; b.len; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a == b)return false; dsu[a] = b; return true; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int s, p; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p; vp.clear(); ve.clear(); dsu.clear(); for(int i = 0; i \u0026lt; p; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; vp.push_back({x, y}); dsu.push_back(i); } for(int i = 0; i \u0026lt; p; ++i) { for(int j = i + 1; j \u0026lt; p; ++j) { int dx = vp[i].x - vp[j].x, dy = vp[i].y - vp[j].y; ve.push_back({i, j, sqrt(dx * dx + dy * dy)}); } } sort(ve.begin(), ve.end(), cmpVE); vector\u0026lt;double\u0026gt; ans; for(int i = 0; ans.size() \u0026lt; p - 1; ++i) { if(!Union(ve[i].u, ve[i].v)) continue; ans.push_back(ve[i].len); } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; ans[p - 1 - s] \u0026lt;\u0026lt; endl; } return 0; } E - Power Plant #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int x, y, z; } a[500010]; int fa[100010], n, m, k, ans, len = 0; bool vis[100010]; int getf(int x) { if (x == fa[x]) return x; return fa[x] = getf(fa[x]); } bool cmp(node x, node y) { return x.z \u0026lt; y.z; } int main() { int T, ll = 0;; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { memset(vis, 0, sizeof(vis)); ll++; len = ans = 0; int xx; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= k; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;xx), vis[xx] = 1; for (int i = 1; i \u0026lt;= m; i++) { ++len; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a[len].x, \u0026amp;a[len].y, \u0026amp;a[len].z); len++; a[len].x = a[len - 1].y; a[len].y = a[len - 1].x; a[len].z = a[len - 1].z; } for (int i = 1; i \u0026lt;= len; i++) { if (vis[a[i].x]) a[i].x = n + 1; if (vis[a[i].y]) a[i].y = n + 1; } sort(a + 1, a + len + 1, cmp); for (int i = 1; i \u0026lt;= n + 1; i++) fa[i] = i; int num = 0; for (int i = 1; i \u0026lt;= len; i++) { int x = getf(a[i].x), y = getf(a[i].y); if (x != y) { fa[x] = y; ans += a[i].z; num++; if (num == n) break; } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, ll, ans); } return 0; } F - Frogger #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int x, y; }; vector\u0026lt;node\u0026gt; vn; double dis[205][205]; int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int n, cnt = 1; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { vn.clear(); for(int i = 0; i \u0026lt; n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vn.push_back({a, b}); } for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { int dx = vn[i].x - vn[j].x, dy = vn[i].y - vn[j].y; dis[i][j] = sqrt(dx * dx + dy * dy); } } for(int k = 0; k \u0026lt; n; ++k) { for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { dis[i][j] = min(dis[i][j], max(dis[i][k], dis[k][j])); } } } cout \u0026lt;\u0026lt; \u0026#34;Scenario #\u0026#34; \u0026lt;\u0026lt; cnt++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Frog Distance = \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; dis[0][1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } return 0; } G - Airports #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int u, v, w; bool operator \u0026lt; (const node \u0026amp;r) const { return w \u0026lt; r.w; } }; vector\u0026lt;node\u0026gt; vn; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; for(int ca = 1; ca \u0026lt;= T; ++ca) { int n, m, cost; vn.clear(); dsu.clear(); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; cost; for(int i = 0; i \u0026lt;= n; ++i) dsu.push_back(i); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; vn.push_back({a, b, c}); } sort(vn.begin(), vn.end()); int sum = 0; for(int i = 0; i \u0026lt; m; ++i) { if(vn[i].w \u0026gt;= cost) continue; if(Union(vn[i].u, vn[i].v)) sum += vn[i].w; } int cnt = 0; for(int i = 1; i \u0026lt;= n; ++i) { if(i == dsu[i]) ++cnt; } cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; sum + cost*cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } H - Slim Span #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct node { int u, v, w; bool operator \u0026lt; (const node \u0026amp;r) const { return w \u0026lt; r.w; } }; vector\u0026lt;node\u0026gt; vn; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; (n || m)) { vn.clear(); for(int i = 0; i \u0026lt; m; ++i) { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; vn.push_back({a, b, c}); } sort(vn.begin(), vn.end()); int ans = INF; for(int i = 0; i \u0026lt; m; ++i) { dsu.clear(); for(int i = 0; i \u0026lt;= n; ++i) dsu.push_back(i); int cnt = n - 1; for(int j = i; j \u0026lt; m; ++j) { if(Union(vn[j].u, vn[j].v)) --cnt; if(cnt == 0) { ans = min(ans, vn[j].w - vn[i].w); break; } } } if(ans == INF) cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } I - Buy or Build #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct point { int x, y; }; struct buy { int m, ci; vector\u0026lt;int\u0026gt; a; }; struct node { int u, v, w; bool operator \u0026lt; (const node \u0026amp;r) const { return w \u0026lt; r.w; } }; vector\u0026lt;point\u0026gt; vp; vector\u0026lt;buy\u0026gt; vb; vector\u0026lt;node\u0026gt; vn, vt; vector\u0026lt;int\u0026gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) { dsu[a] = b; return true; } return false; } int ksu(int t, vector\u0026lt;node\u0026gt; \u0026amp;vn, vector\u0026lt;node\u0026gt; \u0026amp;used) { if(t == 1) return 0; int m = vn.size(), ans = 0; used.clear(); for(int i = 0; i \u0026lt; m; ++i) { if(Union(vn[i].u, vn[i].v)) { ans += vn[i].w; used.push_back(vn[i]); if(--t == 1) break; } } return ans; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { vp.clear(); vb.clear(); vn.clear(); dsu.clear(); int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; q; ++i) { buy tmp; cin \u0026gt;\u0026gt; tmp.m \u0026gt;\u0026gt; tmp.ci; for(int j = 0; j \u0026lt; tmp.m; ++j) { int t; cin \u0026gt;\u0026gt; t; tmp.a.push_back(t - 1); } vb.push_back(tmp); } for(int i = 0; i \u0026lt; n; ++i) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; vp.push_back({x, y}); } for(int i = 0; i \u0026lt; n; ++i) { for(int j = i + 1; j \u0026lt; n; ++j) { int dx = vp[i].x - vp[j].x, dy = vp[i].y - vp[j].y; vn.push_back({i, j, dx * dx + dy * dy}); } } sort(vn.begin(), vn.end()); for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); int ans = ksu(n, vn, vt); for(int mask = 0; mask \u0026lt; (1 \u0026lt;\u0026lt; q); ++mask) { dsu.clear(); for(int i = 0; i \u0026lt; n; ++i) dsu.push_back(i); int cnt = n, c = 0; for(int i = 0; i \u0026lt; q; ++i) { if(mask \u0026amp; (1 \u0026lt;\u0026lt; i)) { c += vb[i].ci; for(int j = 1; j \u0026lt; vb[i].a.size(); j++) { if(Union(vb[i].a[0], vb[i].a[j])) --cnt; } } } vector\u0026lt;node\u0026gt; vd; ans = min(ans, c + ksu(cnt, vt, vd)); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; if(T) cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-08-10T23:50:17+08:00","permalink":"https://blog.smallten.tk/p/star_coder-06/","title":"StarCoder2021暑訓：Week05"},{"content":"主題  動態規劃  經典背包模板 0/1 背包 \u0026amp; 無限背包 const int N = 100, W = 100000; int cost[N], weight[N], c[W + 1]; void knapsack(int n, int w) { memset(c, 0, sizeof(c)); for (int i = 0; i \u0026lt; n; ++i) for (int j = w; j - weight[i] \u0026gt;= 0; --j) // 0/1 背包  // for (int j = weight[i]; j \u0026lt;= w; ++j) 無限背包  c[j] = max(c[j], c[j - weight[i]] + cost[i]); cout \u0026lt;\u0026lt; \u0026#34;最高的價值為\u0026#34; \u0026lt;\u0026lt; c[w]; } 有限背包 const int N = 100, W = 100000; int cost[N], weight[N], number[N], c[W + 1]; void knapsack(int n, int w) { for (int i = 0; i \u0026lt; n; ++i) { int num = min(number[i], w / weight[i]); for (int k = 1; num \u0026gt; 0; k *= 2) { if (k \u0026gt; num) k = num; num -= k; for (int j = w; j \u0026gt;= weight[i] * k; --j) c[j] = max(c[j], c[j - weight[i] * k] + cost[i] * k); } } cout \u0026lt;\u0026lt; \u0026#34;最高的價值為\u0026#34; \u0026lt;\u0026lt; c[w]; } 經典零錢問題模板 int price[5] = {5, 2, 6, 11, 17}; bool c[1000+1]; //int c[1000+1]; void change(int m) { memset(c, false, sizeof(c)); c[0] = true; for (int i = 0; i \u0026lt; 5; ++i) for (int j = price[i]; j \u0026lt;= m; ++j) c[j] ||= c[j-price[i]]; // c[j] += c[j-price[i]];  if (c[m]) cout \u0026lt;\u0026lt; \u0026#34;湊得到\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;湊不到\u0026#34;; // cout \u0026lt;\u0026lt; \u0026#34;湊得價位\u0026#34; \u0026lt;\u0026lt; m;  // cout \u0026lt;\u0026lt; \u0026#34;湊法總共\u0026#34; \u0026lt;\u0026lt; c[m] \u0026lt;\u0026lt; \u0026#34;種\u0026#34;; } LIS 模板 DP const int N = 100; int s[N], length[N]; int LIS() { for (int i=0; i\u0026lt;N; i++) length[i] = 1; for (int i=0; i\u0026lt;N; i++) for (int j=0; j\u0026lt;i; j++) if (s[j] \u0026lt; s[i]) length[i] = max(length[i], length[j] + 1); int l = 0; for (int i=0; i\u0026lt;N; i++) l = max(l, length[i]); return l; } Robinson-Schensted-Knuth Algorithm  時間複雜度 O(NlogL) ， N 是序列長度， L 是 LIS 長度。  int LIS(vector\u0026lt;int\u0026gt;\u0026amp; s) { if (s.size() == 0) return 0; vector\u0026lt;int\u0026gt; v; v.push_back(s[0]); for (int i=1; i\u0026lt;s.size(); ++i) { int n = s[i]; if (n \u0026gt; v.back()) v.push_back(n); else *lower_bound(v.begin(), v.end(), n) = n; } return v.size(); } LCS 模板 DP const int N1 = 7, N2 = 5; int s1[N1+1] = {0, 2, 5, 7, 9, 3, 1, 2}; int s2[N2+1] = {0, 3, 5, 3, 2, 8}; int length[N1+1][N2+1]; int LCS() { for (int i=0; i\u0026lt;=N1; i++) length[i][0] = 0; for (int j=0; j\u0026lt;=N2; j++) length[0][j] = 0; for (int i=1; i\u0026lt;=N1; i++) for (int j=1; j\u0026lt;=N2; j++) if (s1[i] == s2[j]) length[i][j] = length[i-1][j-1] + 1; else length[i][j] = max(length[i-1][j], length[i][j-1]); return length[N1][N2]; } Hunt-Szymanski Algorithm  LCS 問題，化作 2D LIS 問題，再化作 1D LIS 問題，最後套用 Robinson-Schensted-Knuth Algorithm 。 排序所有數對，使用 Counting Sort 。掃描一遍 s2 ，把每個字元的位置紀錄下來。 較短的序列當作 s1 ，時間複雜度是 O(Klog(min(N,M)) + R) 。 K 是數對數目， N 和 M 是序列長度， R 是數字範圍。 K 至多是 NM ，最差情況下比先前的演算法還慢，平均情況下比先前的演算法快上許多。 R 源自 Counting Sort 。  int LCS(string \u0026amp;s1, string \u0026amp;s2) { vector\u0026lt;int\u0026gt; p[128]; // 假設字元範圍為 0 ~ 127  for (int i = 0; i \u0026lt; s2.size(); ++i) p[s2[i]].push_back(i); vector\u0026lt;int\u0026gt; v; v.push_back(-1); for (int i = 0; i \u0026lt; s1.size(); ++i) for (int j = p[s1[i]].size() - 1; j \u0026gt;= 0; --j) { int n = p[s1[i]][j]; if (n \u0026gt; v.back()) v.push_back(n); else *lower_bound(v.begin(), v.end(), n) = n; } return v.size() - 1; } 題目  Virtual Judge 題目列表與提示    題目 題目需求 採用演算法 難度 (for 新手)     UVa 10130 給物品價值和重量，給全家人每人最大負重，問全家能搬走的最高總價。 經典背包 易   UVa 357 給定幣值種類，問某一個金額存在幾種表示法。 經典零錢問題 易   UVa 10405 給兩個字串，問最長共同子字串。 裸 LCS 易   UVa 369 求 N 個中取 M 個數的總組合數。 組合數公式 易   UVa 10003 給一根棍子上的切斷點，每次切斷的成本為該段長度，問所有切斷點都切斷的最小成本。 區間 DP 易   UVa 103 給一堆 D 維的盒子，問這些盒子一個裝進一個，最多能裝多少個。 DAG 最短路/LIS 中   UVa 10534 一個 Wavio 序列含 2n+1 個數，前半嚴格遞增，後半嚴格遞減。求一個數列中的最長 Wavio 序列。 O(nlogn) LIS 難   UVa 10949 給兩個長度最多 20000 個字元的字串，求最長共同子字串。 因字串很長，需透過 LCS-\u0026gt;LIS 轉換，再用快速 LIS 解決。 難   UVa 10032 給一群人的體重，將他們分成兩群（人數最多差一個），並儘可能最小化兩群的體重和差距。 背包變化+狀態壓縮 \\(難^2\\)   UVa 104 給 n 種貨幣彼此間的匯率，找出一種匯率轉換順序能從中套利 1% 以上。 Floyd-Warshall \\(難^2\\)      參考作法 A - SuperSale #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, m, c[35], g, ans = 0; cin \u0026gt;\u0026gt; n; int p[n], w[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; p[i] \u0026gt;\u0026gt; w[i]; cin \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; g; memset(c, 0x00, sizeof(c)); for(int j = 0; j \u0026lt; n; ++j) { for(int k = g; k - w[j] \u0026gt;= 0; --k) { c[k] = max(c[k], c[k - w[j]] + p[j]); } } ans += c[g]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } B - Let Me Count The Ways #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int p[5] = {50, 25, 10, 5, 1}, n; long long c[30005]; while(cin \u0026gt;\u0026gt; n) { memset(c, 0, sizeof(c)); c[0] = 1; for(int i = 0; i \u0026lt; 5; ++i) { for(int j = p[i]; j \u0026lt;= n; ++j) { c[j] += c[j - p[i]]; } } if(c[n] == 1) cout \u0026lt;\u0026lt; \u0026#34;There is only 1 way to produce \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; cents change.\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;There are \u0026#34; \u0026lt;\u0026lt; c[n] \u0026lt;\u0026lt; \u0026#34; ways to produce \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; cents change.\\n\u0026#34;; } return 0; } C - Longest Common Subsequence #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); string s1, s2; while(getline(cin, s1)) { getline(cin, s2); int n1 = s1.length(), n2 = s2.length(); int dp[n1 + 1][n2 + 1]; for(int i = 0; i \u0026lt;= n1; ++i) dp[i][0] = 0; for(int i = 0; i \u0026lt;= n2; ++i) dp[0][i] = 0; for(int i = 0; i \u0026lt; n1; ++i) { for(int j = 0; j \u0026lt; n2; ++j) { if(s1[i] == s2[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); } } cout \u0026lt;\u0026lt; dp[n1][n2] \u0026lt;\u0026lt; endl; } return 0; } D - Combinations #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); long long c[105][105] = {0}; for(int i = 1 ; i \u0026lt;= 100 ; ++i) { for(int j = 1 ; j \u0026lt;= i ; ++j) { if(i == j) c[i][j] = 1; else c[i][j] = c[i - 1][j] * i / (i - j); } } int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; !(n == 0 \u0026amp;\u0026amp; m == 0)) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; things taken \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34; at a time is \u0026#34; \u0026lt;\u0026lt; c[n][m] \u0026lt;\u0026lt; \u0026#34; exactly.\\n\u0026#34;; return 0; } E - Cutting Sticks #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int len, n, c[55], dp[55][55]; while(cin \u0026gt;\u0026gt; len \u0026amp;\u0026amp; len) { cin \u0026gt;\u0026gt; n; c[0] = 0; c[++n] = len; memset(dp, 0, sizeof(dp)); for(int i = 1; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; c[i]; for(int w = 2; w \u0026lt;= n; ++w) { for(int l = 0; l \u0026lt; n - 1; ++l) { int r = l + w; if(r \u0026gt; n) break; dp[l][r] = INF; for(int m = l + 1; m \u0026lt; r; ++m) dp[l][r] = min(dp[l][m] + dp[m][r] + c[r] - c[l], dp[l][r]); } } cout \u0026lt;\u0026lt; \u0026#34;The minimum cutting is \u0026#34; \u0026lt;\u0026lt; dp[0][n] \u0026lt;\u0026lt; \u0026#34;.\\n\u0026#34;; } return 0; } F - Stacking Boxes #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 struct Box { int id; vector\u0026lt;int\u0026gt; len; }; bool boxcmp(const Box \u0026amp;a, const Box \u0026amp;b) { int sz = a.len.size(); for(int i = 0; i \u0026lt; sz; ++i) { if(a.len[i] \u0026lt; b.len[i]) return true; if(a.len[i] \u0026gt; b.len[i]) return false; } return true; } bool isContain(const Box \u0026amp;a, const Box \u0026amp;b) { int sz = a.len.size(); for(int i = 0; i \u0026lt; sz; ++i) { if(a.len[i] \u0026lt;= b.len[i]) return false; } return true; } void printBox(const vector\u0026lt;int\u0026gt; \u0026amp;prevNesting, const vector\u0026lt;Box\u0026gt; \u0026amp;box, int lastbox, bool printSpace) { if(lastbox == -1) return; printBox(prevNesting, box, prevNesting[lastbox], true); cout \u0026lt;\u0026lt; box[lastbox].id; if(printSpace) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int k, n; while(cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n) { vector\u0026lt;Box\u0026gt; box; for(int i = 0; i \u0026lt; k; ++i) { int t; vector\u0026lt;int\u0026gt; tmp; for(int j = 0; j \u0026lt; n; ++j) { cin \u0026gt;\u0026gt; t; tmp.push_back(t); } sort(tmp.begin(), tmp.end()); box.push_back({i + 1, tmp}); } sort(box.begin(), box.end(), boxcmp); vector\u0026lt;int\u0026gt; maxNesting(k, 1), prevNesting(k, -1); int maxLen = 1, lastbox = 0; for(int i = 0; i \u0026lt; k; ++i) { for(int j = 0; j \u0026lt; i; ++j) { if(isContain(box[i], box[j])) { if(maxNesting[j] + 1 \u0026gt; maxNesting[i]) { maxNesting[i] = maxNesting[j] + 1; prevNesting[i] = j; if(maxNesting[i] \u0026gt; maxLen) { maxLen = maxNesting[i]; lastbox = i; } } } } } cout \u0026lt;\u0026lt; maxLen \u0026lt;\u0026lt; endl; printBox(prevNesting, box, lastbox, false); cout \u0026lt;\u0026lt; endl; } return 0; } G - Wavio Sequence #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int n, a[10005], dpI[10005], dpD[10005]; void LIS() { if(n == 0) return; vector\u0026lt;int\u0026gt; v; v.push_back(a[0]); dpI[0] = 1; for(int i = 1; i \u0026lt; n; ++i) { if(a[i] \u0026gt; v.back()) v.push_back(a[i]); else *lower_bound(v.begin(), v.end(), a[i]) = a[i]; dpI[i] = v.size(); } } void LDS() { if(n == 0) return; vector\u0026lt;int\u0026gt; v; v.push_back(a[n - 1]); dpD[n - 1] = 1; for(int i = n - 2; i \u0026gt;= 0; --i) { if(a[i] \u0026gt; v.back()) v.push_back(a[i]); else *lower_bound(v.begin(), v.end(), a[i]) = a[i]; dpD[i] = v.size(); } } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); while(cin \u0026gt;\u0026gt; n) { memset(dpI, 0, sizeof(dpI)); memset(dpD, 0, sizeof(dpD)); for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; LIS(); LDS(); int ans = 1; for(int i = 0; i \u0026lt; n; ++i) ans = max(min(dpI[i], dpD[i]) * 2 - 1, ans); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } H - Kids in a Grid #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 string g[30]; int LCS(string \u0026amp;s1, string \u0026amp;s2) { vector\u0026lt;int\u0026gt; p[130]; for(int i = 0; i \u0026lt; s2.size(); ++i) p[s2[i]].push_back(i); vector\u0026lt;int\u0026gt; v; v.push_back(-1); for (int i = 0; i \u0026lt; s1.size(); ++i) { for (int j = p[s1[i]].size() - 1; j \u0026gt;= 0; --j) { int n = p[s1[i]][j]; if (n \u0026gt; v.back()) v.push_back(n); else *lower_bound(v.begin(), v.end(), n) = n; } } return v.size() - 1; } string getStr() { string s, path; int n, x, y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; cin.ignore(100, \u0026#39;\\n\u0026#39;); getline(cin, path); int curX = x - 1, curY = y - 1; s += g[curX][curY]; for(int i = 0; i \u0026lt; n; ++i) { if(path[i] == \u0026#39;N\u0026#39;) --curX; else if(path[i] == \u0026#39;E\u0026#39;) ++curY; else if(path[i] == \u0026#39;S\u0026#39;) ++curX; else if(path[i] == \u0026#39;W\u0026#39;) --curY; s += g[curX][curY]; } return s; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; ++i) { int row, col; cin \u0026gt;\u0026gt; row \u0026gt;\u0026gt; col; string str1, str2, tmp; for(int j = 0; j \u0026lt; row; ++j) cin \u0026gt;\u0026gt; g[j]; str1 = getStr(); str2 = getStr(); int len, len1 = str1.length(), len2 = str2.length(); if(len1 \u0026gt; len2) len = LCS(str2, str1); else len = LCS(str1, str2); cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; len1 - len \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; len2 - len \u0026lt;\u0026lt; endl; } return 0; } I - Tug of War #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 int f(vector\u0026lt;int\u0026gt; \u0026amp;w, int sum) { if(w.size() == 1) return 0; sort(w.begin(), w.end()); } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, w[105]; long long dp[22505]; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; long long sum = accumulate(w + 1, w + n + 1, 0LL); memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int i = 1; i \u0026lt;= n; ++i) { for(int j = sum / 2; j \u0026gt;= w[i]; j--) { dp[j] |= (dp[j - w[i]] \u0026lt;\u0026lt; 1); } } if(n \u0026amp; 1) { for(int i = sum / 2; i \u0026gt;= 0; --i) { long long flag1 = (1LL \u0026lt;\u0026lt; (n / 2)); long long flag2 = (1LL \u0026lt;\u0026lt; (n / 2 + 1)); if((dp[i]\u0026amp;flag1) || (dp[i]\u0026amp;flag2)) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum - i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; } } } else { for(int i = sum / 2; i \u0026gt;= 0; --i) { if(dp[i] \u0026amp; (1LL \u0026lt;\u0026lt; (n / 2))) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum - i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; } } } if(T) cout \u0026lt;\u0026lt; endl; } return 0; } J - Arbitrage #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 void printPath(vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; \u0026amp;paths, int t, int i, int j) { if(t == 0) { cout \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j + 1; return; } printPath(paths, t - 1, i, paths[t][i][j]); cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j + 1; } int main() { #ifndef ONLINE_JUDGE  freopen(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  USE_CPPIO(); int n; while(cin \u0026gt;\u0026gt; n) { vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; ct(n, vector\u0026lt;double\u0026gt;(n, 0)); for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; n; ++j) { if(i == j) ct[i][j] = 1; else cin \u0026gt;\u0026gt; ct[i][j]; } } vector\u0026lt;vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt;\u0026gt; values(n, vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt;(n, vector\u0026lt;double\u0026gt;(n))); vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; paths(n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(n, -1))); values[0] = ct; int item = -1, itemT = -1; for(int t = 1 ; t \u0026lt; n \u0026amp;\u0026amp; item == -1 ; ++t) { for(int i = 0 ; i \u0026lt; n \u0026amp;\u0026amp; item == -1 ; ++i) { for(int j = 0 ; j \u0026lt; n \u0026amp;\u0026amp; item == -1 ; ++j) { values[t][i][j] = -1.0; for(int k = 0 ; k \u0026lt; n ; ++k ) { double newRate = values[t - 1][i][k] * ct[k][j]; if(newRate \u0026gt; values[t][i][j]) { values[t][i][j] = newRate; paths[t][i][j] = k; } } } if(values[t][i][i] \u0026gt; 1.01) { item = i; itemT = t; break; } } } if(item == -1) cout \u0026lt;\u0026lt; \u0026#34;no arbitrage sequence exists\\n\u0026#34;; else { printPath(paths, itemT, item, item); cout \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2021-08-06T10:42:11+08:00","permalink":"https://blog.smallten.tk/p/star_coder-05/","title":"StarCoder2021暑訓：Week04"},{"content":"主題  圖、狀態搜尋、拓樸排序、尤拉路  題目  Virtual Judge 題目列表與提示    題目 題目需求 採用演算法 基本題     UVa 10004 無向圖的兩色著色問題 DFS/BFS 均可 V   UVa 10959 求無向無權圖上每一點和一指定點的最短距離 BFS V   UVa 572 求二維地圖上的連通塊數量 DFS/BFS 均可 V   UVa 441 給定 k 個數，由小到大列出所有包含其中 6 個數的遞增數列 DFS    UVa 567 求無向無權圖上指定兩點間的最短距離 BFS (或用後面會學到的 Floyd-Warshall 演算法) V   UVa 10926 給有向無環圖，求最大一棵樹的節點數減1 DFS/BFS 均可    SPOJ PT07Z 求數直徑（經典題） DFS/BFS 均可    UVa 10603 倒水問題（給三個水瓶，倒出指定水量） BFS 變型 (帶權最短路)    UVa 10305 給定 n 個工作的兩兩先後關係，輸出任一個合法的工作完成順序。 拓樸排序 V   UVa 1423 給定一數列中 Sij = a[i]+…+a[j] 的正負號，輸出一組符合正負號關係的數列。(有趣，值得思考！) 拓樸排序    UVa 302 給定一個無向圖和指定起點，列印尤拉路。 尤拉路    UVa 10441 給定一堆字串，問如何將它們頭尾相連串起來。 尤拉路       參考作法 A - Bicoloring #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; bool a[205][205]; int p[205]; bool dfs(int x, int n, int color) { if(p[x]) { if(p[x] != color) return false; else return true; } p[x] = color; bool ans = true; for(int i = x + 1; i \u0026lt; n; ++i) { if(a[x][i]) ans = dfs(i, n, (color == 1) ? 2 : 1); } return ans; } int main() { USE_CPPIO(); int n, e; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { cin \u0026gt;\u0026gt; e; memset(a, false, sizeof(a)); memset(p, 0x00, sizeof(p)); int u, v; for(int i = 0; i \u0026lt; e; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; a[u][v] = a[v][u] = true; } if(dfs(0, n, 1)) cout \u0026lt;\u0026lt; \u0026#34;BICOLORABLE.\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NOT BICOLORABLE.\\n\u0026#34;; } return 0; } B - The Party, Part I #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; bool a[1005][1005]; int d[1005], n, m; void bfs() { for(int i = 0; i \u0026lt; n; ++i) d[i] = n; d[0] = 0; queue\u0026lt;int\u0026gt; q; q.push(0); while (!q.empty()) { int now = q.front(); q.pop(); for(int i = 0; i \u0026lt; n; ++i) { if(a[now][i] \u0026amp;\u0026amp; d[i] \u0026gt; d[now] + 1) { d[i] = d[now] + 1; q.push(i); } } } } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { memset(a, false, sizeof(a)); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int u, v; for(int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; a[u][v] = a[v][u] = true; } bfs(); for(int i = 1; i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if(T) cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } C - Oil Deposits #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, m, ans; char g[105][105]; int d[8][2] = {{1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}, {0, 1}}; void dfs(int x, int y) { g[x][y] = \u0026#39;*\u0026#39;; for(int i = 0; i \u0026lt; 8; ++i) { int dx = x + d[i][0], dy = y + d[i][1]; if(dx \u0026gt;= 0 \u0026amp;\u0026amp; dx \u0026lt; n \u0026amp;\u0026amp; dy \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026lt; m \u0026amp;\u0026amp; g[dx][dy] == \u0026#39;@\u0026#39;) { dfs(dx, dy); } } } int main() { USE_CPPIO(); while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { ans = 0; string s; for(int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; s; for(int j = 0; j \u0026lt; m; ++j) g[i][j] = s[j]; } for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; m; ++j) { if(g[i][j] == \u0026#39;@\u0026#39;) { dfs(i, j); ++ans; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } D - Lotto #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, a[15], ans[15]; bool u[15]; void dfs(int x, int t) { if(t == 6) { for(int i = 0; i \u0026lt; 5; ++i) cout \u0026lt;\u0026lt; ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; ans[5] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } for(int i = x; i \u0026lt; n; ++i) { if(!u[i]) { u[i] = true; ans[t] = a[i]; dfs(i + 1, t + 1); u[i] = false; } } } int main() { USE_CPPIO(); int cnt = 0; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { if(cnt++) cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; memset(u, false, sizeof(u)); for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; dfs(0, 0); } return 0; } E - Risk #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int main() { int cnt = 0, g[21][21], n; while(cin \u0026gt;\u0026gt; n) { memset(g, INF, sizeof(g)); for(int i = 1; i \u0026lt;= 19; ++i) { int a; for(int j = 0; j \u0026lt; n; ++j) { cin \u0026gt;\u0026gt; a; g[i][a] = g[a][i] = 1; } if(i \u0026lt; 19) cin \u0026gt;\u0026gt; n; } for(int k = 1; k \u0026lt;= 20; ++k) { for(int i = 1; i \u0026lt;= 20; ++i) { for(int j = 1; j \u0026lt;= 20; ++j) { g[i][j] = min(g[i][j], g[i][k] + g[k][j]); } } } cout \u0026lt;\u0026lt; \u0026#34;Test Set #\u0026#34; \u0026lt;\u0026lt; ++cnt \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; printf(\u0026#34;%2d to %2d: %d\\n\u0026#34;, a, b, g[a][b]); } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } F - How Many Dependencies? #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, a[105]; vector\u0026lt;int\u0026gt; g[105]; int dfs(int x) { if(a[x] != -1) return a[x]; int t = 0; for(auto i : g[x]) t = max(t, dfs(i)); return a[x] = t + 1; } int main() { USE_CPPIO(); int n; while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { for(int i = 0; i \u0026lt; 105; ++i) g[i].clear(); memset(a, -1, sizeof(a)); for(int i = 1; i \u0026lt;= n; ++i) { int t, b; cin \u0026gt;\u0026gt; t; while(t--) { cin \u0026gt;\u0026gt; b; g[i].push_back(b); } } int ans = 1, most = 0; for(int i = 1; i \u0026lt;= n; ++i) { int t = dfs(i); if(t \u0026gt; most) { most = t; ans = i; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } G - Longest path in a tree #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, ans = 0; vector\u0026lt;int\u0026gt; g[10005]; bool vis[10005]; int dfs(int x, int y) { int ans1 = 0, ans2 = 0; for(auto i : g[x]) { if(i == y) continue; int t = dfs(i, x); if(t \u0026gt; ans1) { ans2 = ans1; ans1 = t; } else if(t \u0026gt; ans2) { ans2 = t; } } if(ans1 + ans2 \u0026gt; ans) ans = ans1 + ans2; return ans1 + 1; } int main() { USE_CPPIO(); cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); g[v].push_back(u); } dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } H - Fill #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; struct node { int v[3], dist; bool operator\u0026lt;(const node \u0026amp;r) const { return dist \u0026gt; r.dist; } }; int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { int cup[3], d, ans[205]; bool vis[205][205]; cin \u0026gt;\u0026gt; cup[0] \u0026gt;\u0026gt; cup[1] \u0026gt;\u0026gt; cup[2] \u0026gt;\u0026gt; d; memset(vis, false, sizeof(vis)); memset(ans, -1, sizeof(ans)); priority_queue\u0026lt;node\u0026gt; pq; pq.push({0, 0, cup[2], 0}); vis[0][0] = true; while(!pq.empty()) { node now = pq.top(); pq.pop(); for(int i = 0; i \u0026lt; 3; ++i) { int t = now.v[i]; if(ans[t] \u0026lt; 0 || now.dist \u0026lt; ans[t]) ans[t] = now.dist; } if(ans[d] \u0026gt; 0) break; for(int i = 0; i \u0026lt; 3; ++i) { for(int j = 0; j \u0026lt; 3; ++j) { if(i != j) { if(now.v[i] == 0 || now.v[j] == cup[j]) continue; int amount = min(cup[j], now.v[i] + now.v[j]) - now.v[j]; node tmp = now; tmp.dist = now.dist + amount; tmp.v[i] -= amount; tmp.v[j] += amount; if(!vis[tmp.v[0]][tmp.v[1]]) { vis[tmp.v[0]][tmp.v[1]] = true; pq.push(tmp); } } } } } while(d \u0026gt;= 0) { if(ans[d] \u0026gt;= 0) { cout \u0026lt;\u0026lt; ans[d] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; break; } --d; } } return 0; } I - Ordering Tasks #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int main() { USE_CPPIO(); int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { if(n == 0 \u0026amp;\u0026amp; m == 0) break; int indeg[105] = {0}, cnt = 0; vector\u0026lt;int\u0026gt; g[101]; for(int i = 0; i \u0026lt; m; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); ++indeg[v]; } for(int i = 1; i \u0026lt;= n; ++i) { if(indeg[i] == 0) { if(cnt \u0026lt; n) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++cnt; indeg[i] = -1; for(auto j : g[i]) --indeg[j]; } if(cnt == n) break; else if(i == n) i = 0; } cout \u0026lt;\u0026lt; endl; } return 0; } J - Guess #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, indeg[15], a[15]; string s; vector\u0026lt;int\u0026gt; g[15]; void addEdge(int u, int v) { ++indeg[v]; g[u].push_back(v); } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; memset(indeg, 0, sizeof(indeg)); for(int i = 0; i \u0026lt;= n; ++i) g[i].clear(); int pos = 0; for(int i = 0; i \u0026lt;= n; ++i) { for(int j = i + 1; j \u0026lt;= n; ++j) { if(s[pos] == \u0026#39;+\u0026#39;) addEdge(i, j); else if(s[pos] == \u0026#39;-\u0026#39;) addEdge(j, i); ++pos; } } int d = 0; queue\u0026lt;int\u0026gt; q; for(int i = 0; i \u0026lt;= n; ++i) if(indeg[i] == 0) q.push(i); while(!q.empty()) { int sz = q.size(); for(int i = 0; i \u0026lt; sz; ++i) { int f = q.front(); q.pop(); a[f] = d; for(auto j : g[f]) { --indeg[j]; if(indeg[j] == 0) q.push(j); } } ++d; } for(int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt; a[i] - a[i - 1] \u0026lt;\u0026lt; \u0026#34; \\n\u0026#34;[i == n]; } return 0; } K - John\u0026rsquo;s trip #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int g[50][2010], cnt[50], nRoads, nPoints, start; bool vis[2010]; stack\u0026lt;int\u0026gt; st; void init() { nRoads = nPoints = 0; while(!st.empty()) st.pop(); memset(g, 0, sizeof(g)); memset(cnt, 0, sizeof(cnt)); memset(vis, false, sizeof(vis)); } void euler(int u) { for(int v = 1; v \u0026lt;= nRoads; ++v) { if(!vis[v] \u0026amp;\u0026amp; g[u][v]) { vis[v] = true; euler(g[u][v]); st.push(v); } } } void solve() { bool flag = false; for(int i = 1; i \u0026lt; 50; ++i) { if(cnt[i] % 2) { flag = true; break; } } if(flag) cout \u0026lt;\u0026lt; \u0026#34;Round trip does not exist.\\n\u0026#34;; else { euler(start); bool ff = false; while(!st.empty()) { if(ff) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; st.top(); st.pop(); ff = true; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { USE_CPPIO(); int x, y, z, t = 0; bool flag = false; init(); while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { ++t; if(x == 0 \u0026amp;\u0026amp; y == 0) { if(flag) break; flag = true; t = 0; solve(); init(); continue; } flag = false; cin \u0026gt;\u0026gt; z; if(t == 1) start = min(x, y); nRoads = max(nRoads, z); nPoints = max(nPoints, max(x, y)); g[x][z] = y; g[y][z] = x; ++cnt[x]; ++cnt[y]; } return 0; } L - Catenyms #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) #define INF 0x3f3f3f3f #define NINF 0xc0c0c0c0 using namespace std; int n, dsu[26], cnt, tot, indeg[26], outdeg[26]; bool vis[26], used[26][1005]; vector\u0026lt;string\u0026gt; g[26], ans; void init() { cnt = 1, tot = 0; memset(indeg, 0, sizeof(indeg)); memset(outdeg, 0, sizeof(outdeg)); memset(vis, false, sizeof(vis)); memset(used, false, sizeof(used)); for(int i = 0; i \u0026lt; 26; ++i) { g[i].clear(); dsu[i] = i; } ans.clear(); } int Find(int x) { if(dsu[x] == x) return x; return dsu[x] = Find(dsu[x]); } void euler(int u) { for(int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i][g[u][i].length() - 1] - \u0026#39;a\u0026#39;; if(!used[u][i]) { used[u][i] = true; euler(v); ans.push_back(g[u][i]); } } } bool solve() { if(cnt != tot) return false; int t = INF, odd = 0, q; for(int i = 0; i \u0026lt; 26; ++i) { if(g[i].size()) t = min(t, i); if(outdeg[i] - indeg[i] == 1) { ++odd; q = i; } else if(indeg[i] - outdeg[i] == 1) ++odd; else if(indeg[i] != outdeg[i]) return false; if(odd \u0026gt; 2) return false; } if(!odd) euler(t); else euler(q); for(int i = ans.size() - 1; i \u0026gt; 0; --i) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; cout \u0026lt;\u0026lt; ans[0] \u0026lt;\u0026lt; endl; return true; } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { init(); cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++i) { string s; cin \u0026gt;\u0026gt; s; int u = s[0] - \u0026#39;a\u0026#39;, v = s[s.length() - 1] - \u0026#39;a\u0026#39;; if(!vis[u]) { vis[u] = true; ++tot; } if(!vis[v]) { vis[v] = true; ++tot; } ++indeg[v]; ++outdeg[u]; g[u].push_back(s); int x = Find(u), y = Find(v); if(x != y) { dsu[x] = y; ++cnt; } } for(int i = 0; i \u0026lt; 26; ++i) sort(g[i].begin(), g[i].end()); if(!solve()) cout \u0026lt;\u0026lt; \u0026#34;***\\n\u0026#34;; } return 0; } ","date":"2021-07-28T05:48:25+08:00","permalink":"https://blog.smallten.tk/p/star_coder-04/","title":"StarCoder2021暑訓：Week03"},{"content":" 下載 NPS Clients，並放到一個資料夾中。 下載 pkg2Zip，並將 pkg2zip.exe 放到同一個資料夾中。 執行 NPS_Browser.exe。 複製以下連結：  Games  PSV tsv http://nopaystation.com/tsv/PSV_GAMES.tsv PSM tsv http://nopaystation.com/tsv/PSM_GAMES.tsv PSX tsv http://nopaystation.com/tsv/PSX_GAMES.tsv PSP tsv http://nopaystation.com/tsv/PSP_GAMES.tsv PS3 tsv http://nopaystation.com/tsv/PS3_GAMES.tsv   DLCs:  PSV tsv http://nopaystation.com/tsv/PSV_DLCS.tsv PSP tsv http://nopaystation.com/tsv/PSP_DLCS.tsv PS3 tsv http://nopaystation.com/tsv/PS3_DLCS.tsv   Themes:  PSV tsv http://nopaystation.com/tsv/PSV_THEMES.tsv     設定 Download and unpack dir: 檔案下載後的位置。 設定 Any pkg dec tool: 路徑為 pkg2Zip.exe 的位置。 設定 Your pkg dec params: -x {pkgFile} \u0026quot;{zRifKey}\u0026quot;。 設定 HMAC key for updates: E5E278AA1EE34082A088279C83F9BBC806821C52F2AB5D2B4ABD995450355114。 設定 CompPack URL: https://gitlab.com/nopaystation_repos/nps_compati_packs/raw/master/entries.txt 設定 CompPack Patch URL: https://gitlab.com/nopaystation_repos/nps_compati_packs/raw/master/entries_patch.txt 重新啟動 NPS Browser。 下載你要的檔案，並將其放進 PSV 對應路徑中。 進入 Vita Shell，按下三角形按鈕，選擇 Refresh LiveArea  ","date":"2021-07-26T11:50:17+08:00","permalink":"https://blog.smallten.tk/p/psv-03/","title":"PlayStation Vita-03：NoPayStation Browser"},{"content":" 在 PSV 執行 Vita Shell，然後按一下 Select 按鈕，最後以 USB 連接 PC。 下載 NoNpDrm，並將 nonpdrm.skprx 放進 tai 資料夾中。 回到 PSV 的 Vita Shell 中，並到達 ux0:tai/，選擇 config.txt。 找到並移到 *KERNEL 那行，按一下三角形按鈕，選 Insert empty line。 選擇下方新增的空白行，並輸入 ux0:tai/nonpdrm.skprx，然後儲存離開。 到設定中的 HENkaku 設置，選擇 重載 taiHEN config.txt。 重新啟動 PSV。  ","date":"2021-07-26T11:46:32+08:00","permalink":"https://blog.smallten.tk/p/psv-02/","title":"PlayStation Vita-02：NoNpDrm"},{"content":" 下載 Qcma 並安裝到電腦上。 PSV 以 USB 的方式連接到 PC。 下載 Final h-encore，然後將其解壓縮，最後執行它。 點擊 Let\u0026rsquo;s Go ，然後等到 100% 完成。 回到 PSV 的檔案管理 (Content Manager)，然後選擇複製內容(Copy Content) PC to PSV，之後 Applications \u0026gt; PS Vita，最後選 h-encore 2 再按 複製(Copy) \u0026gt; OK。 拔掉 USB，執行 PSV 桌面上的 h-encore 2。 PSV 記得要連網，然後選 Install HENkaku \u0026gt; Download VitaShell \u0026gt; Exit 到設定確認系統資訊，確認成功後，再去設定 HENkaku。   之後若有重開機的話，得重新進入 h-encore 2 再離開即可。\n ","date":"2021-07-26T11:04:05+08:00","permalink":"https://blog.smallten.tk/p/psv-01/","title":"PlayStation Vita-01：H-encore 2"},{"content":"主題  STL、併查集  併查集模板 int dsu[MAX_N]; void init(int num) { for(int i = 0; i \u0026lt;= num; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } 題目  Virtual Judge 題目列表與提示    題目 題目需求 採用結構 優先練習     UVa 673 括號匹配與 LIFO 操作 std::stack v   UVa 442 括號匹配與 LIFO 操作 std::stack    UVa 12100 遍歷和 FIFO 操作 std::queue (加上 std::priority_queue 效率更高) v   UVa 245 取出第 n 個以及插入頭端 std::list / std::deque / std::vector    UVa 1203 插入與取出最小值 std::priority_queue v   UVa 11995 模擬 stack, queue, priority_queue std::stack, std::queue, std::priority_queue v   UVa 10583 標準併查集操作 disjoint set v   UVa 11987 併查集的變化題(值得思考) disjoint set    UVa 1665 判斷連通塊數 disjoint set    UVa 230 字串排序與搜尋 std::map / std::set v   UVa 1592 字串比較（將字串轉成數值以加快比較） std::map       參考作法 A - Parentheses Balance #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; cin.ignore(100, \u0026#39;\\n\u0026#39;); while(n--) { string s; getline(cin, s); stack\u0026lt;char\u0026gt; st; for(auto \u0026amp;i : s) { if(i == \u0026#39;]\u0026#39;) { if(!st.empty() \u0026amp;\u0026amp; st.top() == \u0026#39;[\u0026#39;) st.pop(); else st.emplace(i); } else if(i == \u0026#39;)\u0026#39;) { if(!st.empty() \u0026amp;\u0026amp; st.top() == \u0026#39;(\u0026#39;) st.pop(); else st.emplace(i); } else st.emplace(i); } cout \u0026lt;\u0026lt; (st.empty() ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } B - Matrix Chain Multiplication #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; struct Matrix { int row, col; }; int main() { int n, errCnt = -1; cin \u0026gt;\u0026gt; n; map\u0026lt;char, Matrix\u0026gt; ma; for(int i = 0; i \u0026lt; n; ++i) { char name; Matrix m; cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; m.row \u0026gt;\u0026gt; m.col; ma[name] = m; } string s; while(cin \u0026gt;\u0026gt; s) { int multiCnt = 0; stack\u0026lt;Matrix\u0026gt; st; for(int i = 0; i \u0026lt; s.length(); ++i) { if(s[i] == \u0026#39;(\u0026#39;) continue; if(s[i] != \u0026#39;)\u0026#39;) { st.push(ma[s[i]]); continue; } Matrix b = st.top(); st.pop(); Matrix a = st.top(); st.pop(); if(a.col != b.row) { multiCnt = errCnt; break; } multiCnt += a.row * b.row * b.col; st.push({a.row, b.col}); } if(multiCnt == errCnt) cout \u0026lt;\u0026lt; \u0026#34;error\\n\u0026#34;; else cout \u0026lt;\u0026lt; multiCnt \u0026lt;\u0026lt; endl; } return 0; } C - Printer Queue #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; deque\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dq; int t[10] = {0}; for(int i = 0; i \u0026lt; n; ++i) { int a; cin \u0026gt;\u0026gt; a; dq.emplace_back(a, i); ++t[a]; } int cnt = 0; int lev, idx; while(true) { tie(lev, idx) = dq.front(); int canPop = 1; for(int i = lev + 1; i \u0026lt; 10; ++i) canPop \u0026amp;= (t[i] == 0); if(canPop) { ++cnt; --t[lev]; if(idx == m) break; dq.pop_front(); } else { dq.push_back(dq.front()); dq.pop_front(); } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } D - Uncompress #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { vector\u0026lt;string\u0026gt; vs; string buf; while (getline(cin, buf) \u0026amp;\u0026amp; buf[0] != \u0026#39;0\u0026#39;) { string s; for (int i = 0; buf[i]; ++ i) { if (isalpha(buf[i])) { s = \u0026#34;\u0026#34;; while (isalpha(buf[i])) s.insert(s.end(), buf[i ++]); vs.push_back(s); --i; cout \u0026lt;\u0026lt; s; } else if (isdigit(buf[i])) { int value = 0; while (isdigit(buf[i])) value = value * 10 + buf[i ++] - \u0026#39;0\u0026#39;; s = vs[vs.size() - value]; vs.erase(vs.end() - value); vs.push_back(s); --i; cout \u0026lt;\u0026lt; s; } else printf(\u0026#34;%c\u0026#34;, buf[i]); } puts(\u0026#34;\u0026#34;); } return 0; } E - Argus #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using tiii = tuple\u0026lt;int, int, int\u0026gt;; // time, query_num, period int main() { priority_queue\u0026lt;tiii, vector\u0026lt;tiii\u0026gt;, greater\u0026lt;tiii\u0026gt;\u0026gt; pq; string s; int q, p, cur, n; while(cin \u0026gt;\u0026gt; s \u0026amp;\u0026amp; s != \u0026#34;#\u0026#34; \u0026amp;\u0026amp; cin \u0026gt;\u0026gt; q \u0026gt;\u0026gt; p) pq.push(make_tuple(p, q, p)); cin \u0026gt;\u0026gt; n; while(n--) { tie(cur, q, p) = pq.top(); pq.pop(); cout \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pq.push(make_tuple(cur + p, q, p)); } return 0; } F - I Can Guess the Data Structure! #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int main() { USE_CPPIO(); int n; while(cin \u0026gt;\u0026gt; n) { bool flag[3]; memset(flag, true, sizeof(flag)); stack\u0026lt;int\u0026gt; st; queue\u0026lt;int\u0026gt; qu; priority_queue\u0026lt;int\u0026gt; pq; int a, b; for(int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(a == 1) { st.push(b); qu.push(b); pq.push(b); } else if(a == 2) { if(flag[0]) { if(!st.empty() \u0026amp;\u0026amp; st.top() == b) st.pop(); else flag[0] = false; } if(flag[1]) { if(!qu.empty() \u0026amp;\u0026amp; qu.front() == b) qu.pop(); else flag[1] = false; } if(flag[2]) { if(!pq.empty() \u0026amp;\u0026amp; pq.top() == b) pq.pop(); else flag[2] = false; } } } if((flag[0] \u0026amp;\u0026amp; flag[1])||(flag[1] \u0026amp;\u0026amp; flag[2])||(flag[2] \u0026amp;\u0026amp; flag[0])) cout\u0026lt;\u0026lt;\u0026#34;not sure\\n\u0026#34;; else if(flag[0]) cout\u0026lt;\u0026lt;\u0026#34;stack\\n\u0026#34;; else if(flag[1]) cout\u0026lt;\u0026lt;\u0026#34;queue\\n\u0026#34;; else if(flag[2]) cout\u0026lt;\u0026lt;\u0026#34;priority queue\\n\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;impossible\\n\u0026#34;; } return 0; } G - Ubiquitous Religions #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int dsu[50005]; void init(int n) { for(int i = 0; i \u0026lt; n; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x); int b = Find(y); if(a == b) return false; dsu[a] = b; return true; } int main() { USE_CPPIO(); int n, m, Case = 1; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { init(n); int cnt = n; for(int i = 0; i \u0026lt; m; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(Union(a - 1, b - 1)) --cnt; } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; Case++ \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } H - Almost Union-Find #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int dsu[200005], num[200005], sum[200005]; void init(int n) { for(int i = 0; i \u0026lt;= n; ++i) { dsu[i] = dsu[i + n] = i + n; sum[i] = sum[i + n] = i; num[i] = num[i + n] = 1; } } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } int main() { USE_CPPIO(); int n, m; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { init(n); for(int i = 0; i \u0026lt; m; ++i) { int t, a, b; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; a; if(t == 1) { cin \u0026gt;\u0026gt; b; int x = Find(a); int y = Find(b); if(x == y) continue; dsu[x] = y; num[y] += num[x]; sum[y] += sum[x]; } else if(t == 2) { cin \u0026gt;\u0026gt; b; int x = Find(a); int y = Find(b); if(x == y) continue; dsu[a] = y; --num[x]; ++num[y]; sum[x] -= a; sum[y] += a; } else if(t == 3) { int x = Find(a); cout \u0026lt;\u0026lt; num[x] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sum[x] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } return 0; } I - Islands #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; int n, m, total, dsu[1000010]; int dx[4] = {0, 0, 1, -1}; int dy[4] = {1, -1, 0, 0}; struct Point { int x, y, id, height; }; vector\u0026lt;Point\u0026gt; vp; bool cmp(Point a, Point b) { return a.height \u0026gt; b.height; } int Find(int t) { if(t == -1) return -1; if(dsu[t] == t) return t; return dsu[t] = Find(dsu[t]); } void add(int idx) { int id = vp[idx].id; dsu[id] = id; ++total; for(int i = 0; i \u0026lt; 4; ++i) { int x = vp[idx].x + dx[i]; int y = vp[idx].y + dy[i]; if(x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; m) { int id2 = x * m + y; int root_id2 = Find(id2); if(root_id2 == -1) continue; if(root_id2 != id) { --total; dsu[root_id2] = id; } } } } int main() { USE_CPPIO(); int T; cin \u0026gt;\u0026gt; T; while(T--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vp.clear(); vector\u0026lt;int\u0026gt; h; for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; j \u0026lt; m; ++j) { int t; cin \u0026gt;\u0026gt; t; Point p = {i, j, i * m + j, t}; vp.push_back(p); dsu[i * m + j] = -1; } } sort(vp.begin(), vp.end(), cmp); int q; cin \u0026gt;\u0026gt; q; for(int i = 0; i \u0026lt; q; ++i) { int t; cin \u0026gt;\u0026gt; t; h.push_back(t); } int idx = 0; total = 0; for(int i = h.size() - 1; i \u0026gt;= 0; --i) { while(idx \u0026lt; vp.size() \u0026amp;\u0026amp; h[i] \u0026lt; vp[idx].height) add(idx++); h[i] = total; } for(auto i : h) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } return 0; } J - Borrowers #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; map\u0026lt;string, string\u0026gt; mss; struct ReturnBook { string title; string author; }; bool cmp(string b1, string b2) { string a1 = mss[b1]; string a2 = mss[b2]; if(a1 != a2) return a1 \u0026lt; a2; return b1 \u0026lt; b2; } bool cmp_return(ReturnBook b1, ReturnBook b2) { if(b1.author != b2.author) return b1.author \u0026lt; b2.author; return b1.title \u0026lt; b2.title; } int main() { USE_CPPIO(); string s; vector\u0026lt;string\u0026gt; shelve; vector\u0026lt;ReturnBook\u0026gt; vRB; while(getline(cin, s)) { if(s == \u0026#34;END\u0026#34;) break; int idx = s.find(\u0026#34;\\\u0026#34;by\u0026#34;); string title = s.substr(0, idx + 1); string author = s.substr(idx + 4); mss[title] = author; shelve.push_back(title); } sort(shelve.begin(), shelve.end(), cmp); while(getline(cin, s)) { if(s == \u0026#34;END\u0026#34;) break; if(s == \u0026#34;SHELVE\u0026#34;) { sort(vRB.begin(), vRB.end(), cmp_return); for(int i = 0; i \u0026lt; vRB.size(); ++i) { auto it = lower_bound(shelve.begin(), shelve.end(), vRB[i].title, cmp); if(it == shelve.begin()) cout \u0026lt;\u0026lt; \u0026#34;Put \u0026#34; \u0026lt;\u0026lt; vRB[i].title \u0026lt;\u0026lt; \u0026#34; first\u0026#34; \u0026lt;\u0026lt; endl; else { int t = it - shelve.begin() - 1; cout \u0026lt;\u0026lt; \u0026#34;Put \u0026#34; \u0026lt;\u0026lt; vRB[i].title \u0026lt;\u0026lt; \u0026#34; after \u0026#34; \u0026lt;\u0026lt; shelve[t] \u0026lt;\u0026lt; endl; } shelve.insert(it, vRB[i].title); } vRB.clear(); cout \u0026lt;\u0026lt; \u0026#34;END\\n\u0026#34;; } else { int idx = s.find(\u0026#34;\\\u0026#34;\u0026#34;); string title = s.substr(idx); if(s[0] == \u0026#39;B\u0026#39;) { auto it = lower_bound(shelve.begin(), shelve.end(), title, cmp); shelve.erase(it); } else vRB.push_back({title, mss[title]}); } } return 0; } K - Database #include \u0026lt;bits/stdc++.h\u0026gt;#define USE_CPPIO() ios_base::sync_with_stdio(0); cin.tie(0) using namespace std; map\u0026lt;string, int\u0026gt; ID; int idx = 1; int StrID(string str) { if(ID[str]) return ID[str]; return ID[str] = idx++; } int main() { USE_CPPIO(); int row, col; while(cin \u0026gt;\u0026gt; row \u0026gt;\u0026gt; col) { cin.get(); int IDtable[row + 2][col + 2]; string table[row + 2][col + 2], tmp; for(int i = 1; i \u0026lt;= row; ++i) { getline(cin, tmp); char *pch = strtok((char*)tmp.c_str(), \u0026#34;,\u0026#34;); int j = 1; while(pch) { table[i][j++] = pch; pch = strtok(NULL, \u0026#34;,\u0026#34;); } } for(int i = 1; i \u0026lt;= row; ++i) { for(int j = 1; j \u0026lt;= col; ++j) { IDtable[i][j] = StrID(table[i][j]); } } bool flag = true; for(int i = 1; i \u0026lt;= col \u0026amp;\u0026amp; flag; ++i) { for(int j = i + 1; j \u0026lt;= col \u0026amp;\u0026amp; flag; ++j) { map\u0026lt;int, int\u0026gt; mii; for(int k = 1; k \u0026lt;= row \u0026amp;\u0026amp; flag; ++k) { int idx = IDtable[k][i] * 100000 + IDtable[k][j]; if(mii.count(idx)) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; mii[idx] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; flag = false; } else mii[idx] = k; } } } if(flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","date":"2021-07-24T08:26:57+08:00","permalink":"https://blog.smallten.tk/p/star_coder-03/","title":"StarCoder2021暑訓：Week02"},{"content":"前情提要  一開始時，學長們在 Messenger 的群組裡問有沒有人要參加這場新手向的 CTF 競賽，我是沒有選擇參加的 (因為我從來沒有深入的去玩、學習這方面的東東，可以算是個純正的小萌新~~)，然而到最後因為人數的關係學長們組成了兩隊，然後還能再多 2 個人，因此我也加入想說去見見世面也好。(其中還得感謝學長們的鼓勵，以及願意帶我這個什麼都不會的新手)😆😆\n競賽簡介  R2S CTF 競賽網站 Online Qualification : 7/16 - 18 Flag 樣式：R2S{}  成績  All: 7 / 81 Offical Only: 4 / 43      解題紀錄  以下是我解的題目，其他題目我無能為力，就只能看有沒有學長寫題解了(顆顆  Welcome  Welcome to R2S CTF o((\u0026gt;ω\u0026lt; ))o  在 R2S Discord 群組中的 challenge-announcement 頻道中，有黑黑的訊息要點開就能到 Flag 了。 一開始覺得很酷，事後知道了這叫暴雷標籤 ||暴雷訊息||。    Forensics  Headache  這題依照 CRC32 找出圖片的長寬，並用 hex editor 把 png 的 header 改成正確的就行了。    Crypto  Base1024  這題將那堆 emoji 解碼後就得到 Flag 了。 ecoji、ecoji 線上工具   BiGGG_RSA  一開始不知道怎麼分解 N，對於 Factordb 來說也太大了，解不出來。之後到了這個 primefac-fork，再寫個簡單的程式就解決了。   Seeeeed  也是 RSA 相關題。    Misc  Time Traveler  nc time-traveler.misc.quals.r2s.tw 5487 依照格式輸入並計算一下，弄到 1937 年就有 Flag 了。   Fat7z  依照給的 code 反著寫，就能得到 Flag 了。    Reverse  What is this!?  JavaSript aaencode 將言文字轉回 js，再執行裡面的 function 就行了。    Web  Chatroom  chatroom 一樣是 JavaSript aaencode 複製下來，F12 丟 console，Flag 就噴出來了。    心得  這次是我第一次參加 CTF 相關的競賽，雖然幾乎都不太會寫，主要的題目還都是學長們解開的，但這場比賽中我依然學到了不少新的技巧，也對 CTF 有了更多的興趣，未來繼續努力吧!\n","date":"2021-07-19T14:03:54+08:00","permalink":"https://blog.smallten.tk/p/experience-01/","title":"2021 R2S CTF"},{"content":"主題  搜尋、排序、貪心  題目  Virtual Judge  參考作法 A - Flip Sort  題目說明：  給一堆數字，輸出要交換(只能相鄰交換)多少次，才能由小到大排好。   解題思路：  Bubble sort   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, a[1005]; while(cin \u0026gt;\u0026gt; n) { int ans = 0; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; for(int i = 0; i \u0026lt; n; ++i) { for(int j = n - 1; j \u0026gt; i; --j) { if(a[j] \u0026lt; a[j - 1]) { swap(a[j], a[j - 1]); ++ans; } } } cout \u0026lt;\u0026lt; \u0026#34;Minimum exchange operations : \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; }   B - Age Sort  題目說明：  給一堆數字，由小到大排序。   解題思路：  std::sort() 小心 Presentation error   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); int n; bool flag; while (cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { int a[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); flag = false; for(auto i : a) { if(flag) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; i; flag = true; } cout \u0026lt;\u0026lt; endl; } return 0; }   C - Conformity  題目說明：  輸出最多人選擇課的程組合的人數，若是最多的有多個，將人數相加。   解題思路：  將每行的課程排序後，再丟入 map 中統計。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { int maxNum = 0, total = 0; map\u0026lt;string, int\u0026gt; msi; vector\u0026lt;string\u0026gt; vs; string input, line; while(n--) { line.clear(); vs.clear(); for(int i = 0; i \u0026lt; 5; ++i) { cin \u0026gt;\u0026gt; input; vs.push_back(input); } sort(vs.begin(), vs.end()); for(int i = 0; i \u0026lt; 5; ++i) line += vs[i]; ++msi[line]; } for(auto it = msi.begin(); it != msi.end(); ++it) if(it-\u0026gt;second \u0026gt; maxNum) maxNum = it -\u0026gt; second; for(auto it = msi.begin(); it != msi.end(); ++it) if(it-\u0026gt;second == maxNum) total += maxNum; cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; endl; } return 0; }   D - Guessing Game  題目說明：  依照題目模擬，看有沒有說謊。   解題思路：  模擬操作，最後看 right on 的值有沒有在區間中。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n; while(scanf(\u0026#34;%d \u0026#34;, \u0026amp;n) != EOF \u0026amp;\u0026amp; n != 0) { int s = 1, e = 10; string str; while(getline(cin, str) \u0026amp;\u0026amp; str != \u0026#34;right on\u0026#34;) { if(str == \u0026#34;too high\u0026#34;) e = min(e, n - 1); else if(str == \u0026#34;too low\u0026#34;) s = max(s, n + 1); scanf(\u0026#34;%d \u0026#34;, \u0026amp;n); } if(n \u0026gt;= s \u0026amp;\u0026amp; n \u0026lt;= e) cout \u0026lt;\u0026lt; \u0026#34;Stan may be honest\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Stan is dishonest\\n\u0026#34;; } return 0; }   E - Ancient Cipher  題目說明：  判斷第一行字串能不能依照題目的轉換方式變成第二行字串。   解題思路：  先紀錄彼此字母出現的次數並排序，再比對排序後數值是否相同即可。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { string s1, s2; while(cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2) { int a[26] = {0}, b[26] = {0}; for(auto i : s1) ++a[i - \u0026#39;A\u0026#39;]; for(auto i : s2) ++b[i - \u0026#39;A\u0026#39;]; sort(a, a + 26); sort(b, b + 26); bool flag = true; for(int i = 0; i \u0026lt; 26; ++i) { if(a[i] != b[i]) { cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; flag = false; break; } } if(flag) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; } return 0; }   F - Bridge Hands  題目說明：  依照給定方位的下一個人開始給牌，最後輸出要依照順序排列。   解題思路：  就模擬發牌並排序吧。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using pcc = pair\u0026lt;char, char\u0026gt;; char c; vector\u0026lt;pcc\u0026gt; v[4]; bool cmp(pcc a, pcc b) { int ta[2], tb[2]; char cc[4] = {\u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;H\u0026#39;}; char ct[13] = {\u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;A\u0026#39;}; for(int i = 0; i \u0026lt; 4; ++i) { if(a.first == cc[i]) ta[0] = i; if(b.first == cc[i]) tb[0] = i; } for(int i = 0; i \u0026lt; 13; ++i) { if(a.second == ct[i]) ta[1] = i; if(b.second == ct[i]) tb[1] = i; } if(ta[0] \u0026lt; tb[0]) return true; else if(ta[0] \u0026gt; tb[0]) return false; else { if(ta[1] \u0026lt; tb[1]) return true; else return false; } } void sortCard() { for(int i = 0; i \u0026lt; 4; ++i) { sort(v[i].begin(), v[i].end(), cmp); } } void printCard() { char oc[4] = {\u0026#39;S\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;E\u0026#39;}; char cc[4] = {\u0026#39;N\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;W\u0026#39;}; int ic[4][4] = {{1, 2, 3, 0}, {0, 1, 2, 3}, {3, 0, 1, 2}, {2, 3, 0, 1}}; int t; for(int i = 0; i \u0026lt; 4; ++i) { if(cc[i] == c) { t = i; break; } } for(int i = 0; i \u0026lt; 4; ++i) { cout \u0026lt;\u0026lt; oc[i] \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; for(auto it : v[ic[t][i]]) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it.first \u0026lt;\u0026lt; it.second; cout \u0026lt;\u0026lt; endl; } } int main() { while(cin \u0026gt;\u0026gt; c \u0026amp;\u0026amp; c != \u0026#39;#\u0026#39;) { string s; int temp = 0; for(int i = 0; i \u0026lt; 4; ++i) v[i].clear(); for(int i = 0; i \u0026lt; 2; ++i) { cin \u0026gt;\u0026gt; s; int len = s.size(); for(int j = 0; j \u0026lt; len; j += 2) { v[temp % 4].push_back({s[j], s[j + 1]}); ++temp; } } sortCard(); printCard(); } return 0; }   G - Vito\u0026rsquo;s Family  題目說明：  選出一個數，並計算彼此距離和最小的值。   解題思路：  中位數算距離和。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n; cin \u0026gt;\u0026gt; n; int a[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); int mid = a[n / 2], ans = 0; for(int i = 0; i \u0026lt; n; ++i) ans += abs(a[i] - mid); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   H - Shoemaker\u0026rsquo;s Problem  題目說明：  找出能使罰金最少的工作順序。   解題思路：  貪心法 依照 (罰金 / 時間) 的值，大到小排序。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using pdi = pair\u0026lt;double, int\u0026gt;; bool cmp(pdi a, pdi b) { return a.first \u0026gt; b.first; } int main() { int T; cin \u0026gt;\u0026gt; T; while(T--) { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pdi\u0026gt; v; for(int i = 1; i \u0026lt;= n; ++i) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; v.push_back({(b * 1.0 / a), i}); } sort(v.begin(), v.end(), cmp); bool flag = false; for(auto it : v) { if(flag) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; it.second; flag = true; } cout \u0026lt;\u0026lt; endl; if(T) cout \u0026lt;\u0026lt; endl; } return 0; }   I - The Bus Driver Problem  題目說明：  公車工作安排，輸出雇主最少需要支付的加班費。   解題思路：  先依照早晚排序，頭尾配對(最大配最小)，最後計算加班費的金額。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main() { int n, d, r; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d \u0026gt;\u0026gt; r \u0026amp;\u0026amp; n \u0026amp;\u0026amp; d \u0026amp;\u0026amp; r) { int morning[n], night[n]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; morning[i]; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; night[i]; sort(morning, morning + n); sort(night, night + n); int ans = 0; for(int i = 0; i \u0026lt; n; ++i) { if(morning[i] + night[n - i - 1] \u0026gt; d) ans += ((morning[i] + night[n - i - 1] - d) * r); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   J - Watering Grass  題目說明：  計算最少需要多少個噴水頭才能覆蓋整個區域，若都不行輸出 -1。   解題思路：  先轉換成一維。 貪心法 區間覆蓋   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; using pdd = pair\u0026lt;double, double\u0026gt;; bool cmp(pdd a, pdd b) { if(a.first == b.first) return a.second \u0026gt; b.second; else return a.first \u0026lt; b.first; } int main() { int n; double l, w; while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l \u0026gt;\u0026gt; w) { w /= 2; double p, r; vector\u0026lt;pdd\u0026gt; v; for(int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; r; if(r \u0026gt; w) { double dd = sqrt(r * r - w * w); v.push_back({p - dd, p + dd}); } } sort(v.begin(), v.end(), cmp); int ans = 0; double right = 0.0; for(int i = 0; i \u0026lt; v.size(); ++i) { if(v[i].first \u0026gt; right) break; for(int j = i + 1; j \u0026lt; v.size() \u0026amp;\u0026amp; v[j].first \u0026lt;= right; ++j) { if(v[j].second \u0026gt; v[i].second) i = j; } ++ans; right = v[i].second; if(right \u0026gt;= l) break; } if(right \u0026gt;= l) cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } return 0; }   K - Ultra-QuickSort  題目說明：  輸出最少要交換的數量。   解題思路：  用 merge sort 求逆序數對。 大佬們要用 BIT 去解也行。   程式碼： #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; long long ans = 0; long long a[500005]; void mergeSort(long long *arr, int len) { if(len \u0026lt;= 1) return; int leftLen = len / 2, rightLen = len - leftLen; long long *leftArr = arr, *rightArr = arr + leftLen; mergeSort(leftArr, leftLen); mergeSort(rightArr, rightLen); static long long tmp[500005]; long long tmpLen = 0, l = 0, r = 0; while(l \u0026lt; leftLen \u0026amp;\u0026amp; r \u0026lt; rightLen) { if(leftArr[l] \u0026lt; rightArr[r]) tmp[tmpLen++] = leftArr[l++]; else { tmp[tmpLen++] = rightArr[r++]; ans += leftLen - l; } } while(l \u0026lt; leftLen) tmp[tmpLen++] = leftArr[l++]; while(r \u0026lt; rightLen) tmp[tmpLen++] = rightArr[r++]; for(int i = 0; i \u0026lt; tmpLen; ++i) arr[i] = tmp[i]; } int main() { int n; while(cin \u0026gt;\u0026gt; n \u0026amp;\u0026amp; n) { ans = 0; for(int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; mergeSort(a, n); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   ","date":"2021-07-15T00:07:54+08:00","permalink":"https://blog.smallten.tk/p/star_coder-02/","title":"StarCoder2021暑訓：Week01"},{"content":"簡介    週次 主題 題目     一 搜尋、排序、貪心 Link   二 STL、併查集 Link   三 圖、狀態搜尋、拓樸排序、尤拉路 Link   四 動態規劃 Link   五 最小生成樹 Link   六 最短路徑 Link    學習資源 第一週 - 搜尋、排序、貪心  線上教材    教材 說明     師大碼賽客：排序/貪心/二分搜 子緯學長的教學講義（詳盡的新手入門）   北一女培訓：排序 六種排序法的程式與簡介   建中培訓 (第4/6/7節) 4.排序STL/6.貪心/7.二分搜   台大資訊之芽：貪心 貪心法與理論/Huffman Tree   成大競程培訓 (單元5/6) 5.二分搜/6.三種排序     線上影片    影片 說明     台大孔令傑老師：二分搜尋法 7 分鐘學會二分搜尋法   看舞蹈學排序法 以舞蹈呈現各種排序法的運作過程   台大陳縕儂老師：貪心 50 分鐘的正規演算法課程 (CLRS課本)     演算法視覺化    演算法      線性搜尋與二分搜尋 以動畫呈現兩種搜尋法的運作過程   排序 以動畫呈現六種排序演算法的運作過程      第二週 - STL、併查集  內容大綱    資料結構 簡要說明 C++ 內建     陣列 在記憶體中連續，支援隨機存取以及 O(1) 插入尾端 std::vector   字串 以 ‘\\0’ 結尾的字元陣列 std::string   串列 linked list 支援 O(1) 的插入與刪除 std::list   堆疊 stack 支援後進先出 (LIFO) 的存取模式 std::stack   佇列 queue 支援先進先出 (FIFO) 的存取模式 std::queue   堆積 heap (優先隊列 priority_queue) 支援 O(logN) 的插入和 O(logN) 取出最大/小值 std::priority_queue   併查集 disjoint set 有效率地合併兩個集合、有效率地查詢兩個元素是否屬於同一集合 無。模板   平衡搜尋樹 記錄 (鍵, 值) 對應關係，支援 O(logN) 的插入和查詢 std::map   平衡搜尋樹 實現「集合」，支援 O(logN) 的插入和查詢 std::set     線上教材    教材 說明     師大碼賽客：基礎資料結構/STL 品新學長的教學講義（詳盡的STL語法示範與題目解說）   板中培訓：STL STL語法   建中培訓 (第3節) STL語法   北一女培訓：樹/二元樹/Heap/BST 樹狀結構投影片   北一女培訓：併查集(disjoint set) 併查集投影片   成大競程培訓 (單元2/3/4) 資結/STL/樹/圖     演算法視覺化    資料結構 說明     堆積 (heap) 最小堆積的插入與取值動畫（圖形結構與陣列內容）：推薦！   併查集 併查集的 union/find 操作動畫（圖形結構與陣列內容）：推薦！      第三週 - 圖、狀態搜尋、拓樸排序、尤拉路  線上教材    教材 說明     師大碼賽客：狀態搜尋 仲軒學長的教學講義（手把手教學與題目解說）   師大碼賽客：基礎圖論 健愷學長的教學講義（有拓樸序和尤拉路）   台大資訊之芽：圖 圖的實作/搜尋/二分圖判定   建中培訓 (第 1/2/5 節) 第5節有拓樸排序   成大培訓 (單元 4)：圖/DFS/BFS 有一些練習題     線上影片    影片 說明     台大陳縕儂老師：圖 40 分鐘學圖的概念、實作與一筆畫問題   台大陳縕儂老師：BFS 60 分鐘（主要講證明）   台大陳縕儂老師：DFS/連通/拓樸排序 60 分鐘     演算法視覺化    演算法 說明     BFS 搭配樹狀圖/陣列實作/串列實作：推薦！   DFS 搭配樹狀圖/陣列實作/串列實作：推薦！   連通 (connected component) 搭配樹狀圖/陣列實作/串列實作   拓樸排序 搭配樹狀圖/陣列實作/串列實作      第四週 - 動態規劃  線上教材    教材 說明     師大碼賽客：基礎 DP 品新學長的教學講義（涵蓋重要經典題型與題解）   台大資訊之芽：DP 概念、LIS/LCS、零錢/背包 三段講義   成大培訓 (單元 9)：DP (背包/LIS/LCS) 有一些練習題   sa072686 的筆記 有很多習題與解答。     線上影片    影片 說明     台大陳縕儂老師：DP 概念 20 分鐘影片：以費氏數列解釋 DP 概念   台大陳縕儂老師：矩陣連乘 (區間 DP) 30 分鐘     演算法視覺化    演算法 說明     LIS O(n2) 程式步進動畫   LCS O(n2) 程式步進動畫   背包 O(NW) 程式步進動畫      第五週 - 最小生成樹  線上教材    教材 說明     師大碼賽客：MST 智鈞學長的教學講義與題解（本集也包含拓撲排序和尤拉路）   成大培訓 (單元 11)：Graph 速成、有一些練習題   演算法筆記：生成樹 師大資工最有名的個人網站XD     線上影片    影片 說明     資訊之芽：最小生成樹 30分鐘     演算法視覺化    演算法 說明     Kruskal’s 搭配樹狀圖/陣列實作/串列實作：推薦！   Kruskal’s 搭配程式碼   Prim’s 搭配樹狀圖/陣列實作/串列實作：推薦！   Prim’s 搭配程式碼      第六週 - 最短路徑  線上教材    教材 說明     師大碼賽客：最短路 品新學長的教學講義與題解   演算法筆記:路徑 Dijkstra’s、BellmanFord、Floyd-Warshall   成大培訓 (單元 11)：Graph 速成、有一些練習題     線上影片    影片 說明     台大陳縕儂老師：最短路 15分鐘簡介   台大陳縕儂老師：Bellman-Ford 30 分鐘介紹   台大陳縕儂老師：Dijkstra’s 20 分鐘介紹     演算法視覺化    演算法 說明     Dijkstra’s 搭配樹狀圖/陣列實作/串列實作：推薦！   Dijkstra’s 搭配程式碼   Bellman-Ford 搭配程式碼   Floyd-Warshall 搭配樹狀圖/陣列實作/串列實作：推薦！   Floyd-Warshall 搭配程式嗎      ","date":"2021-07-14T22:52:11+08:00","permalink":"https://blog.smallten.tk/p/star_coder-01/","title":"StarCoder2021暑訓"},{"content":" linuxlist.h  #pragma once  struct list_head { struct list_head *next, *prev; }; #define LIST_HEAD_INIT(name) { \u0026amp;(name), \u0026amp;(name) }  #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)  /* * Insert a new entry between two known consecutive entries. * * This is only for internal list manipulation where we know * the prev/next entries already! */ static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-\u0026gt;prev = new; new-\u0026gt;next = next; new-\u0026gt;prev = prev; prev-\u0026gt;next = new; } /** * list_add - add a new entry * @new: new entry to be added * @head: list head to add it after * * Insert a new entry after the specified head. * This is good for implementing stacks. */ static inline void list_add(struct list_head *new, struct list_head *head) { __list_add(new, head, head-\u0026gt;next); } /** * list_add_tail - add a new entry * @new: new entry to be added * @head: list head to add it before * * Insert a new entry before the specified head. * This is useful for implementing queues. */ static inline void list_add_tail(struct list_head *new, struct list_head *head) { __list_add(new, head-\u0026gt;prev, head); } /* * Delete a list entry by making the prev/next entries * point to each other. * * This is only for internal list manipulation where we know * the prev/next entries already! */ static inline void __list_del(struct list_head * prev, struct list_head * next) { next-\u0026gt;prev = prev; prev-\u0026gt;next = next; } /** * list_del - deletes entry from list. * @entry: the element to delete from the list. * Note: list_empty() on entry does not return true after this, the entry is * in an undefined state. */ static inline void __list_del_entry(struct list_head *entry) { if (entry == NULL) return; __list_del(entry-\u0026gt;prev, entry-\u0026gt;next); } static inline void list_del(struct list_head *entry) { __list_del_entry(entry); entry-\u0026gt;next = NULL; entry-\u0026gt;prev = NULL; } /** * list_empty - tests whether a list is empty * @head: the list to test. */ static inline int list_empty(const struct list_head *head) { return head -\u0026gt; next == head; } #define offsetof(TYPE, MEMBER) ((size_t)\u0026amp;((TYPE *)0)-\u0026gt;MEMBER)  #define container_of(ptr, type, member) ({\t\\ void *__mptr = (void *)(ptr);\t\\ ((type *)(__mptr - offsetof(type, member))); })  /** * list_entry - get the struct for this entry * @ptr:\tthe \u0026amp;struct list_head pointer. * @type:\tthe type of the struct this is embedded in. * @member:\tthe name of the list_head within the struct. */ #define list_entry(ptr, type, member) \\ container_of(ptr, type, member)  /** * list_first_entry - get the first element from a list * @ptr:\tthe list head to take the element from. * @type:\tthe type of the struct this is embedded in. * @member:\tthe name of the list_head within the struct. * * Note, that list is expected to be not empty. */ #define list_first_entry(ptr, type, member) \\ list_entry((ptr)-\u0026gt;next, type, member)  /** * list_last_entry - get the last element from a list * @ptr:\tthe list head to take the element from. * @type:\tthe type of the struct this is embedded in. * @member:\tthe name of the list_head within the struct. * * Note, that list is expected to be not empty. */ #define list_last_entry(ptr, type, member) \\ list_entry((ptr)-\u0026gt;prev, type, member)  /** * list_for_each\t-\titerate over a list * @pos:\tthe \u0026amp;struct list_head to use as a loop cursor. * @head:\tthe head for your list. */ #define list_for_each(pos, head) \\ for (pos = (head)-\u0026gt;next; pos != (head); pos = pos-\u0026gt;next)  /** * list_for_each_prev\t-\titerate over a list backwards * @pos:\tthe \u0026amp;struct list_head to use as a loop cursor. * @head:\tthe head for your list. */ #define list_for_each_prev(pos, head) \\ for (pos = (head)-\u0026gt;prev; pos != (head); pos = pos-\u0026gt;prev)  main.c  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;time.h\u0026gt;#include \u0026#34;linuxlist.h\u0026#34;typedef struct _sCharacter { int32_t id; char name[32]; int32_t hp; int32_t mp; int32_t exp; int32_t atk; int32_t def; int32_t ats; int32_t adf; int32_t spd; struct list_head list; } sCharacter; sCharacter *allocCharacter(int32_t id) { sCharacter *newComer = calloc(1, sizeof(sCharacter)); newComer-\u0026gt;id = id; newComer-\u0026gt;name[0] = rand() % 26 + \u0026#39;A\u0026#39;; for(int32_t j = 1 ; j \u0026lt; 6 ; j++) newComer-\u0026gt;name[j] = rand() % 26 + \u0026#39;a\u0026#39;; newComer-\u0026gt;hp = rand() % 100 + 1; newComer-\u0026gt;mp = rand() % 100 + 1; newComer-\u0026gt;exp = rand() % 100 + 1; newComer-\u0026gt;atk = rand() % 100 + 1; newComer-\u0026gt;def = rand() % 100 + 1; newComer-\u0026gt;ats = rand() % 100 + 1; newComer-\u0026gt;adf = rand() % 100 + 1; newComer-\u0026gt;spd = rand() % 100 + 1; return newComer; } void printCharacter(sCharacter *one) { printf(\u0026#34;%04d) \u0026#34;, one-\u0026gt;id); printf(\u0026#34;%8s \u0026#34;, one-\u0026gt;name); for(int32_t *ptr = \u0026amp;(one-\u0026gt;hp); ptr \u0026lt;= \u0026amp;(one-\u0026gt;spd); ptr++) printf(\u0026#34;%3d \u0026#34;, *ptr); printf(\u0026#34;\\n\u0026#34;); return; } int main() { LIST_HEAD(char_list_head); srand(time(0)); for(int32_t i = 0 ; i \u0026lt; 1000 ; i++) { sCharacter *newComer = allocCharacter(i + 1); list_add(\u0026amp;(newComer-\u0026gt;list), \u0026amp;char_list_head); } struct list_head *listptr = NULL; list_for_each(listptr, \u0026amp;char_list_head) { sCharacter *cptr = list_entry(listptr, sCharacter, list); printCharacter(cptr); } /* list_for_each_prev(listptr, \u0026amp;char_list_head) { sCharacter *cptr = list_entry(listptr, sCharacter, list); printCharacter(cptr); } */ return 0; } ","date":"2021-07-13T22:25:50+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-08/","title":"程式設計(二)-08：Linux List"},{"content":"Predefined Macros Standard Predefined Macros #include \u0026lt;stdio.h\u0026gt;int main() { printf(\u0026#34;line: %d \\n\u0026#34;, __LINE__); printf(\u0026#34;file: %s \\n\u0026#34;, __FILE__); printf(\u0026#34;function: %s \\n\u0026#34;, __FUNCTION__); // gcc  printf(\u0026#34;function: %s \\n\u0026#34;, __func__); // C99  printf(\u0026#34;time: %s \\n\u0026#34;, __TIME__); printf(\u0026#34;date: %s \\n\u0026#34;, __DATE__); printf(\u0026#34;STDC: %d \\n\u0026#34;, __STDC__); printf(\u0026#34;STDC_VERSION: %ld \\n\u0026#34;, __STDC_VERSION__); printf(\u0026#34;TIMESTAMP: %s \\n\u0026#34;, __TIMESTAMP__); return 0; }  我們可以怎麼使用這些 Macros ?  fprintf(stderr, \u0026quot;Internal␣error: at %s, line %d. ver %s %s\u0026quot;, __FILE__, __LINE__, __DATE__, __TIME__); Define when Compiling  gcc -D__DEBUG__ debug.c  #include \u0026lt;stdio.h\u0026gt;int main() { printf(\u0026#34;Hello World!!\\n\u0026#34;); #ifdef __DEBUG__  printf(\u0026#34;debug!!\\n\u0026#34;); #endif  return 0; }    Other GCC Predefined MACROs  Common Predefined Macros    Comparing Unsigned Integers  When comparisons between signed and unsigned integers, C will force the signed type to unsigned. C99 and C11 section 6.3.1.8. It is hard to debug since it looks so nature.  Call Functions at Program Termination atexit int atexit(void (*function)(void));\n Register a Function to be Called at Normal Process Termination The atexit() function registers the given function to be called at normal process termination, either via exit(3) or via return from the program’s main(). Functions so registered are called in the reverse order of their registration; no arguments are passed. The atexit() function returns the value 0 if successful; otherwise it returns a nonzero value.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void foo(void) { printf(\u0026#34;Goodbye Foo!\\n\u0026#34;); } void bar(void) { printf(\u0026#34;Goodbye Bar!\\n\u0026#34;); } int main(int argc, wchar_t* argv[]) { atexit(bar); atexit(foo); return 0; } system and more System: Execute a Shell Command int system(const char *command);\n The system() library function uses fork(2) to create a child process that executes the shell command specified in command. system() returns after the command has been completed.  fork  fork() creates a new process by duplicating the calling process. This is an important function. However, I will not talk too much about this function but you will learn more in System Programming.      system() is a blockingfunction. #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main() { system(\u0026#34;while true; do echo \u0026#39;Hit CTRL+C\u0026#39;; sleep 1; done\u0026#34;); return 0; }  The system() returns -1 means your system cannot fork another process instead of your command fails. You can try a command to delete a non-existing file.   Every system call is independent.  So you cannot setup an environment variable and hope other other system calls use this variable.    popen FILE *popen(const char *command, const char *type);\n The popen() function opens a process by creating a pipe, forking, and invoking the shell. The popen() function returns NULL if the fork(2) or pipe(2) calls fail, or if it cannot allocate memory. 別忘了使用 pclose.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;int main() { char buffer[512]; FILE *pPing = NULL; uint32_t counter = 0; pPing = popen(\u0026#34;ping -c 4 www.google.com\u0026#34;, \u0026#34;r\u0026#34;); if(pPing == NULL) { printf(\u0026#34;error end\\n\u0026#34;); exit(1); } while(fgets(buffer, 512, pPing)) { counter++; printf(\u0026#34;--- %d ---\\n\u0026#34;, counter); printf(\u0026#34;%s\u0026#34;, buffer); } pclose(pPing); return 0; } assert  In computer programming, an assertion is a statement that a predicate(Boolean-valued function, i.e. a true-false expression) is always true at that point in code execution. It can help a programmer read the code, help a compiler compile it, or help the program detect its own defects. If the assertion check is not in fact true, an assertion failure, the program considers itself to be brokenand typically deliberately crashes or throws an assertion failure exception.   void assert(scalar expression);\n The macro assert() prints an error message to standard error and terminates the program by calling abort(3) if expression is false. The purpose of this macro is to help programmers find bugs in their programs.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;assert.h\u0026gt;int main() { FILE *fd; fd = fopen (\u0026#34;file.txt\u0026#34;, \u0026#34;r\u0026#34;); assert (fd); fclose (fd); return 0; }  我可以簡單的使用 if-else 去確認並回傳值。那為什麼還要使用 assert?  這取決於您是否可以優雅地處理錯誤。   Note:  一般來說，assert 被用在開發階段。 當發佈時，請移除所有 assert。    qsort void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));\n The qsort() function sorts an array with nmemb elements of size size. The base argument points to the start of the array. The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second. If two members compare as equal, their order in the sorted array is undefined.  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int values[] = {88, 56, 100, 2, 25}; int cmpfunc (const void * a, const void * b) { return (*(int*)a - *(int*)b); } int main() { int n; printf(\u0026#34;Before sorting the list is:\u0026#34;); for(n = 0 ; n \u0026lt; 5; n++) printf(\u0026#34;%d \u0026#34;, values[n]); qsort(values, 5, sizeof(int), cmpfunc); printf(\u0026#34;After sorting the list is:\u0026#34;); for( n = 0 ; n \u0026lt; 5; n++ ) printf(\u0026#34;%d \u0026#34;, values[n]); return 0; } libcurl  安裝: sudo apt-get install libcurl4 libcurl4-openssl-dev 使用: Example codes 編譯: gcc -I curl-7.63.0/include -L curl-7.63.0/lib/.libs/ opendata.c -lcurl (需依照情況自行修改)  Makefile: CFLAGS = -O3 -Wall INCLUDE = -I curl-7.63.0/include LIB = -L curl-7.63.0/lib/.libs/ all: opendata.c gcc ${CFLAGS} ${INCLUDE} ${LIB} opendata.c -o opendata -lcurl clean: rm -f opendata     ","date":"2021-07-13T21:39:10+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-07/","title":"程式設計(二)-07：Some Tricks"},{"content":"Preprocessor 預處理器  在編譯器將您的源代碼編譯為組語前，還有一個稱為預處理的附加階段。 Objective: Produce a source code file with preprocessing commands properly sorted out.   Preprocessor commands are known as Directives. Preprocessor provides certain features, which are called preprocessor directives. Preprocessor directive 以 # 為開頭。(例如：#include \u0026lt;stdio.h\u0026gt;) Preprocessor directives 可以被放在程式中的任何地方。但建議放在開頭，並且每個必須獨立一行。   #include \u0026lt;stdio.h\u0026gt;#define MACRO_DEMO 123 int main() { printf(\u0026#34;demo:␣%d\\n\u0026#34;, MACRO_DEMO); return 0; }  以 gcc -E main.c 查看預處理後的狀態。  Macro 巨集  #define is known as macro expansion. General Form: #define macro_template macro_expansion  Macro Expansion  Preprocessor searches for macro definition. After finding macro definition, it searches the whole program for macro_template. Replaceevery macro_template with macro_expansion.  Replacement will not occur if the template is in a quoted string.   Notes:  通常 macro_template 會使用大寫字母 不要使用分號 ;      為什麼要用巨集?  為了寫出更高效率的程式。 提高程式的可讀性。 定義的巨集名稱可作為其他定義的一部分。   巨集可以像函式一樣擁有 arguments。 Notes：  在定義巨集時，參數和名稱之間不允許有空格。 Macro expansions 應該用括號括起來。 使用 \\ 將巨集拆分為多行。    Macro vs. Function Macro  單純替換 雖然你可能沒感覺，但比函式更快。  Function  傳遞參數 -\u0026gt; 執行 -\u0026gt; 回傳結果 支援遞迴  inline Functions  inline is a CPP keyword. C includes this keyword from C99. Though GNU C (and some other compilers) had inline functions long before standard C. Comparison:  inline is just a suggestion. inline will check types.   I will not talk too much about this keyword since it is different from CPP. I do not want to mislead you. If you are interested in this topic, please read here.  File Inclusion  Why File Inclusion?  Divide a program in multiple files.  Each file contains related functions. How to classify functions. Up to you.   Some functions or macros are required in lot of programs.  Put them in a file. Make them a library. Include them when you need them.     What does Inclusion Mean?  Nothing but simply copy and paste. Nested Inclusionis supported.    Conditional Compilation  Write one code to run on different environments.  #if: if. #else: else. #elif: else if. #endif: end if. #ifdef: if defined. #ifndef: if not defined.    ifdef and endif #ifdef macroname  statement sequence. #endif  如果 macroname 被定義了，那麼 #ifdef 和 #endif 之間的程式將被執行。 範例： #ifndef TEST_H #define TEST_H ... #endif  但也可用 #pragma once      gcc -D OS_LINUX os_dependent.c -D: Predefine name as a macro, with definition 1. So one code can be executed on different OSs. What you need to do is to build your code with different definitions. This is a very useful technique. Let’s see a real case (cJSON).    請自行去了解 # 及 ## 在巨集中的作用。  ","date":"2021-07-13T20:47:06+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-06/","title":"程式設計(二)-06：Macro"},{"content":"Program Argument argc, argv #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;int main(int argc, char *argv[]) { printf(\u0026#34;argc: %d\\n\u0026#34;, argc); for(int32_t i = 0 ; i \u0026lt; argc ; i++) printf(\u0026#34;argv[%d]: %s\\n\u0026#34;, i, argv[i]); return 0; }  誰呼叫了 main 函式? 誰提供了 argc 和 argv 到 main 函式? Is main() the actual starting entry point?  No! Actually, the process start from _start which is defined in crt1.o. 等等\u0026hellip; 我並沒有使用 crt1.o 呀! 實際上是有的。請查看 gcc -v $ nm /usr/lib/x86_64-linux-gnu/crt1.o   Simplified C Linking Process   main() 是如何取得 argc, argv 的?  Actually, _start will prepare argc and argv first. Then _start will register main function to __libc_start_main. _start will call __libc_start_main and __libc_start_main will call main. More details will be described in Assembly.    getopt int getopt(int argc, char * const argv[], const char *optstring);\n The getopt() function parses the command-line arguments. Its arguments argc and argv are the argument count and array as passed to the main() function on program invocation. An element of argv that starts with ’-’ (and is not exactly ”-” or ”–”) is an option element. The characters of this element (aside from the initial ’-’) are option characters. If getopt() is called repeatedly, it returns successively each of the option characters from each of the option elements. 提醒：這是一個 POSIX 標準而不是 C 標準。 extern 變數 extern char *optarg; extern int optind, opterr, optopt;  這意味著我們可以在程式中使用這些變數。    #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main(int argc, char *argv[]) { int32_t c = 0; while((c = getopt(argc, argv, \u0026#34;ab:\u0026#34;)) != -1) { switch(c) { case \u0026#39;a\u0026#39;: printf( \u0026#34;option: -a\\n\u0026#34; ); break; case \u0026#39;b\u0026#39;: printf( \u0026#34;option: -b, %s\\n\u0026#34;, optarg ); case \u0026#39;?\u0026#39;: printf( \u0026#34;option: ?\\n\u0026#34; ); break; default: printf( \u0026#34;option: unknown\\n\u0026#34; ); break; } } return 0; }  optstring  optstring 是一個包含合法選項字符的字符串。 Example: \u0026quot;abc\u0026quot; implies supporting -a, -b, -c. -ab, -bc, -ac, -abc are also supported. 如果這樣的字符後跟一個冒號，則意味著該選項需要一個參數。 optarg 為參數值。   回傳值  如果成功找到選項，則 getopt() 回傳選項字符。 如果所有命令行選項都已解析，則 getopt() 回傳 -1。 如果 getopt() 遇到不在 optstring 中的選項字符，則返回 '?'。 如果 getopt() 遇到缺少參數的選項，則返回值取決於 optstring 中的第一個字符：  如果是':'，則返回':'； 否則返回'?'。      getopt_long int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);\n The getopt_long() function works like getopt() except that it also accepts long options, started with two dashes. If the program accepts only long options, then optstring should be specified as an empty string (””), not NULL. Long option names may be abbreviated if the abbreviation is unique or is an exact match for some defined option. A long option may take a parameter, of the form –arg=param or –arg param. If longindex is not NULL, it points to a variable which is set to the index of the long option relative to longopts. struct option struct option { const char *name; int has_arg; int *flag; int val; };  name: the name of the long option. has_arg:  0: no arguments. 1: required arguments. 2: optional arguments.   flag: specifies how results are returned for a long option. val: the value to return, or to load into the variable pointed to by flag.    #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;getopt.h\u0026gt; struct option long_options[] = { {\u0026#34;all\u0026#34;, 0, NULL, \u0026#39;a\u0026#39;}, {\u0026#34;break\u0026#34;, 0, NULL, \u0026#39;b\u0026#39;}, {\u0026#34;cancel\u0026#34;, 1, NULL, \u0026#39;c\u0026#39;}, {0, 0, 0, 0}, }; int main(int argc, char *argv[]) { int32_t c = 0, index = 0; while((c = getopt_long(argc, argv, \u0026#34;abc:\u0026#34;, long_options, \u0026amp;index)) != -1) { printf(\u0026#34;index: %d\\n\u0026#34;, index); switch(c) { case \u0026#39;a\u0026#39;: printf( \u0026#34;option: -a\\n\u0026#34; ); break; case \u0026#39;b\u0026#39;: printf( \u0026#34;option: -b\\n\u0026#34; ); break; case \u0026#39;c\u0026#39;: printf( \u0026#34;option: -c, %s\\n\u0026#34;, optarg ); break; case \u0026#39;?\u0026#39;: printf( \u0026#34;option: ?\\n\u0026#34; ); break; default: printf( \u0026#34;option: unknown\\n\u0026#34; ); break; } } return 0; } Variable Length Arguments  可變長度參數是一項功能，允許函數接收任意數量的參數。 可變數量的參數由三個點表示 ...。  #include \u0026lt;stdarg.h\u0026gt;void va_start(va_list ap, last); type va_arg(va_list ap, type); void va_end(va_list ap); void va_copy(va_list dest, va_list src);  Actually, they are macros instead of functions. 範例一： printargs.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdarg.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;/* print all args one at a time until a negative argument is seen; all args are assumed to be of int type */ void printargs(int32_t arg1, ...) { va_list ap; int32_t i; va_start( ap, arg1 ); for(int32_t i = arg1; i \u0026gt;= 0; i = va_arg(ap, int32_t)) printf( \u0026#34;%d \u0026#34;, i); va_end( ap ); putchar(\u0026#39;\\n\u0026#39;); return; } int main() { printargs(5, 2, 14, 84, 97, 15, -1, 48, -1); printargs(84, 51, -1); printargs(-1); printargs(1, -1); return 0; }  範例二： avg.c #include \u0026lt;stdarg.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;double average(int32_t num, ...) { va_list valist; int32_t sum = 0; va_start(valist, num); for (int32_t i = 0; i \u0026lt; num; i++) sum += va_arg(valist, int32_t); va_end(valist); return sum / (double)num; } int main() { printf(\u0026#34;Average of { 3, 4 } = %lf\\n\u0026#34;, average(2, 3, 4)); printf(\u0026#34;Average of { 5, 10, 15 } = %lf\\n\u0026#34;, average(3, 5, 10, 15)); return 0; }   ","date":"2021-07-12T21:57:26+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-05/","title":"程式設計(二)-05：Variable Length Arguments List"},{"content":" 如何顯示 BMP 檔 ?  有很多 libraries 可以幫助您做到這一點。實際上，您應該使用它們而不是從頭開始開發。 如何在螢幕上顯示圖像？  您必須至少學習一個 GUI 庫，例如 Gtk、Qt 等。 我的建議：Qt。但是，這是一個 C++ 框架。 了解如何使用 GUI 平台提供的功能顯示圖像。       GTK  GTK（以前稱為 GTK+、GIMP ToolKit）是一個免費的開源跨平台的部件工具箱 (widget toolkit)，用於創建圖形用戶界面（GUIs）。 GTK 是用 C 語言所編寫的物件導向的部件工具箱。它使用 GObject（即 GLib 物件系統）進行物件導向。  因此，不要告訴我 C 不能物件導向。   安裝：sudo apt install libgtk-3-dev   SDL  Simple DirectMedia Layer SDL是跨平台的軟件開發庫，為計算機多媒體硬件組件提供硬件抽象層。  視頻 聲音的 輸入設備 光盤 螺紋 共享對象加載 聯網 計時器 3D圖形   軟體開發者可以使用它來編寫高性能的電腦遊戲和其他多媒體應用程式。 SDL 架構 / 範例     SDL Object  SDL_Window：包含有關 Window 本身的所有信息的結構：大小、位置、全螢幕、邊框等。 SDL_Renderer：處理所有渲染的結構。它與 SDL_Window 綁定在一起，因此只能在該 SDL_Window 中呈現。 SDL_Textures 和 SDL_Surface：SDL_Renderer 渲染SDL_Texture(存儲一個元素的像素資訊)。這是 SDL_Surface 的新版本，他們幾乎相同。  重要的區別是 SDL_Surface 使用軟件渲染（通過CPU），而 SDL_Texture 使用硬件渲染（通過GPU）。     安裝：sudo apt-get install libsdl2-dev libsdl2-image-dev Makefile CFLAGS := `sdl2-config --libs --cflags` -ggdb3 -O0 --std=c99 -Wall -lSDL2_image -lm all: example.c gcc example.c -o example $(CFLAGS) clean: rm example    File Descriptor  POSIX C Implementation  C 標准定義了語法和標準庫，但不規範實現。 所以在 Linux 中，fopen、fclose、printf、scanf、fprintf、fscanf、fread 和 fwrite 是通過低階 API 實現的：  open read write close   現在，我們將使用這些較低級別的 API 來訪問文件。    open, close int open(const char *pathname, int flags);\n Given a pathname for a file, open() returns a file descriptor, a small, nonnegative integer for use in subsequent system calls. open() returns the new file descriptor, or -1 if an error occurred. The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. int close(int fd); close() closes a file descriptor, so that it no longer refers to any file and may be reused. close() returns zero on success. On error, -1 is returned, and errno is set appropriately. For more flags, please read manual.  read, write ssize_t read(int fd, void *buf, size_t count);\n read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. On files that support seeking, the read operation commences at the current file offset, and the file offset is incremented by the number of bytes read. If the current file offset is at or past the end of file, no bytes are read, and read() returns zero. ssize_t write(int fd, const void *buf, size_t count); write() writes up to count bytes from the buffer pointed buf to the file referred to by the file descriptor fd. How about seek? use lseek.  fstat int fstat(int fd, struct stat *buf);\n These functions return information about a file, in the buffer pointed to by buf.  mmap  \nvoid *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);\n mmap() creates a new mapping in the virtual address space of the calling process. The starting address for the new mapping is specified in addr. The length argument specifies the length of the mapping. If addr is NULL, then the kernel chooses the address at which to create the mapping. 現在您可以將返回地址視為一個大陣列，您可以直接訪問數據，包括修改數值。 在使用 mmap 後，請記得要 munmap。 mmap() 不是標準 C 的函式 MapViewOfFile function is somewhat equivalent to mmap in Windows.  ","date":"2021-05-08T17:23:11+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-04/","title":"程式設計(二)-04：File Processing-02"},{"content":"File  C 將每個檔案視為一個連續的 bytes stream 每個檔案以 end-of-file 為結尾，這是由系統提供而不是文件。   It looks like there is an additional byte appended to the file. However, that additional byte does not exist. Instead, it is a signal raised by your system. int feof(FILE *stream);  File Stream  Streams 提供了更高級別的介面(interface)讓你存取資料。  fprintf fscanf   事實上，你已經使用過 file stream !  三種標準流  標準輸入 0 (standard input.) 標準輸出 1 (standard output.) 標準錯誤 2 (standard error.)   真的嗎? 哪時候呀? scanf -\u0026gt; scanf() 從標準輸入流中讀取輸入 scanf 的實作 int scanf(const char *fmt, ...){ int count; va_list ap; va_start(ap, fmt); count = vfscanf(stdin, fmt, ap); va_end(ap); return(count); }     File Descriptor  File descriptor 為輸出入的操作提供了原始的低級介面(interface)。 在 Linux 中，任何東西都可以被視為一個檔案。  Network socker Device driver Inter-process communication   支援哪些操作?  open、read、write、close   如果要控制某些詳細的設定，你需要使用 file descriptor 而不是 file stream。  File Stream vs. File Descriptor  Structure:  Stream: FILE * Descriptor: int   可以用 file stream 實現的，就一定可以用 file descriptor 實現，其逆不真。 File streams 有更多方便的介面(interface)給你使用。  I/O Redirection stdout  \n \u0026gt; filename  重導向 stdout 到一個檔案 如果檔案不存在就創建文件，否則就將其覆蓋   \u0026gt;\u0026gt; filename  重導向 stdout 到一個檔案 如果檔案不存在就創建文件，否則就加在後方      \u0026gt; filename 1\u0026gt; filename  Redirect stdout to file \u0026ldquo;filename\u0026rdquo;   \u0026gt;\u0026gt; filename 1\u0026gt;\u0026gt; filename  Redirect and append stdout to file \u0026ldquo;filename\u0026rdquo;   2\u0026gt; filename  Redirect stderr to file ”filename.”   2\u0026gt;\u0026gt; filename  Redirect and append stderr to file ”filename.”   \u0026amp;\u0026gt; filename  Redirect stdout, stderr to file ”filename.”    stdin $ . / abs \u0026lt; number.txt\nText File Processing fopen FILE *fopen(const char *path, const char *mode);\n path：檔案路徑 mode：  r：read w：write a：append 更多的選項在手冊中   Return：FILE *  成功的話，FILE pointer 將被回傳 如果失敗的話，將回傳 NULL 並且 errno 被設置為表明 error 永遠記得確認回傳的 pointer!    fprintf  幾乎和printf相同，除了你需要給 FILE stream pointer。  End-of-File Indicator  Linu/Mac OS X/UNIX：\u0026lt;Ctrl\u0026gt; d Windows：\u0026lt;Ctrl\u0026gt; z + enter  fclose int fclose(FILE *stream);\n fclose() The fclose() function flushes the stream pointed to by stream (writing any buffered output data using fflush(3)) and closes the underlying file descriptor. 也就是說，當你 close 時，在 buffer 中的資料將被寫入檔案 在開檔後記得關上它!! 因為有同時開檔的數量上限。  fscanf  操作就如同 fprintf 當然，檔案應該被以 r 的模式打開    當你使用 fprintf 或 fscanf 去處理文字檔時，它蘊含著你清楚地知道檔案的格式 在這些情況下，輸入的檢查也許就沒那麼重要了，對吧?  Yes：畢竟格式由你決定。 No：有些人可能會修改檔案，並使你讀取它。    File Position Pointer  \n 所以我們可以返回到開始的位置嗎??  為什麼我們需要這麼做? -\u0026gt; 影片倒放 當然，你可以關掉檔案並重開它。 但我們有另外的函式可以幫助我們 -\u0026gt; rewind    rewind void rewind(FILE *stream);\n 將位置指回檔案的開頭。 那麼我們想要改變 file pointer 到任何地方呢? -\u0026gt; fseek  fseek int fseek(FILE *stream, long offset, int whence);\n The fseek() function sets the file position indicator for the stream pointed to by stream. The new position, measured in bytes, is obtained by adding offset bytes to the position specified by whence. SEEK_SET：檔案開頭 SEEK_CUR：當前位置 SEEK_END：end-of-file    rewind() 相當於 fseek(stream, 0L, SEEK_SET)  ftell long ftell(FILE *stream);\n 告訴你當前所在的位置。  Binary File Processing Binary File  文字檔以字元的方式儲存資料，然而並不是所有的檔案都是文字檔。例如，你可以用文字編輯器打開一張圖片。 此外文字檔的儲存效率並不高  需要多少大小去儲存數字 123 ? Text File：3 bytes Binary File：1 byte    fread size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n 從 FILE * 讀取 nmemb 個資料，每個 size bytes 長，並將它們儲存在 *ptr。 成功時回傳資料讀取的數量。如果失敗，或到達文件尾端時，則回傳是一短項計數 (或 0)  fwrite size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n 從 *ptr 讀取 nmemb 個資料，每個 size bytes 長，並將它們儲存在 FILE *。 成功時回傳資料寫入的數量。如果失敗，或到達文件尾端時，則回傳是一短項計數 (或 0)  BMP File Format  這裡將使用 bmp 檔作為示範  為什麼是 bmp 而不是 jpg ? -\u0026gt; 因為 bmp 是一種未被壓縮的照片格式。   連結  讀取 bmp 檔  讀取 bmp file header 並印出資訊  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; struct _sBmpHeader { char bm[2]; uint32_t size; uint32_t reserve; uint32_t offset; uint32_t header_size; int32_t width; int32_t height; uint16_t planes; uint16_t bpp; uint32_t compression; uint32_t bitmap_size; int32_t hres; int32_t vres; uint32_t used; uint32_t important; }__attribute__ ((__packed__)); typedef struct _sBmpHeader sBmpHeader; void print_bmp_header( sBmpHeader *pHeader ) { printf( \u0026#34;ID: %c%c\\n\u0026#34;, pHeader -\u0026gt; bm[0], pHeader -\u0026gt; bm[1] ); printf( \u0026#34;Size: %u\\n\u0026#34;, pHeader -\u0026gt; size ); printf( \u0026#34;Reserve: %u\\n\u0026#34;, pHeader -\u0026gt; reserve ); printf( \u0026#34;Offset: %u\\n\u0026#34;, pHeader -\u0026gt; offset ); printf( \u0026#34;Header Size: %u\\n\u0026#34;, pHeader -\u0026gt; header_size ); printf( \u0026#34;Width: %u\\n\u0026#34;, pHeader -\u0026gt; width ); printf( \u0026#34;Height: %u\\n\u0026#34;, pHeader -\u0026gt; height ); printf( \u0026#34;Planes: %u\\n\u0026#34;, pHeader -\u0026gt; planes ); printf( \u0026#34;Bits Per Pixel: %u\\n\u0026#34;, pHeader -\u0026gt; bpp ); printf( \u0026#34;Compression: %u\\n\u0026#34;, pHeader -\u0026gt; compression ); printf( \u0026#34;Bitmap Data Size: %u\\n\u0026#34;, pHeader -\u0026gt; bitmap_size ); printf( \u0026#34;H-Resolution: %u\\n\u0026#34;, pHeader -\u0026gt; hres ); printf( \u0026#34;V-Resolution: %u\\n\u0026#34;, pHeader -\u0026gt; vres ); printf( \u0026#34;Used Colors: %u\\n\u0026#34;, pHeader -\u0026gt; used ); printf( \u0026#34;Important Colors: %u\\n\u0026#34;, pHeader -\u0026gt; important ); return; } int main() { FILE *pFile = NULL; if((pFile = fopen(\u0026#34;maldives_16.bmp\u0026#34;, \u0026#34;rb\u0026#34;)) == NULL) { printf(\u0026#34;File could not be opened!\\n\u0026#34;); return 0; } sBmpHeader header; printf(\u0026#34;%lu\\n\u0026#34;, sizeof(header)); fread(\u0026amp;header, 54, 1, pFile); print_bmp_header(\u0026amp;header); fclose(pFile); return 0; } 修改 bmp 檔  翻轉顏色  // ...略... int main() { FILE *pFile = NULL; FILE *pFile2 = NULL; if((pFile = fopen(\u0026#34;maldives.bmp\u0026#34;, \u0026#34;rb\u0026#34;)) == NULL) { printf( \u0026#34;File could not be opened!\\n\u0026#34; ); return 0; } if((pFile2 = fopen(\u0026#34;maldives_gray.bmp\u0026#34;, \u0026#34;wb\u0026#34;)) == NULL) { printf(\u0026#34;File could not be opened!\\n\u0026#34;); return 0; } sBmpHeader\theader; fread( \u0026amp;header, sizeof( header ), 1, pFile ); fwrite( \u0026amp;header, sizeof( header ), 1, pFile2 ); while(!feof(pFile)) { uint8_t\toriginal[1024] = {0}; uint8_t modified[1024] = {0}; size_t count = fread( original, 1, 1024, pFile ); for(size_t i = 0; i \u0026lt; count; ++i){ modified[i] = 255 - original[i]; } fwrite( modified, count, 1, pFile2 ); } fclose( pFile ); fclose( pFile2 ); return 0; }  轉成灰階  // ...略... while(!feof(pFile)) { uint8_t\toriginal[999] = {0}; uint8_t modified[999] = {0}; size_t count = fread( original, 1, 999, pFile ); for(size_t i = 0; i \u0026lt; count; i = i + 3) { // BGR  uint8_t gray = 0.299 * original[i+2] + 0.587 * original[i+1] + 0.114 * original[i]; for(size_t j = 0; j \u0026lt; 3; ++j) { modified[i+j] = gray; } } fwrite(modified, count, 1, pFile2); } // ...略...  Hex 編輯工具  Bless Hex Editor GHex  ","date":"2021-04-02T17:58:22+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-03/","title":"程式設計(二)-03：File Processing-01"},{"content":"Structure  Structures 就是將一堆相關的變數整合在一個名字下。  關鍵字：struct 資料型別：struct _name_ 成員：在 struct 的大括號內宣告的變數。 同一個結構體下的成員名稱是唯一的。  struct _sCard{ uint8_t suit, face; };  初始化 struct _sCard a_card = {.suit = 1, .face = 2}; struct _sCard a_card = {1, 2};  structure member operator -\u0026gt; . structure pointer operator -\u0026gt; -\u0026gt; a_card_ptr = \u0026amp;a_card; a_card_ptr-\u0026gt;face = 5; // Equivalent to (*a_card_ptr).face = 5;   CPU Alignment  CPU 有時候會為了減少從記憶體呼叫變數的次數，而主動將變數的記憶體放在連續的地方。 為了避免 alignment，你可以使用以下兩種方法：  __attribute__((packed)) pragma #pragma pack(push) #pragma pack(1) #pragma pack(pop)   // 法一 struct st{ ... }__attribute__((packed)); // 法二 #pragma pack(push) #pragma pack(1) struct st{ ... }; #pragma pack(pop)  Structure 不能包含自己，如果需要請用 pointer ! struct student { char name [64]; uint8_t age; uint8_t gender; struct student *leader; };   typedef  由於軟體開發者盡可能的保持懶惰，因此他們嘗試縮短程式碼。 為了提高可讀性  typedef struct card Card; typedef struct card { uint8_t suit; uint8_t face; } Card; Structure With Functions  為什麼我們時常以傳址的方式傳送 Structures ?  因為效率   傳值 vs 傳址      const int *a; // declare a as pointer to int int const *a; // syntax error int * const a; // declare a as const pointer to int int const * const a; // syntax error const int *a; // declare a as pointer to const int const int * const a; // declare a as const pointer to const int  Although C and C++ read mostly from top-to-bottom and left-to-right, pointer declarations read, in a sense, backwards.  Union  Union 是所有成員共享相同記憶體空間的派生數據類型。 記憶體大小足以容納最大的成員。 實際應用  struct ip_addr { uint8_t fam; // socket family type  union { struct in_addr ipv4_sin_addr; struct in6_addr ipv6_sin_addr; }addr; }; Bitwise Operation  \u0026amp;：AND -\u0026gt; 0\u0026amp;0 = 0; 0\u0026amp;1 = 0; 1\u0026amp;0 = 0; 1\u0026amp;1 = 1. |：OR -\u0026gt; 0|0 = 0; 0|1 = 1; 1|0 = 1; 1|1 = 1. ^：XOR -\u0026gt; 0^0 = 0; 0^1 = 1; 1^0 = 1; 1^1 = 0. ~：Complement -\u0026gt; \\(\\text{\\textasciitilde}4_{10}\\) =\u0018 \\(\\text{\\textasciitilde}100_2\\) = \\(011_2\\) = \\(3_{10}\\). \u0026lt;\u0026lt;：Left Shift 0012 \u0026laquo; 2 = 1002. \u0026gt;\u0026gt;：Right Shift 1002 \u0026raquo; 2 = 0012.    為什麼我們需要 bitwise operation ?  在大多數情況下，按位運算比算術運算要快。  a = a * 2 a = a \u0026laquo; 1   由於編譯器優化，這可能不是正確的。   Mask with better memory utilization. Game Cheating Example  ０１ ⽕炎術 １０ 電擊術 ０２ 烈炎術 ２０ 落雷術 ０４ 炎⿓術 ４０ 轟雷術 ０８ 天⽕術 ８０ 神雷術    Bit Fields typedef union { struct { unsigned char b1:1; unsigned char b2:1; unsigned char b3:1; unsigned char b4:1; unsigned char b5:1; unsigned char b6:1; unsigned char b7:1; unsigned char b8:1; } bits; unsigned char byte; } uByte;  由於 alignment 問題，記憶體的空間可能不是安全的，這取決於你如何儲存你的資料。 實際上，bit fields 可能會增加編程時的難度。我不建議您使用此功能，但是，您需要了解此語法，因為其他人可能會使用它。 Do not take the address of a bit field.  Enumeration  A set of integer enumeration constants represented by identifiers.  enum career { SABER, LANCER, ARCHER, RIDER, CASTER, ASSASSIN, BERSAKER, RULER, CAREER_MAX = 31 }; typedef struct player { char name[64]; enum career role; uint32_t role2; } Player;  你不能改變 enumeration constants 的值。 我是否可以使用 define 或 const 而不是 enum?  是，可以的。 但他們有什麼不同呢?    ","date":"2021-04-02T16:24:46+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-02/","title":"程式設計(二)-02：Structure"},{"content":"字元  在講字串之前我們先來看什麼是字元。  ASCII  American Standard Code for Information Interchange. 電子通訊的字元編碼標準 基於英文字母，ASCII 將 128 個字元編碼成 7 個位元長。  95 個可印字元：A-Z, a-z, 0-9, 標點符號 不可印字元：換行符號      在電腦中我們使用 8-bit 的記憶體儲存字元。 在 C 語言中，使用 char 這個型別。 %c -\u0026gt; 輸出字元 %x or %X -\u0026gt; 印出 hex or HEX 的值。    在以前，許多情況下，有些人使用 unsigned char 作為 one byte 的資料型別，但現今你應該使用的是 uint8_t。 請把 char 留給字串，盡管事實上對電腦來說都是一樣的。 其他編碼：Big5、UTF-8  字串  事實上，字串就是一連串的可印字元。 這樣看起來很像陣列對吧? Yes!    \n 在 C 語言中，字串是一個字元指標，並以 '\\0' 為結尾。 常見的錯誤：  沒有分配足夠的空間 輸出一個不包含 '\\0' 的字串 在 C 的標準中，字元指標是不可修改的，如果要修改字串，必須儲存在字元陣列中。    字串處理函式  首先，這部分有印象就好，不用記，畢竟到這邊大家應該都有能力自己實作出來吧!  字串轉整數  很久很久以前 #include \u0026lt;stdlib.h\u0026gt;int atoi(const char *nptr); long atol(const char *nptr);  現今 #include \u0026lt;stdlib.h\u0026gt;// string to double double strtod(const char *nptr, char **endptr); // string to long int long int strtol(const char *nptr, char **endptr, int base);   輸出入函式  輸出  #include \u0026lt;stdio.h\u0026gt;int putchar(int c); // 輸出字元 int puts(const char *s); // 輸出字串 int snprintf(char *restrict buffer, size_t bufsz, const char *restrict format, ... );  輸入  #include \u0026lt;stdio.h\u0026gt;int getchar(void); // 輸入字元 char *fgets(char *s, int size, FILE *stream); // 輸入字串 int sscanf(const char *restrict buffer, const char *restrict format, ... );   一些不推薦的函式，永遠不要用他們  char *gets(char *s); int sprintf(char *str, const char *format, ...);   有 buffer overflow 的風險  字串操作函式 char *strncpy(char *dest, const char *src, size_t n); // 複製字串 char *strncat(char *dest, const char *src, size_t n); // 串接字串   和上述理由一樣，不要使用下方的函式  char *strcpy(char *dest,const char *src); char *strcat(char *dest,const char *src);    字串比較函式 #include \u0026lt;string.h\u0026gt;int strcmp(const char *s1, const char *s2); int strncmp(const char *s1, const char *s2, size_t n);  如果s1（或其前n個字節）分別小於、匹配或大於s2，則函數將返回小於、等於或大於零的整數。  字串搜尋函式 #include \u0026lt;string.h\u0026gt;char *strchr(const char *s, int c); // 從頭找字元 char *strrchr(const char *s, int c); // 從尾找字元 // 計算 s 的前綴有多少字元在 accept 中 size_t strspn(const char *s, const char *accept ); // 計算 s 的前綴有多少字元不在 reject 中 size_t strcspn(const char *s, const char *reject ); // 回傳在 accept 中的任何字元在 s 字串首次出現位置的指標 char *strpbrk(const char *s, const char *accept ); // 回傳 needle 在 haystack 中首次出現位置的指標 char *strstr(const char *haystack, const char *needle ); // 依照 delim 中的字元分割 str char *strtok(char *str, const char *delim ); strtok 範例 char str[] = \u0026#34;the value of pi is 3.14\u0026#34;; char *token = strtok(str, \u0026#34; \u0026#34;); while(token != NULL) { printf(\u0026#34;%d: %s\\n\u0026#34;, i, token); token = strtok(NULL, \u0026#34; \u0026#34;); }  為何第二次之後呼叫都是以 NULL 作為輸入?  因為這是一個 static 的變數。如果輸入 NULL，該函式將繼續從最後一個位置切割字串。   為甚麼我不能直接使用 const char *str?  因為 strtok 的實作，將會直接操作在輸入的字串上。    其他字串函式 #include \u0026lt;string.h\u0026gt;size_t strlen(const char *s); // 計算字串長度 // 輸出錯誤訊息 char *strerror(int errnum); void perror(const char *str);  strerror 搭配 errno 使用 (#include \u0026lt;errno.h\u0026gt;)  ","date":"2021-04-02T14:40:30+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_2-01/","title":"程式設計(二)-01：String"},{"content":"簡介  這部份是紀錄我修改的主題內容，並將 codeblocks 區塊美化，以及支援 KaTex 和 Google Analytics  教學開始  我使用的主題為 Stack  主題內容修改  找到 assets/scss/variables.scss，並修改 --link-background-color: 90, 240, 250; //189, 195, 199; --code-text-color: #ef3982; //rgba(255, 255, 255, 0.9);   Codeblocks 區塊美化  到 static/css/ 下建立 copy-to-clipboard.css，內容如下 .highlight { position: relative; } .highlight .ln { -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; } .highlight-copy-btn { position: absolute; top: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.8em; line-height: 1.8; color: #fff; background-color: #777; min-width: 55px; text-align: center; } .highlight-copy-btn:hover { background-color: #666; }  到 static/js/ 下建立 copy-to-clipboard.js，內容如下 (function () { \u0026#39;use strict\u0026#39;; if (!document.queryCommandSupported(\u0026#39;copy\u0026#39;)) { return; } function flashCopyMessage(el, msg) { el.textContent = msg; setTimeout(function () { el.textContent = \u0026#34;Copy\u0026#34;; }, 1000); } function selectText(node) { var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(node); selection.removeAllRanges(); selection.addRange(range); return selection; } function addCopyButton(containerEl) { var copyBtn = document.createElement(\u0026#34;button\u0026#34;); copyBtn.className = \u0026#34;highlight-copy-btn\u0026#34;; copyBtn.textContent = \u0026#34;Copy\u0026#34;; var codeEl = containerEl.firstElementChild; copyBtn.addEventListener(\u0026#39;click\u0026#39;, function () { try { var selection = selectText(codeEl); document.execCommand(\u0026#39;copy\u0026#39;); selection.removeAllRanges(); flashCopyMessage(copyBtn, \u0026#39;Copied!\u0026#39;) } catch (e) { console \u0026amp;\u0026amp; console.log(e); flashCopyMessage(copyBtn, \u0026#39;Failed :\\\u0026#39;(\u0026#39;) } }); containerEl.appendChild(copyBtn); } // Add copy button to code blocks  var highlightBlocks = document.getElementsByClassName(\u0026#39;highlight\u0026#39;); Array.prototype.forEach.call(highlightBlocks, addCopyButton); })();  修改 config.yaml custom_css:[\u0026#34;css/copy-to-clipboard.css\u0026#34;]pygmentsUseClasses:truemarkup:highlight:lineNos:truelineNumbersInTable:false 修改 layouts/partials/head/custom.html {{ range .Site.Params.custom_css -}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt; {{- end }} {{ range .Site.Params.custom_js -}} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{- end }}  修改 layouts/partials/footer/custom.html \u0026lt;script src=\u0026#34;/js/copy-to-clipboard.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  這樣程式碼區塊就有 Copy Button，並且直接複製時不會選取到行號了  KaTex  到 layouts/partials/ 下新增 math.html，內容如下 {{ if or .Params.math .Site.Params.math }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true}, {left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true}, {left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false}, {left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false} ] }); }); \u0026lt;/script\u0026gt; {{ end }}  修改 layouts/partials/head/custom.html {{ partial \u0026#34;math.html\u0026#34; . }}   Google Analytics  到 Google Analytics 創建一個資料串流 由於 Hugo 內建的 GA 模板，似乎還不支援 GA4，因此我們使用 gtag.js 複製剛剛建立的資料串流中的 gtag.js 內容到 layouts/partials/google_analytics.html中 修改 layouts/partials/head/custom.html {{ if not .Site.IsServer }}{{ partial \u0026#34;google_analytics.html\u0026#34; . }}{{ end }}  這裡的 if 是避免在 local 測試時的數據也被紀錄下來     Hugo 於 0.82.0 版本已更新了對 GA4 的支援，使用方法如下\n  同上 在 config.yaml 中設定 googleAnalytics: G- 修改 layouts/partials/head/custom.html {{ template \u0026#34;_internal/google_analytics.html\u0026#34; . }}   ","date":"2021-02-07T04:06:17+08:00","permalink":"https://blog.smallten.tk/p/hugo-02/","title":"Hugo-02：優化 Blog"},{"content":"簡介  這篇內容將快速帶你建立一個 Hugo Blog 並將其部屬到 GitHub 上  相關連結  Hugo - Hugo 官網 Hugo Themes - 選擇自己喜歡的主題 Hugo Releases - 下載 Hugo 並安裝進電腦  教學開始 建立 Hugo Blog  安裝 Hugo  這裡以 Ubuntu 為示範 先至 Hugo Releases 下載自己所需的版本 $ dpkg -i hugo_extended_0.79.0_Linux-64bit.deb # 記得依照檔案自行更改    創建一個 Hugo Site  這裡創建一個名為 blog $ cd ~ $ hugo new site blog # 可自行修改名稱    新增主題  這裡我選擇了 Stack 這個主題  $ cd ~/blog/ $ git init $ git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack  跟著主題的教學文檔修改 config file 如要建立新文章時 $ hugo new post/test.md  此時會在 content/post/ 下，建立新文章，檔名為 test.md draft: 草稿 slug: 此文章的 url (可自行建立)   本機測試 $ hugo server -D  -D: 將會連草稿都顯示出來    部署到 GitHub  在 GitHub 上建立一個新的 Repository  名稱為 \u0026quot;Your account\u0026quot;.github.io (\u0026ldquo;Your account\u0026rdquo; 使用自己 GitHub 的名稱)   將剛才建立好的 Blog 上到這個 Repo $ cd ~/blog/ $ git add --all $ git commit -m \u0026#34;blog init\u0026#34; $ git branch -M main $ git remote add origin git@github.com... #這裡使用了 ssh 的方式 $ git push -u origin main  使用 GitHub Actions  建立一個 workflows 名叫 hugo_publish.yml (有些地方須自行依照情況修改) 內容：hugo_publish.yml   修改 Repo 的設定  先找到 GitHub Pages 的地方 將 Source 改成 Branch: gh-pages 有 custom domain 的記得填入 Enforce HTTPS 打勾   這樣就完成了，之後只要 push 時，便會自動更新網站了  ","date":"2021-02-07T03:22:22+08:00","permalink":"https://blog.smallten.tk/p/hugo-01/","title":"Hugo-01：建立一個Hugo Blog"},{"content":"Pointer  許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分    指標是一個變數，其值為記憶體位置   宣告：int32_t *p  p 是一個指標 指向的記憶體區塊被視為整數   初始化：int32_t *p = NULL address operator \u0026amp;：返回其變數的記憶體位置  如果想要印出記憶體位置，你可以使用%p   indirection operator *：也被稱為dereferencing operator，返回指向對象的值   void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別  傳參數至函式  在C語言中，argument passing 稱為 call-by-value  電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行   這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。  陣列與指標  在大部分的情況下，我們可以把array視為第一個元素的指標  現在你應該明白為什麼陣列的值會在函式中被修改   為了避免模棱兩可(搞混)，我較喜歡\u0026amp;(array[0])而不是array、\u0026amp;array 然而你不能寫出 array = \u0026amp;a int32_t   int16_t   int8_t   ptr++  移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用   事實上，array[n] = *(ptr + n)  Endian Issue  \n函式指標  指標不過是一個記憶體位址。 當我們宣告某種類型的指標時，這意味著電腦將將訪問記憶體並根據給定的類型解釋存儲在該位址的值。 您是否知道函式也存儲在記憶體中？ 使用函式指標時，返回的型別和參數應該要和實際的定義相同。  Really??為什麼在編譯時不會產生errors? 這是個檢查definition的好習慣。   回呼函式 (Callback function) 你可以用陣列來儲存函式指標 void (*f[3])(int32_t) = {f1, f2, f3};    使用了函式指標的例子  Menu Driven Driver struct file_operations scull_fops = { .owner = THIS_MODULE , .llseek = scull_llseek , .read = scull_read , .write = scull_write , .ioctl = scull_ioctl , .open = scull_open , .release = scull_release , };  Firewall  static unsigned int hook_func( const struct nf_hook_ops *ops , struct sk_buff *skb , const struct net_device *in , const struct net_device *out , int (*okfn)( struct sk_buff *) )   記憶體管理  記憶體管理  分配記憶體當你宣告一個變數 垃圾回收 ( GC )   為什麼許多現代的程式語言不支援記憶體管理  軟體工程師是人類 人是不可被信任的   然而，如果軟體工程師知道他們在做什麼，那麼他們可以更有效率的管理記憶體 如果不考慮記憶體，請使用陣列 如果你想陣列的大小可以被動態的改變，那麼去讀 C++ 並學習如何使用 container   malloc #include \u0026lt;stdlib.h\u0026gt;ptr = malloc( sizeof(int) * size);  malloc() 分配 size bytes 並回傳一個指向所分配的記憶體的指標 記憶體沒有初始化 若要初始化，請使用 memset  #include \u0026lt;string.h\u0026gt;memset(ptr, 0, sizeof(int) * size); calloc #include \u0026lt;stdlib.h\u0026gt;ptr = calloc(size, sizeof(int));  在現代的 C 中，你應該使用 calloc 第一個參數：多少個區塊你想去分配? 第二個參數：每個區塊的大小。 記憶體被初始化成 0  free  \n free(ptr)：釋放 ptr 指向的記憶體空間，該記憶體空間必須是由之前使用 malloc()、calloc()、realloc() 所回傳的。 此外，若已經 free(ptr)，再次使用會發生未定義行為。  Double Pointer  \n 使用場景：  在函式中分配記憶體  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void table(int32_t **pp, int32_t n){ *pp = (int32_t *)calloc(n * n, sizeof(int32_t)); for(int32_t i=1; i\u0026lt;=n; ++i){ for(int32_t j=1; j\u0026lt;=n; ++j){ *(*pp + (i-1) * n + (j-1)) = i * j; } } } int main(){ int32_t number = 0; scanf(\u0026#34;%d\u0026#34;, number); int32_t *ptr = NULL; table(\u0026amp;ptr, number); return 0; }  分配一個二維陣列  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main() { size_t size_row = 0, size_column = 0; printf(\u0026#34;Please enter two integers for row and column: \u0026#34;); scanf( \u0026#34;%lu %lu\u0026#34;, \u0026amp;size_row, \u0026amp;size_column ); int32_t **ptr = NULL; ptr = (int32_t **)calloc( sizeof( int32_t * ), size_row ); for( size_t i = 0 ; i \u0026lt; size_row ; i++ ) { *( ptr + i ) = (int32_t *)calloc( sizeof( int32_t ), size_column ); for( size_t j = 0 ; j \u0026lt; size_column ; j++ ) { *( *( ptr + i ) + j ) = ( i + 1 ) * ( j + 1 ); } } for( size_t i = 0 ; i \u0026lt; size_row ; i++ ) { for( size_t j = 0 ; j \u0026lt; size_column; j++ ) { printf( \u0026#34;%4d \u0026#34;, *( *( ptr + i ) + j ) ); } printf( \u0026#34;\\n\u0026#34; ); } return 0; }    小工具 cdecl  安裝：sudo apt install cdecl 使用：cdecl -\u0026gt; explain int ***a;  資源查看  top / htop vmstat ( 較輕量化 )  vmstat -n 1 ( -n 1 為一秒輸出一次 )    ","date":"2020-12-23T19:38:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-08/","title":"程式設計(一)-08：Pointer"},{"content":"第一個 Hugo Blog  由於秉持著「人生總折騰」的道理，我來轉移 Blog 了(誤///)，好啦，其實是單純希望有個穩定且又能全天候供應的 Blog 而已，由於我的隊友兩人分別使用了 Hexo 及 Hugo ，因此一開始讓我有點難抉擇，但最終我還是選擇了 Hugo 。\n 至於第二個選擇的難關就是主題了，挑了好久都沒看到順眼的，差點就要聽吳文元說的沒有喜歡的就自己寫呀(怕///)，最終還是挑到了一個稍微滿意的主題 Stack。\n 至於架設的過程到目前為止還算是蠻順利的，希望之後也不會遇到什麼大坑。\n","date":"2020-12-18T01:16:06+08:00","permalink":"https://blog.smallten.tk/p/first-hugo-blog/","title":"First Hugo Blog"},{"content":"蓄水池抽樣法 (Reservoir Sampling)  從 N 個樣本中，隨機抽取 K 個樣本，其中 N 非常大(不能將所有數據都放進記憶體或是一個未知數)，而每個被抽出來的機率要相等。  定理 該算法保證每個元素以 \\( k \\over n \\) 的機率被選入蓄水池中。\n證明  第 i 個元素進入蓄水池的機率為 \\( k \\over i \\)，蓄水池內每個元素被替換的機率為\\( 1 \\over k \\) 因此在第 i 輪第 j 個元素被替換的機率為 \\( {k \\over i}\\times{1 \\over k} = {1 \\over i} \\)，接下來用 M.I. (數學歸納法)來證明，當 n 次循環結束時每個元素進入蓄水池的機率為 \\( k \\over n \\) 假設在 (i-1) 次迭代後，任意一個元素進入 蓄水池的概率為 \\( k \\over i-1 \\)。由上面的結論，在第 i 次迭代時，該元素被替換的概率為 \\( 1 \\over i \\)， 那麼其不被替換的概率則為 \\( 1 - {1 \\over i} = {i - 1 \\over i} \\) 故在第 i 次迭代後，該元素在蓄水池內的概率為 \\( {k \\over i-1} \\times {i-1 \\over i} = {k \\over i} \\)，歸納結束。 因此當循環結束時，每個元素進入蓄水池的概率為 \\( k \\over n \\)，命題得證。  例題  Leetcode 382.Linked List Random Node 解法： Cpp  class Solution { ListNode *p; public: Solution(ListNode* head) { p = head; } int getRandom() { int ans = p-\u0026gt;val; ListNode *t = p-\u0026gt;next; for(int i=2; t; ++i){ if(rand()%i == 0) ans = t-\u0026gt;val; t = t-\u0026gt;next; } return ans; } }; ","date":"2020-12-08T16:02:25+08:00","permalink":"https://blog.smallten.tk/p/algorithm-01/","title":"演算法-01：蓄水池抽樣法"},{"content":"Array  陣列是一種可以儲存大量相同型別資料的方法。 連續的記憶體位置。 永遠從0開始  int32_t a[10] -\u0026gt; a[0] ~ a[9]   計數變數 i 的型別可以宣告為 size_t，它是一個無號的整數型別。 初始化  int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0};   存取陣列元素使用 variable[index] 專業說明：電腦將找到第一個元素的地址，然後根據索引移動記憶體位置以訪問數據。 事實上一維陣列可以處理所有情況，至於多維陣列只是給人類方便閱讀的。   define  是遇處理指令，不是C的詞(statement) 我們可以使用 #define 去做巨集(MACRO)  當開發時MACRO有些像function，然而對電腦而言他們是不同的。 當遇到MACRO，編譯器將簡單的依定義替換掉程式碼。 函式擁有自己的標記。    基本排序 氣泡排序法 for(int i = 0; i \u0026lt; n; ++i) { for(int j = i; j \u0026lt; n; ++j) { if(a[j] \u0026lt; a[i]) { a[i] = a[i] ^ a[j]; a[j] = a[i] ^ a[j]; a[i] = a[i] ^ a[j]; } } } qsort #include \u0026lt;stdlib.c\u0026gt;int cmp(const void *a, const void *b) { return (*(int*)a - *(int*)b); } qsort(a, n, sizeof(int), cmp); 傳陣列至函式 int f(int [][n], int); f(a, 10); int f(int a[][n], int size){ }  除了第一個[]外，剩下的都必須要給大小。(電腦才能計算偏移量) 為甚麼要給size? 因為傳過去的只是陣列的記憶體起始位置而已。 在函式中依然會改到本身的值。  const  constant read-only  可變長度陣列  Variable Length Array 雖然有些編譯器支援了以下寫法(C99之後)，但有些依然不支援  int n = 5; int a[n] = {0};  但你應該使用 malloc  準確來說，你應該使用 calloc，而不是 `malloc。   我的建議：當考試的時候不要使用這功能( a[n] )，因為你不知道編譯器的版本。  ","date":"2020-12-07T19:38:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-07/","title":"程式設計(一)-07：Array"},{"content":"Makefile for 程設一 CC = gcc CFLAGS = -Wall -Wextra -O2 -std=c11 LDFLAGS = -lm TARGETS = main01 main02 main01_OBJ = main01.o func01.o main02_OBJ = main02.o func02.o .PHONY = all clean all: $(TARGETS) .SECONDEXPANSION: $(TARGETS): $$($$@_OBJ) $(CC) $^ -o $@ $(LDFLAGS) %.o: $@.c clean: -$(RM) $(TARGETS) $(foreach targ,$(TARGETS),$(foreach obj, $($(targ)_OBJ), $(obj))) ","date":"2020-12-02T21:45:51+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-06/","title":"程式設計(一)-06：Makefile"},{"content":"Function 函式 double  double 是一種浮點數型別，就像是 float 就如同它的名字，它使用的記憶體大小為 float 的兩倍 建議: 當你需要浮點數的話，一律使用 double    到目前為止我們最常使用到的函式為 printf 我們稱這些函式為 C standard functions (C標準函式) 所有的函式都被儲存在libraries中  如果你想要讀書，你需要知道書在哪，然後去圖書館借書 如果你想要使用函式，你需要知道函式在哪，然後include library去使用函式 例如: stdio.h \u0026lt;-\u0026gt; printf   使用 math.h 時，需下編譯參數 -lm    永不重新發明輪子 在開發前請先搜尋   //原型宣告 Return-Value-Type Function-Name (parameter-Type-list); Return-Value-Type Function-Name (parameter-list){ Statements }  使用原型宣告並將自訂函式置於main function之後的好處?  不用管function之間的先後順序。     void  沒有型別 在這裡，代表不需要回傳值  標頭檔 (Header Files)  甚麼是header file?  是一個包含函式的原型宣告(prototypes)和其他定義(definitions)的檔案   為甚麼我們需要header file?  抽象層 有時我們想保護我們的實作(implementation)     #ifndef #define ... #endif  如同我所說，軟體工程師是懶惰的  #pragma once 如何編譯多個檔案 #static gcc -c library.c -o library.o gcc main.c library.o -o main #dynamic gcc -shared test.o -o libtest.so gcc main.c -o main -L. -ltest #執行 LD_LIBRARY_PATH=. ./main Link  Static link: Static linking is the process of copying all library modules used in the program into the final executable image. Dynamic link: In dynamic linking the names of the external libraries (shared libraries) are placed in the final executable file while the actual linking takes place at run time when both executable file and libraries are placed in the memory. .a 是一堆 .o 包在一起  Random #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; srand(time(0)); n = rand % 6 //n: 0 ~ 5  有安全要求時，請勿使用 random()  Global, Static, Extern Variable global  變數的生命週期為整個程式。 也可被extern所存取到。  static  變數只會在程式開始之前分配和初始化一次。 在程式終止之前，儲存空間都不會被釋放。 加上 static 後， extern便無法存取了。  extern  使用外部的變數。  遞迴 Recursive  遞迴定義如下  遞迴: 參見「遞迴」。   什麼?這個定義什麼也沒有說啊!好吧，改一下:  遞迴: 如果你還是沒明白遞迴是什麼意思的話，參見「遞迴」。    Return-Value-Type Function-Name ( parameter-list ) { if ( Base case ) { Return pre-defined value. } else { Call itself with parameter modification. } }  所有能使用遞迴表達的敘述，皆能以迴圈的方式編寫。 To iterate is human, to recurse, divine. — L. Peter Deutsch 遞迴只應天上有，人間該當用迴圈 我的觀點:  如果你找到關係式，遞迴是簡單的。 時常用在虛擬碼(pseudo-code)中。 性能效率可能比迭代差。    ","date":"2020-11-21T21:48:47+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-05/","title":"程式設計(一)-05：Function"},{"content":"Loop - `while` - `for` - `do while`  While Loop while(條件){ 執行區塊 }  %.200f 會發生什麼事? -\u0026gt; 精度不夠沒有意義 while(1) -\u0026gt; 無窮迴圈  For Loop for(初始化; 條件; 執行後操作){ 執行區塊 }  i++ -\u0026gt; Use the current value of i. -\u0026gt; i = i + 1 ++i -\u0026gt; i = i + 1 -\u0026gt; Use the new value of i. {} -\u0026gt; 變數生命週期範圍 %4d ( %# ) -\u0026gt; 給最小的位數去顯示 在 ANSI C, 變數只能被宣告在函式的開頭，而 Modern C 沒有任何限制  Do While Loop do{ 執行區塊 }while(條件)  三種不同類型的迴圈毫無疑問的都可以互相轉換  除了 do while 至少會執行一次   大多數來說，如果你知道要執行幾次迴圈的話，會使用 for break：離開當前的區段 continue：跳過剩餘的敘述，直接執行下一次迭代 無窮迴圈不是個好東西? -\u0026gt; 不，或許你會需要他，例如：Web server   #include \u0026lt;unistd.h\u0026gt;sleep(sec); ","date":"2020-10-18T20:33:18+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-04/","title":"程式設計(一)-04：Loop"},{"content":"Condition Control 簡介  我們想要讓電腦去做基礎的判斷  if switch    If if (condition1) { statements; } else if (condition2){ ... } else { ... }  如果條件不是錯誤，那麼將會執行大括號裡的敘述  簡而言之，false 被定義為 0   \u0026gt; -\u0026gt; 大於 \u0026lt; -\u0026gt; 小於 \u0026gt;= -\u0026gt; 大於等於 \u0026lt;= -\u0026gt; 小於等於 == -\u0026gt; 等於 != -\u0026gt; 不等於 \u0026amp;\u0026amp; -\u0026gt; and || -\u0026gt; or  Boolean  在 Cpp 裡，有個型別稱為 bool  它只有兩個值：true, false 那麼 bool 使用的記憶體大小為何能?( 1 bit or 1 byte ??)   在 ANSI C 裡，沒有一個型別為boolean的 從 C99 開始，有一個標頭檔可以使用，stdbool.h  Switch  你可以使用 if-else 來做每個條件判斷，但是有時候可能會寫一個巨大的巢狀程式，因此將介紹另一個方法 switch  switch (){ case 1: ... break; ... default: ... }  break：從此處結束  那麼如果不使用 break 呢??   default：如果沒有 case 符合，執行這段  浮點數比較 #include \u0026lt;stdio.h\u0026gt;int main() { float a = 0.3; if (a == 0.3) printf(\u0026#34;if01\\n\u0026#34;); else printf(\u0026#34;else01\\n\u0026#34;); if (a == 0.3f) printf(\u0026#34;if02\\n\u0026#34;); else printf(\u0026#34;else02\\n\u0026#34;); return 0; }  結果： else01 if02 請使用 sizeof() 查看發生了什麼!(IEEE 754) 結論：浮點數的比較是相當危險的!!  ","date":"2020-10-15T20:53:14+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-03/","title":"程式設計(一)-03：Condition Control"},{"content":"Arithmetic #include \u0026lt;stdio.h\u0026gt;int main(){ int a = 1, b = 2, sum = 0; sum = a + b; printf(\u0026#34;%d\u0026#34;, sum); return 0; }  變數  每個變數都必須有它的型別 在使用變數前必須先宣告它   在C裡面， = 意思為”指定”，而不是”相等”，指派右邊的數值給左邊的變數 一個好習慣，總是初始化變數 C Spec:  C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero.      In C99: a == (a / b) * b + a % b printf 是一個函式去印出格式化字串  %d -\u0026gt; 有號十進位整數 %f -\u0026gt; 十進位浮點數 %u -\u0026gt; 無號十進位整數 當然不只這些   小技巧  a += b -\u0026gt; a = a + b a -= b -\u0026gt; a = a - b a *= b -\u0026gt; a = a * b a /= b -\u0026gt; a = a / b a %= b -\u0026gt; a = a % b   查看記憶體使用大小： sizeof()，回傳單位為 byte ( printf(\u0026quot;%lu\u0026quot;, sizeof()); ) #include \u0026lt;stdint.h\u0026gt;  int8_t: 8-bit signed interger int16_t: 16-bit signed interger int32_t: 32-bit signed interger int64_t: 64-bit signed interger uint8_t: 8-bit unsigned interger uint16_t: 16-bit unsigned interger uint32_t: 32-bit unsigned interger uint64_t: 64-bit unsigned interger      輸入：scanf(\u0026quot;%d\u0026quot;, \u0026amp;a);  至於為甚麼需要 \u0026amp;，之後會在指標的章節介紹到 scanf 是否有回傳值? ( man 3 scanf )      最後也最重要的技能：RTFM and STFG  ","date":"2020-10-15T11:19:09+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-02/","title":"程式設計(一)-02：Arithmetic"},{"content":"簡介  這篇將帶你下載m3u8檔並分析出ts的檔案，再透過多線程來加速下載，之後再由FFmpeg合併成mp4。\nPython 下載m3u8 m3u8Url = \u0026#39;https://.../index.m3u8\u0026#39; def downloadM3u8(url): r = requests.get(url) with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) 分析m3u8  這部份請依照你所取得的m3u8檔進行分析，並將完整的ts檔的url放進tsList即可。  tsList = [] tsCnt = 0 def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;r\u0026#39;) as f: text = f.read() textList = text.split(\u0026#39;\\n\u0026#39;) while textList[-1] != \u0026#39;#EXT-X-ENDLIST\u0026#39;: textList.pop(-1) for i in textList: if i[0] != \u0026#39;#\u0026#39;: tsList.append(tempUrl + i) global tsCnt tsCnt = len(tsList) 下載ts檔 q = queue.Queue() def downloadts(): global tsList while q.qsize() \u0026gt; 0: num = q.get() r = requests.get(tsList[num]) with open(\u0026#39;./ts/\u0026#39; + str(num+1) + \u0026#39;.ts\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) if __name__ == \u0026#34;__main__\u0026#34;: if not os.path.isdir(\u0026#39;./ts/\u0026#39;): os.mkdir(\u0026#39;./ts/\u0026#39;) for i in range(tsCnt): q.put(i) thList = [] for i in range(tsCnt): th = threading.Thread(target=downloadts) th.start() thList.append(th) for th in thList: th.join() print(\u0026#39;下載ts完成\u0026#39;) 合併ts成mp4 def merge(tsCnt, output): for i in range(tsCnt): with open(\u0026#39;./ts/ts.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;file \u0026#39; + str(i+1) + \u0026#39;.ts\\n\u0026#39;) command = \u0026#39;ffmpeg -y -f concat -i %s-bsf:a aac_adtstoasc -c copy %s\u0026#39; % (\u0026#39;./ts/ts.txt\u0026#39;, output) os.system(command) print(\u0026#39;合併成功\u0026#39;) 移除無用檔案 def remove(): shutil.rmtree(\u0026#39;./ts/\u0026#39;) os.remove(\u0026#39;./index.m3u8\u0026#39;)  完整程式碼 # -*- coding: UTF-8 -*- import requests, os, threading, queue, shutil m3u8Url = \u0026#39;https://.../index.m3u8\u0026#39; tsList = [] tsCnt = 0 q = queue.Queue() def downloadM3u8(url): r = requests.get(url) with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; with open(\u0026#39;./index.m3u8\u0026#39;, \u0026#39;r\u0026#39;) as f: text = f.read() textList = text.split(\u0026#39;\\n\u0026#39;) while textList[-1] != \u0026#39;#EXT-X-ENDLIST\u0026#39;: textList.pop(-1) for i in textList: if i[0] != \u0026#39;#\u0026#39;: tsList.append(tempUrl + i) global tsCnt tsCnt = len(tsList) def downloadts(): global tsList while q.qsize() \u0026gt; 0: num = q.get() r = requests.get(tsList[num]) with open(\u0026#39;./ts/\u0026#39; + str(num+1) + \u0026#39;.ts\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) def merge(tsCnt, output): for i in range(tsCnt): with open(\u0026#39;./ts/ts.txt\u0026#39;, \u0026#39;a+\u0026#39;) as f: f.write(\u0026#39;file \u0026#39; + str(i+1) + \u0026#39;.ts\\n\u0026#39;) command = \u0026#39;ffmpeg -y -f concat -i %s-bsf:a aac_adtstoasc -c copy %s\u0026#39; % (\u0026#39;./ts/ts.txt\u0026#39;, output) os.system(command) print(\u0026#39;合併成功\u0026#39;) def remove(): shutil.rmtree(\u0026#39;./ts/\u0026#39;) os.remove(\u0026#39;./index.m3u8\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: downloadM3u8(m3u8Url) analyzeM3u8() print(\u0026#39;m3u8下載且分析完畢\u0026#39;) if not os.path.isdir(\u0026#39;./ts/\u0026#39;): os.mkdir(\u0026#39;./ts/\u0026#39;) for i in range(tsCnt): q.put(i) thList = [] for i in range(tsCnt): th = threading.Thread(target=downloadts) th.start() thList.append(th) for th in thList: th.join() print(\u0026#39;下載ts完成\u0026#39;) merge(tsCnt, \u0026#39;./test.mp4\u0026#39;) remove() ","date":"2020-10-04T16:36:35+08:00","permalink":"https://blog.smallten.tk/p/python-04/","title":"Python-04：多線程-ts下載並合併成mp4"},{"content":"簡介  現今你時常能在影音媒體網站看到 .m3u8 的檔案，以及許多 .ts 的分段媒體，本篇將教你如何簡單的下載成 .mp4 檔。 這篇並不詳加敘述 HLS 之類的觀念，若有興趣深入了解請自行查找資料。  FFmpeg  FFmpeg官網 下載安裝完後，若為 windows 用戶請將 %ffmpeg%\\bin 的路徑加入環境變數中，並於terminal中執行 ffmpeg -version 來查看是否成功加入。 下載檔案，直接在 terminal 輸入 ffmpeg -i m3u8URL -c copy filname.mp4，即可完成下載。(下面將提供Python的寫法)  Python # -*- coding: UTF-8 -*- import ffmpeg_streaming from ffmpeg_streaming import Formats url = \u0026#39;https://.../index.m3u8\u0026#39; filename = \u0026#39;test.mp4\u0026#39; def ffmpeg_download(input_path, output_path): video = ffmpeg_streaming.input(input_path) stream = video.stream2file(Formats.h264()) stream.output(output_path) if __name__ == \u0026#34;__main__\u0026#34;: ffmpeg_download(url, \u0026#39;./\u0026#39; + filename)  下一篇將教你如何直接從 m3u8 裡讀取目錄，並使用多線程下載 ts 並合併成 mp4  ","date":"2020-10-04T11:07:24+08:00","permalink":"https://blog.smallten.tk/p/python-03/","title":"Python-03：m3u8影片下載"},{"content":"Hello World #include \u0026lt;stdio.h\u0026gt;//Your first code. int main(){ printf(\u0026#34;Hello World\\n\u0026#34;); return 0; }  main是每個C程式的進入點，我們稱它為main function(主函式) int 及 return 是C裡面的Keywords  int代表這個函式將會回傳一個整數 每個函式都應該有一個回傳值   每個敘述的結尾都應該要有 ; printf 是一個會顯示格式化字串的函式 \\n -\u0026gt; 換行 \\t -\u0026gt; tab \\\\ -\u0026gt; \\ \\\u0026quot; -\u0026gt; “ # 的那一行是C的預處理器並且不需要;結尾 stdio.h -\u0026gt; standard input / output header(標準輸出/輸入標頭檔) 註解 -\u0026gt; 是給開發者看的  //Your code -\u0026gt; 單行 /*Your code*/ -\u0026gt; 多行      使用編譯器將程式碼編譯成組合語言，再由組譯器組議成機械碼或可執行的二進制檔 IDE -\u0026gt; Integrated Development Environment，不是編譯器 gcc是最受歡迎的C編譯器之一(不完全對!!因為它不只做了編譯的動作…) 一些基本的Linux的操作指令  man -\u0026gt; 不會就問那個男人吧，男人不會就Google ls cd rm pwd   gcc main.c 一些參數  -o -v -g -Wall -Wextra -O2 or -Og    Makefile all: gcc main.c -o main clean: rm -rf main  make 將執行all下的指令 中間縮排應為Tab而不是Space make clean 預設可執行的檔名為 makefile，Makefile，GNUmakefile，若為其他可下 -f 的參數  ","date":"2020-10-04T11:00:48+08:00","permalink":"https://blog.smallten.tk/p/computer_programming_1-01/","title":"程式設計(一)-01：Your first program"},{"content":"簡介  接續上一篇Python-01：爬蟲-圖片下載的內容，這篇文章將帶領大家使用多線程來加速圖片的下載  教學開始  首先我們先看個簡單的多線程範例  import time, threading # 子執行緒的工作函數 def job(): for i in range(5): print(\u0026#34;Child thread:\u0026#34;, i) time.sleep(1) # 建立一個子執行緒 t = threading.Thread(target = job) # 執行該子執行緒 t.start() # 主執行緒繼續執行自己的工作 for i in range(3): print(\u0026#34;Main thread:\u0026#34;, i) time.sleep(1) # 等待 t 這個子執行緒結束 t.join() print(\u0026#34;Done.\u0026#34;) import time, threading # 子執行緒的工作函數 def job(num): print(\u0026#34;Thread\u0026#34;, num) time.sleep(1) # 建立 5 個子執行緒 threads = [] for i in range(5): threads.append(threading.Thread(target = job, args = (i,))) threads[i].start() # 主執行緒繼續執行自己的工作 # 等待所有子執行緒結束 for i in range(5): threads[i].join() print(\u0026#34;Done.\u0026#34;)  接下來我們修改Python-01：爬蟲-圖片下載中下載圖片那部分的程式碼  th_list = [] for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; th = threading.Thread(target=download_img, args=(img, i)) th.start() th_list.append(th) for th in th_list: th.join() 完整程式碼 # -*- coding: UTF-8 -*- from selenium import webdriver from bs4 import BeautifulSoup import requests, threading def download_img(img, num): r = requests.get(img) with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) if __name__ == \u0026#34;__main__\u0026#34;: save_url = \u0026#39;./test/\u0026#39; url = \u0026#39;https://www.ohmanhua.com/13621/1/1.html\u0026#39; chop = webdriver.ChromeOptions() chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) soup = BeautifulSoup(browser.page_source, \u0026#39;lxml\u0026#39;) img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) if img_url[0] == \u0026#39;/\u0026#39;: img_url = \u0026#39;https:\u0026#39; + img_url m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; th_list = [] for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; th = threading.Thread(target=download_img, args=(img, i)) th.start() th_list.append(th) for th in th_list: th.join() browser.quit() ","date":"2020-08-03T00:56:43+08:00","permalink":"https://blog.smallten.tk/p/python-02/","title":"Python-02：多線程-加速圖片下載"},{"content":"簡介  這一篇將帶領大家透過Python的爬蟲自動化的下載圖片  安裝  打開終端機，安裝下列套件  pip install requests pip install BeautifulSoup4 pip install lxml pip install selenium   至 Chrome Driver 下載當前電腦中Chrome所對應版本的Driver  教學開始  首先因為這次的主題為圖片下載，因此我們找了一個擁有大量圖片的漫畫網頁來進行教學。 由於這個網頁的圖片是由JavaScript加載的，因此一開始我們使用Selenium來開啟網頁 from selenium import webdriver url = \u0026#39;https://www.ohmanhua.com/13621/1/1.html\u0026#39; #使用crx插件 chop = webdriver.ChromeOptions() chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url)  當然若不想顯示瀏覽器的視窗可以使用headless模式  chop.add_argument(\u0026#39;--headless\u0026#39;) #規避google bug chop.add_argument(\u0026#39;--disable-gpu\u0026#39;)  接下來使用BeautifulSoup4來分析頁面，並取得圖片網址，和共幾張圖片  img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) if img_url[0] == \u0026#39;/\u0026#39;: img_url = \u0026#39;https:\u0026#39; + img_url m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39;  最後便是下載圖片和關閉瀏覽器  def download_img(img, num): r = requests.get(img) with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; download_img(img, i) browser.quit() 完整程式碼 # -*- coding: UTF-8 -*- from selenium import webdriver from bs4 import BeautifulSoup import requests def download_img(img, num): r = requests.get(img) with open(save_url + str(num+1) + \u0026#39;.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(r.content) if __name__ == \u0026#34;__main__\u0026#34;: save_url = \u0026#39;./download/\u0026#39; url = \u0026#39;\u0026#39; chop = webdriver.ChromeOptions() chop.add_extension(\u0026#39;Adblock-Plus_v3.8.4.crx\u0026#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) soup = BeautifulSoup(browser.page_source, \u0026#39;lxml\u0026#39;) img_count = int(soup.find(\u0026#39;select\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_select\u0026#39;}).find_all(\u0026#39;option\u0026#39;)[-1].get(\u0026#39;value\u0026#39;)) img_url = soup.find_all(\u0026#39;div\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;mh_comicpic\u0026#39;})[0].find(\u0026#39;img\u0026#39;).get(\u0026#39;src\u0026#39;) if img_url[0] == \u0026#39;/\u0026#39;: img_url = \u0026#39;https:\u0026#39; + img_url m = len(img_url.rsplit(\u0026#39;/\u0026#39;, 1)[1].split(\u0026#39;.\u0026#39;)[0]) img_url = img_url.rsplit(\u0026#39;/\u0026#39;, 1)[0] + \u0026#39;/\u0026#39; for i in range(img_count): img = img_url + str(i + 1).zfill(m) + \u0026#39;.jpg\u0026#39; download_img(img, i) browser.quit() ","date":"2020-08-03T00:39:24+08:00","permalink":"https://blog.smallten.tk/p/python-01/","title":"Python-01：爬蟲-圖片下載"},{"content":"簡介  這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作在Raspberry pi用Python讀取Arduino Serial的數值，並且製作一個簡易的UI實時顯示出數值。  硬體  上一小節的成品 Raspberry pi * 1  教學開始  打開Raspberry pi的Terminal，並輸入 ls /dev/tty* 將Arduino的Usb接上Raspberry pi 再次於Terminal中輸入 ls /dev/tty*，比較兩次的差異，即可知Arduino使用的序列埠為何(例如此時為/ dev/ttyACM0，請依照情況自行修改) 於Terminal中輸入 python3 -m pip install pyserial 將以下程式碼建立成一個python檔，再以python3執行即可  # -*- coding: UTF-8 -*- import serial import tkinter as tk def getData(): ser = serial.Serial(\u0026#39;/dev/ttyACM0\u0026#39;, 9600, timeout=1) ser.flush() while True: flag = False if ser.in_waiting\u0026gt;0: arduinoData = ser.readline().decode(encoding=\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;).rstrip().split(\u0026#39;;\u0026#39;) if len(arduinoData)!=4 or arduinoData==\u0026#39;\u0026#39;: continue for i in range(0,3): if arduinoData[i]==\u0026#39;0\u0026#39;: flag = True break if flag: continue else: temperature_value[\u0026#39;text\u0026#39;] = arduinoData[0] + \u0026#39; 度C\u0026#39; humidity_value[\u0026#39;text\u0026#39;] = arduinoData[1] + \u0026#39; %\u0026#39; pmat25_value[\u0026#39;text\u0026#39;] = arduinoData[2] + \u0026#39; ug/m^3\u0026#39; wind_value[\u0026#39;text\u0026#39;] = arduinoData[3] + \u0026#39; 級\u0026#39; break window.after(1000, getData) if __name__==\u0026#39;__main__\u0026#39;: window = tk.Tk() window.title(\u0026#39;Weather\u0026#39;) window.geometry(\u0026#39;500x250\u0026#39;) window.resizable(False, False) header_label = tk.Label(window, text=\u0026#39;環境監測\u0026#39;, font=(\u0026#39;Arial\u0026#39;, 20), width=30, height=2, borderwidth=2, relief=\u0026#39;solid\u0026#39;) header_label.pack(side=tk.TOP) temperature_frame = tk.Frame(window) temperature_frame.pack(side=tk.TOP) temperature_label = tk.Label(temperature_frame, text=\u0026#39;溫度: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) temperature_label.pack(side=tk.LEFT) temperature_value = tk.Label(temperature_frame, font=(\u0026#39;Arial\u0026#39;, 16)) temperature_value.pack(side=tk.LEFT) humidity_frame = tk.Frame(window) humidity_frame.pack(side=tk.TOP) humidity_label = tk.Label(humidity_frame, text=\u0026#39;濕度: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) humidity_label.pack(side=tk.LEFT) humidity_value = tk.Label(humidity_frame, font=(\u0026#39;Arial\u0026#39;, 16)) humidity_value.pack(side=tk.LEFT) pmat25_frame = tk.Frame(window) pmat25_frame.pack(side=tk.TOP) pmat25_label = tk.Label(pmat25_frame, text=\u0026#39;PM2.5: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) pmat25_label.pack(side=tk.LEFT) pmat25_value = tk.Label(pmat25_frame, font=(\u0026#39;Arial\u0026#39;, 16)) pmat25_value.pack(side=tk.LEFT) wind_frame = tk.Frame(window) wind_frame.pack(side=tk.TOP) wind_label = tk.Label(wind_frame, text=\u0026#39;風速: \u0026#39;, font=(\u0026#39;Arial\u0026#39;, 16)) wind_label.pack(side=tk.LEFT) wind_value = tk.Label(wind_frame, font=(\u0026#39;Arial\u0026#39;, 16)) wind_value.pack(side=tk.LEFT) getData() window.mainloop()  最終成果圖    ","date":"2020-07-12T09:31:38+08:00","permalink":"https://blog.smallten.tk/p/weather-02/","title":"簡易氣象站-02"},{"content":"簡介  這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作由Arduino抓取感測器數值的部分。  硬體  Arduino Uno R3 * 1 攀藤 G5 PMS5003 * 1 DFrobot 三杯式風速感測器 * 1  教學開始 連結電路  \nUno程式碼 #include \u0026lt;SoftwareSerial.h\u0026gt;#define windPin A0 SoftwareSerial pmsSerial(2, 3); long pmValue=0; long pmcf25=0; long pmat25=0; unsigned int temperature = 0; unsigned int humandity = 0; void retrievepm25(){ int count = 0; unsigned char c; unsigned char high; while (pmsSerial.available()) { c = pmsSerial.read(); if((count==0 \u0026amp;\u0026amp; c!=0x42) || (count==1 \u0026amp;\u0026amp; c!=0x4d)) break; if(count \u0026gt; 27) break; else if(count == 4 || count == 6 || count == 8 || count == 10 || count == 12 || count == 14 || count == 24 || count == 26) high = c; else if(count == 7){ pmcf25 = 256*high + c; pmValue = pmcf25; } else if(count == 13){ pmat25 = 256*high + c; pmValue = pmat25; } else if(count == 25) temperature = (256*high + c)/10; else if(count == 27) humandity = (256*high + c)/10; count++; } while(pmsSerial.available()) pmsSerial.read(); } void setup() { Serial.begin(9600); pmsSerial.begin(9600); } void loop() { retrievepm25(); Serial.print(temperature); Serial.print(\u0026#34;;\u0026#34;); Serial.print(humandity); Serial.print(\u0026#34;;\u0026#34;); Serial.print(pmat25); int windValue = analogRead(windPin); int Level = 6 * windValue * (5.0 / 1023.0); Serial.print(\u0026#34;;\u0026#34;); Serial.print(Level); Serial.println(); delay(1000); } ","date":"2020-07-12T09:02:34+08:00","permalink":"https://blog.smallten.tk/p/weather-01/","title":"簡易氣象站-01"},{"content":"簡介  這篇內容將教大家透過Arduino的序列埠設定HC-05的AT命令  硬體  Arduino Uno * 1 HC-05藍芽模組 * 1  教學 腳位連接    Arduino HC-05     5V VCC   GND GND   8 TX   9 RX    程式碼 #include \u0026lt;SoftwareSerial.h\u0026gt; SoftwareSerial BT(8, 9); char val; void setup() { Serial.begin(9600); BT.begin(38400); } void loop() { if(Serial.available()){ val = Serial.read(); BT.print(val); } if(BT.available()){ val = BT.read(); Serial.print(val); } }  連接腳位，並上傳程式碼，最後給HC-05供電前，先按住上面的按鈕，再提供電源，燈號將變成約兩秒一閃，及表示進入了AT命令模式 接下來打開序列埠監控視窗，將設定調成\u0026quot;9600 baud\u0026quot;和\u0026quot;NL與CR\u0026quot;，最後依需求輸入以下命令即可   AT -\u0026gt; 顯示OK表示連接成功 查看韌體版本 -\u0026gt; AT+VERSION 查看名稱 -\u0026gt; AT+NAME? 修改名稱 -\u0026gt; AT+NAME=你要的名字 查看密碼 -\u0026gt; AT+PSWD? 修改密碼 -\u0026gt; AT+PSWD=你要的密碼  ","date":"2020-05-10T21:56:45+08:00","permalink":"https://blog.smallten.tk/p/arduino-05/","title":"Arduino-05：HC-05 AT命令"},{"content":"簡介  這篇內容將帶領大家製作藍芽的遙控車，並且用Blynk的Joystick操控它  硬體  Arduino nano * 1 L298N 馬達控制板 * 1 HC-05 藍芽模組 * 1 二輪直流馬達遙控車 * 1  下載  至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫  教學開始  先上傳程式碼至Nano板中 依照下方圖示連接腳位，並且設定Blynk App內的物件  連接腳位  \n設定Blynk  創建3個元件，分別為Button、Bluetooth、Joystick，並且依下圖進行設置      nano程式碼 #include \u0026lt;BlynkSimpleSerialBLE.h\u0026gt;#define BLYNK_USE_DIRECT_CONNECT  char auth[] = \u0026#34;Blynk Auth\u0026#34;; int d[2] = {0}; int car[2][2] = { {5, 6}, {11, 10} }; //in 1,2,4,3 int en[2] = {3, 9}; void Controller(); void Move(int, int, int, int, int, int); BLYNK_WRITE(V0){ for(int i=0; i\u0026lt;2; ++i){ d[i] = param[i].asInt(); if(d[i]\u0026lt;=64) d[i] = d[i]*2-255; else if(d[i]\u0026gt;64 \u0026amp;\u0026amp; d[i]\u0026lt;=192) d[i]=0; } } void setup() { Serial.begin(9600); Blynk.begin(Serial, auth); for(int i=0; i\u0026lt;2; ++i){ pinMode(en[i], OUTPUT); for(int j=0; j\u0026lt;2; ++j){ pinMode(car[i][j], OUTPUT); } } } void loop() { Blynk.run(); Controller(); } void Controller() { if(d[0]\u0026gt;0){ if(d[1]\u0026gt;0) Move(0, 1, 1, 0, min(d[0], d[1]), max(d[0], d[1])); else if(d[1]==0) Move(0, 0, 1, 0, 0, d[0]); else Move(1, 0, 0, 1, min(d[0], abs(d[1])), max(d[0], abs(d[1]))); } else if(d[0]==0){ if(d[1]\u0026gt;0) Move(1, 0, 1, 0, d[1], d[1]); else if(d[1]==0) Move(0, 0, 0, 0, 0, 0); else Move(0, 1, 0, 1, abs(d[1]), abs(d[1])); } else{ if(d[1]\u0026gt;0) Move(1, 0, 0, 1, max(abs(d[0]), d[1]), min(abs(d[0]), d[1])); else if(d[1]==0) Move(1, 0, 0, 0, abs(d[0]), 0); else Move(0, 1, 1, 0, max(abs(d[0]), abs(d[1])), min(abs(d[0]), abs(d[1]))); } } void Move(int a1,int a2, int a3, int a4, int e1, int e2) { digitalWrite(car[0][0], a1); digitalWrite(car[0][1], a2); digitalWrite(car[1][0], a3); digitalWrite(car[1][1], a4); analogWrite(en[0], e1); analogWrite(en[1], e2); } 補充  由於這邊我們將HC-05和Nano板的RX、TX對接，因此自行修改程式碼後要重新上傳時，記得先移除連接Nano板的那兩條線，當然也可使用SoftwareSerial Library來進行，就不用拔除線路了 若要自行修改HC-05的設定，可參考下一篇文章 ARDUINO-05：HC-05 AT命令  ","date":"2020-05-03T16:29:01+08:00","permalink":"https://blog.smallten.tk/p/arduino-04/","title":"Arduino-04：藍芽遙控車"},{"content":"簡介  這篇內容將帶領大家製作點陣跑馬燈，並且用Blynk來操控它  硬體  WeMos D1R2 * 1 MAX7219 8*8LED點陣模組 * 2  下載  至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 maxmatrix－下載並加入函式庫  教學開始 連接腳位    MAX7219 D1R2     VCC 5V   GND GND   DIN MOSI/D7   CS SS/D8   CLK SCK/D5     若要串聯多塊MAX7219的話，請將下一塊的DIN接至上一塊的DOUT連接腳位  設定Blynk  請照下圖拉出三個物件，並設定其相關參數      D1R2程式碼 #include \u0026lt;MaxMatrix.h\u0026gt;#include \u0026lt;avr/pgmspace.h\u0026gt;#include \u0026lt;ESP8266WiFi.h\u0026gt;#include \u0026lt;BlynkSimpleEsp8266.h\u0026gt; char auth[] = \u0026#34;Blynk auth\u0026#34;; char ssid[] = \u0026#34;Wifi ssid\u0026#34;; char pass[] = \u0026#34;Wifi password\u0026#34;; PROGMEM const unsigned char CH[] = { 3, 8, B0000000, B0000000, B0000000, B0000000, B0000000, // space  1, 8, B1011111, B0000000, B0000000, B0000000, B0000000, // !  3, 8, B0000011, B0000000, B0000011, B0000000, B0000000, // \u0026#34;  5, 8, B0010100, B0111110, B0010100, B0111110, B0010100, // #  4, 8, B0100100, B1101010, B0101011, B0010010, B0000000, // $  5, 8, B1100011, B0010011, B0001000, B1100100, B1100011, // %  5, 8, B0110110, B1001001, B1010110, B0100000, B1010000, // \u0026amp;  1, 8, B0000011, B0000000, B0000000, B0000000, B0000000, // \u0026#39;  3, 8, B0011100, B0100010, B1000001, B0000000, B0000000, // (  3, 8, B1000001, B0100010, B0011100, B0000000, B0000000, // )  5, 8, B0101000, B0011000, B0001110, B0011000, B0101000, // *  5, 8, B0001000, B0001000, B0111110, B0001000, B0001000, // +  2, 8, B10110000, B1110000, B0000000, B0000000, B0000000, // ,  4, 8, B0001000, B0001000, B0001000, B0001000, B0000000, // -  2, 8, B1100000, B1100000, B0000000, B0000000, B0000000, // .  4, 8, B1100000, B0011000, B0000110, B0000001, B0000000, // /  4, 8, B0111110, B1000001, B1000001, B0111110, B0000000, // 0  3, 8, B1000010, B1111111, B1000000, B0000000, B0000000, // 1  4, 8, B1100010, B1010001, B1001001, B1000110, B0000000, // 2  4, 8, B0100010, B1000001, B1001001, B0110110, B0000000, // 3  4, 8, B0011000, B0010100, B0010010, B1111111, B0000000, // 4  4, 8, B0100111, B1000101, B1000101, B0111001, B0000000, // 5  4, 8, B0111110, B1001001, B1001001, B0110000, B0000000, // 6  4, 8, B1100001, B0010001, B0001001, B0000111, B0000000, // 7  4, 8, B0110110, B1001001, B1001001, B0110110, B0000000, // 8  4, 8, B0000110, B1001001, B1001001, B0111110, B0000000, // 9  2, 8, B01010000, B0000000, B0000000, B0000000, B0000000, // :  2, 8, B10000000, B01010000, B0000000, B0000000, B0000000, // ;  3, 8, B0010000, B0101000, B1000100, B0000000, B0000000, // \u0026lt;  3, 8, B0010100, B0010100, B0010100, B0000000, B0000000, // =  3, 8, B1000100, B0101000, B0010000, B0000000, B0000000, // \u0026gt;  4, 8, B0000010, B1011001, B0001001, B0000110, B0000000, // ?  5, 8, B0111110, B1001001, B1010101, B1011101, B0001110, // @  4, 8, B1111110, B0010001, B0010001, B1111110, B0000000, // A  4, 8, B1111111, B1001001, B1001001, B0110110, B0000000, // B  4, 8, B0111110, B1000001, B1000001, B0100010, B0000000, // C  4, 8, B1111111, B1000001, B1000001, B0111110, B0000000, // D  4, 8, B1111111, B1001001, B1001001, B1000001, B0000000, // E  4, 8, B1111111, B0001001, B0001001, B0000001, B0000000, // F  4, 8, B0111110, B1000001, B1001001, B1111010, B0000000, // G  4, 8, B1111111, B0001000, B0001000, B1111111, B0000000, // H  3, 8, B1000001, B1111111, B1000001, B0000000, B0000000, // I  4, 8, B0110000, B1000000, B1000001, B0111111, B0000000, // J  4, 8, B1111111, B0001000, B0010100, B1100011, B0000000, // K  4, 8, B1111111, B1000000, B1000000, B1000000, B0000000, // L  5, 8, B1111111, B0000010, B0001100, B0000010, B1111111, // M  5, 8, B1111111, B0000100, B0001000, B0010000, B1111111, // N  4, 8, B0111110, B1000001, B1000001, B0111110, B0000000, // O  4, 8, B1111111, B0001001, B0001001, B0000110, B0000000, // P  4, 8, B0111110, B1000001, B1000001, B10111110, B0000000, // Q  4, 8, B1111111, B0001001, B0001001, B1110110, B0000000, // R  4, 8, B1000110, B1001001, B1001001, B0110010, B0000000, // S  5, 8, B0000001, B0000001, B1111111, B0000001, B0000001, // T  4, 8, B0111111, B1000000, B1000000, B0111111, B0000000, // U  5, 8, B0001111, B0110000, B1000000, B0110000, B0001111, // V  5, 8, B0111111, B1000000, B0111000, B1000000, B0111111, // W  5, 8, B1100011, B0010100, B0001000, B0010100, B1100011, // X  5, 8, B0000111, B0001000, B1110000, B0001000, B0000111, // Y  4, 8, B1100001, B1010001, B1001001, B1000111, B0000000, // Z  2, 8, B1111111, B1000001, B0000000, B0000000, B0000000, // [  4, 8, B0000001, B0000110, B0011000, B1100000, B0000000, // backslash  2, 8, B1000001, B1111111, B0000000, B0000000, B0000000, // ]  3, 8, B0000010, B0000001, B0000010, B0000000, B0000000, // hat  4, 8, B1000000, B1000000, B1000000, B1000000, B0000000, // _  2, 8, B0000001, B0000010, B0000000, B0000000, B0000000, // `  4, 8, B0100000, B1010100, B1010100, B1111000, B0000000, // a  4, 8, B1111111, B1000100, B1000100, B0111000, B0000000, // b  4, 8, B0111000, B1000100, B1000100, B0101000, B0000000, // c  4, 8, B0111000, B1000100, B1000100, B1111111, B0000000, // d  4, 8, B0111000, B1010100, B1010100, B0011000, B0000000, // e  3, 8, B0000100, B1111110, B0000101, B0000000, B0000000, // f  4, 8, B10011000, B10100100, B10100100, B01111000, B0000000, // g  4, 8, B1111111, B0000100, B0000100, B1111000, B0000000, // h  3, 8, B1000100, B1111101, B1000000, B0000000, B0000000, // i  4, 8, B1000000, B10000000, B10000100, B1111101, B0000000, // j  4, 8, B1111111, B0010000, B0101000, B1000100, B0000000, // k  3, 8, B1000001, B1111111, B1000000, B0000000, B0000000, // l  5, 8, B1111100, B0000100, B1111100, B0000100, B1111000, // m  4, 8, B1111100, B0000100, B0000100, B1111000, B0000000, // n  4, 8, B0111000, B1000100, B1000100, B0111000, B0000000, // o  4, 8, B11111100, B0100100, B0100100, B0011000, B0000000, // p  4, 8, B0011000, B0100100, B0100100, B11111100, B0000000, // q  4, 8, B1111100, B0001000, B0000100, B0000100, B0000000, // r  4, 8, B1001000, B1010100, B1010100, B0100100, B0000000, // s  3, 8, B0000100, B0111111, B1000100, B0000000, B0000000, // t  4, 8, B0111100, B1000000, B1000000, B1111100, B0000000, // u  5, 8, B0011100, B0100000, B1000000, B0100000, B0011100, // v  5, 8, B0111100, B1000000, B0111100, B1000000, B0111100, // w  5, 8, B1000100, B0101000, B0010000, B0101000, B1000100, // x  4, 8, B10011100, B10100000, B10100000, B1111100, B0000000, // y  3, 8, B1100100, B1010100, B1001100, B0000000, B0000000, // z  3, 8, B0001000, B0110110, B1000001, B0000000, B0000000, // {  1, 8, B1111111, B0000000, B0000000, B0000000, B0000000, // |  3, 8, B1000001, B0110110, B0001000, B0000000, B0000000, // }  4, 8, B0001000, B0000100, B0001000, B0000100, B0000000, // ~ }; const byte data = D7; const byte cs = D8; const byte clk = D5; const byte maxInUse = 2; //使用的點陣模塊數量 MaxMatrix m(data, cs, clk, maxInUse); byte buffer[8]; String str; int speed = 100; //移動的速度，單位ms int light = 5; bool islight = false; void printChar(char); BLYNK_WRITE(V0){ str = param.asStr(); for(int i=0; i\u0026lt;maxInUse; ++i) str+=\u0026#34; \u0026#34;; } BLYNK_WRITE(V1){ light = param.asInt(); islight = true; } BLYNK_WRITE(V2){ speed = param.asInt(); } void setup() { Serial.begin(115200); //Blynk  Blynk.begin(auth, ssid, pass); Blynk.virtualWrite(V1, light); Blynk.virtualWrite(V2, speed); //8*8 led  m.init(); m.setIntensity(light); //點陣模組的亮度 } void loop() { if(Blynk.connected()){ Blynk.run(); if(islight){ m.setIntensity(light); islight = false; } int len = str.length(); for(int i=0; i\u0026lt;len; ++i){ printChar(str[i]); } } else{ Blynk.begin(auth, ssid, pass); Serial.println(\u0026#34;Reconnected!\u0026#34;); } } void printChar(char c) { if(c\u0026lt;32) return; c-=32; memcpy_P(buffer, CH+7*c, 7); m.writeSprite(32, 0, buffer); m.setColumn(32+buffer[0], 0); for(int i=0; i\u0026lt;=buffer[0]; ++i){ delay(speed); /*往左位移，第一個參數false，代表不旋轉； 第二個參數false，代表不清空顯示；若設成true，顯示器將不呈現資料。*/ m.shiftLeft(false, false); } } 補充  若是覺得Blynk的能量太少，可自行架設 Server  ","date":"2020-04-09T14:50:56+08:00","permalink":"https://blog.smallten.tk/p/arduino-03/","title":"Arduino-03：跑馬燈"},{"content":"簡介  這篇內容將帶領大家把Arduino手把變成電腦手把  所需硬體  Arduino Uno R3 * 1 JoyStick 雙軸按鍵搖桿模組 * 1  下載檔案  FLIP － 請下載包含JRE的檔案(Java Runtime Environment included) UnoJoy － 將Uno變成電腦手把 x360ce － 將手把模擬成xbox 360的手把  教學開始  將下載好的FLIP安裝至電腦 確定電腦已安裝Arduino IDE，並已連接Uno板至電腦，可在裝置管理員查看狀態（如下圖）   打開剛剛下載的UnoJoy資料夾下的檔案，並將它上傳進Uno板中 UnoJoy-master\\UnoJoy\\UnoJoyArduinoSample\\UnoJoyArduinoSample.ino 關閉Arduino IDE，進入DFU Mode，進入方式：用導線同時接觸下圖框起處的兩根針腳   確認已進入 DFU Mode，如下圖    若找不到驅動可手動新增驅動，選擇資料夾為 C:\\Program Files (x86)\\Atmel\\Flip 3.4.7\\usb   打開UnoJoy資料夾，啟動TurnIntoAJoystick的批次檔，檔案路徑 UnoJoy-master\\UnoJoy\\TurnIntoAJoystick.bat，執行成功結果如下圖   至此已完成將Uno變成電腦搖桿，之後插上Uno板皆為UnoJoy Joystick，可在以下路徑查看 控制台\\硬體和音效\\裝置和印表機 將搖桿的vrx和vry分別連接至Uno板的A0和A1，在 控制台\\硬體和音效\\裝置和印表機 裡的UnoJoy Joystick圖示上右鍵-\u0026gt;遊戲控制器-\u0026gt;內容，可查看搖桿狀態，如下圖   最後進入起動x360ce，新建立一個搖桿的設定檔，並選取模擬的位置，點選[Record]，依圖示移動搖桿方向即設定完成  補充  如何將UnoJoy Joystick變回一般的Arduino Uno板  連接UnoJoy Joystick，並進入DFU Mode 打開UnoJoy資料夾，啟動TurnIntoAnArduino的批次檔，檔案路徑 UnoJoy-master\\UnoJoy\\TurnIntoAnArduino.bat 將Uno的usb重新接上電腦，即可看到已變回   如果UnoJoy檔案下載太慢，可至 這裡 下載，但此載點內容僅包含uno板的檔案（Github的檔案裡包含其他板子變成手把的檔案，故檔案相對較大） 如何在電腦遊戲中使用此手把  將剛剛x360ce創建的兩個檔案（x360ce.ini/xinput.dll）放進遊戲資料夾的根目錄即可   此範例檔案預設搖桿資訊  A0~A1 － 為左搖桿的x，y A2~A3 － 為右搖桿的x，y D2~D5 － 為PS搖桿的右側功能鍵 D6~D9 － 為PS搖桿的左側方向鍵 D10~D11 － 為PS搖桿的L1R1 D12 － select A4 － start A5 － home 但由於是模擬成xbox的手把，故可自由接線，再由x360ce中直接[Record]即可 若是腳位不夠可自行替換成mega板    ","date":"2020-04-09T08:16:57+08:00","permalink":"https://blog.smallten.tk/p/arduino-02/","title":"Arduino-02：UNOJOY"},{"content":"官方IDE  此IDE由官方提供，可在此查看官網 下載－官方載點    VSCode + PlatformIO  先下載 VSCode 再安裝 PlatformIO 的插件    ","date":"2020-04-09T08:08:43+08:00","permalink":"https://blog.smallten.tk/p/arduino-01/","title":"Arduino-01：安裝IDE"}]