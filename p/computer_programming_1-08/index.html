<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Pointer  許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分    指標是一個變數，其值為記憶體位置   宣告：int32_t *p  p 是一個指標 指向的記憶體區塊被視為整數   初始化：int32_t *p = NULL address operator &amp;amp;：返回其變數的記憶體位置  如果想要印出記憶體位置，你可以使用%p   indirection operator *：也被稱為dereferencing operator，返回指向對象的值   void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別  傳參數至函式  在C語言中，argument passing 稱為 call-by-value  電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行   這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。  陣列與指標  在大部分的情況下，我們可以把array視為第一個元素的指標  現在你應該明白為什麼陣列的值會在函式中被修改   為了避免模棱兩可(搞混)，我較喜歡&amp;amp;(array[0])而不是array、&amp;amp;array 然而你不能寫出 array = &amp;amp;a int32_t   int16_t   int8_t   ptr++  移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用   事實上，array[n] = *(ptr + n)  Endian Issue"><title>程式設計(一)-08：Pointer</title><link rel=canonical href=https://blog.smallten.tk/p/computer_programming_1-08/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="程式設計(一)-08：Pointer"><meta property="og:description" content="Pointer  許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分    指標是一個變數，其值為記憶體位置   宣告：int32_t *p  p 是一個指標 指向的記憶體區塊被視為整數   初始化：int32_t *p = NULL address operator &amp;amp;：返回其變數的記憶體位置  如果想要印出記憶體位置，你可以使用%p   indirection operator *：也被稱為dereferencing operator，返回指向對象的值   void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別  傳參數至函式  在C語言中，argument passing 稱為 call-by-value  電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行   這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。  陣列與指標  在大部分的情況下，我們可以把array視為第一個元素的指標  現在你應該明白為什麼陣列的值會在函式中被修改   為了避免模棱兩可(搞混)，我較喜歡&amp;amp;(array[0])而不是array、&amp;amp;array 然而你不能寫出 array = &amp;amp;a int32_t   int16_t   int8_t   ptr++  移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用   事實上，array[n] = *(ptr + n)  Endian Issue"><meta property="og:url" content="https://blog.smallten.tk/p/computer_programming_1-08/"><meta property="og:site_name" content="小十的部落格"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="C"><meta property="article:published_time" content="2020-12-23T19:38:14+08:00"><meta property="article:modified_time" content="2020-12-23T19:38:14+08:00"><meta name=twitter:title content="程式設計(一)-08：Pointer"><meta name=twitter:description content="Pointer  許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分    指標是一個變數，其值為記憶體位置   宣告：int32_t *p  p 是一個指標 指向的記憶體區塊被視為整數   初始化：int32_t *p = NULL address operator &amp;amp;：返回其變數的記憶體位置  如果想要印出記憶體位置，你可以使用%p   indirection operator *：也被稱為dereferencing operator，返回指向對象的值   void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別  傳參數至函式  在C語言中，argument passing 稱為 call-by-value  電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行   這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。  陣列與指標  在大部分的情況下，我們可以把array視為第一個元素的指標  現在你應該明白為什麼陣列的值會在函式中被修改   為了避免模棱兩可(搞混)，我較喜歡&amp;amp;(array[0])而不是array、&amp;amp;array 然而你不能寫出 array = &amp;amp;a int32_t   int16_t   int8_t   ptr++  移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用   事實上，array[n] = *(ptr + n)  Endian Issue"><script async src="https://www.googletagmanager.com/gtag/js?id=G-RPR56CRPCG"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-RPR56CRPCG');</script><link rel=stylesheet href=https://blog.smallten.tk/css/copy-to-clipboard.css><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=/favicon/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><script>(function(){const colorSchemeKey='StackColorScheme';if(!localStorage.getItem(colorSchemeKey)){localStorage.setItem(colorSchemeKey,"auto");}})();</script><script>(function(){const colorSchemeKey='StackColorScheme';const colorSchemeItem=localStorage.getItem(colorSchemeKey);const supportDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches===true;if(colorSchemeItem=='dark'||colorSchemeItem==='auto'&&supportDarkMode){document.body.dataset.scheme='dark';}else{document.body.dataset.scheme='light';}})();</script><div class="container main-container flex on-phone--column extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/header_hu4cfb69605c22b48cecb92135d5094273_5680_300x0_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></figure><h1 class=site-name><a href=https://blog.smallten.tk/>小十的部落格</a></h1><h2 class=site-description>教學、資訊分享、生活記趣</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://blog.smallten.tk/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E4%B8%80/>程式設計(一)</a></header><h2 class=article-title><a href=/p/computer_programming_1-08/>程式設計(一)-08：Pointer</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Dec 23, 2020</time></footer></div></header><section class=article-content><h1 id=pointer>Pointer</h1><ul><li>許多人不喜歡C是因為有「指標」</li><li>這可能是C中最困難的一個部分</li></ul><hr><ul><li>指標是一個變數，其值為記憶體位置<figure style=flex-grow:129;flex-basis:310px><a href=/p/computer_programming_1-08/computer_programming_1-08-01.png data-size=624x482><img src=/p/computer_programming_1-08/computer_programming_1-08-01.png srcset="/p/computer_programming_1-08/computer_programming_1-08-01_hu398bb37b63fd8209945f2f56af9b6d3e_23889_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-01_hu398bb37b63fd8209945f2f56af9b6d3e_23889_1024x0_resize_box_2.png 1024w" width=624 height=482 loading=lazy></a></figure></li><li>宣告：<code>int32_t *p</code><ul><li>p 是一個指標</li><li>指向的記憶體區塊被視為整數</li></ul></li><li>初始化：<code>int32_t *p = NULL</code></li><li>address operator <code>&</code>：返回其變數的記憶體位置<ul><li>如果想要印出記憶體位置，你可以使用<code>%p</code></li></ul></li><li>indirection operator <code>*</code>：也被稱為dereferencing operator，返回指向對象的值<figure style=flex-grow:116;flex-basis:278px><a href=/p/computer_programming_1-08/computer_programming_1-08-02.png data-size=560x482><img src=/p/computer_programming_1-08/computer_programming_1-08-02.png srcset="/p/computer_programming_1-08/computer_programming_1-08-02_hu0a8930e11c7536ee883fb5d0dfdd78ad_20157_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-02_hu0a8930e11c7536ee883fb5d0dfdd78ad_20157_1024x0_resize_box_2.png 1024w" width=560 height=482 loading=lazy></a></figure></li><li>void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別</li></ul><h3 id=傳參數至函式>傳參數至函式</h3><ul><li>在C語言中，argument passing 稱為 call-by-value<ul><li>電腦將會分配另一個記憶體區塊</li><li>複製輸入的參數到記憶體區塊</li><li>函式將會在新的記憶體區塊執行</li></ul></li><li>這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。</li><li>在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。</li><li>普遍來說，傳址會比傳值更快。</li></ul><h3 id=陣列與指標>陣列與指標</h3><ul><li>在大部分的情況下，我們可以把array視為第一個元素的指標<ul><li>現在你應該明白為什麼陣列的值會在函式中被修改</li></ul></li><li>為了避免模棱兩可(搞混)，我較喜歡<code>&(array[0])</code>而不是<code>array</code>、<code>&array</code></li><li>然而你不能寫出 <code>array = &a</code></li><li>int32_t<figure style=flex-grow:262;flex-basis:629px><a href=/p/computer_programming_1-08/computer_programming_1-08-03.png data-size=1376x525><img src=/p/computer_programming_1-08/computer_programming_1-08-03.png srcset="/p/computer_programming_1-08/computer_programming_1-08-03_hua4ffcfffdb0d5cbd6f85ca56310f1d36_36032_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-03_hua4ffcfffdb0d5cbd6f85ca56310f1d36_36032_1024x0_resize_box_2.png 1024w" width=1376 height=525 loading=lazy></a></figure></li><li>int16_t<figure style=flex-grow:262;flex-basis:629px><a href=/p/computer_programming_1-08/computer_programming_1-08-04.png data-size=1376x525><img src=/p/computer_programming_1-08/computer_programming_1-08-04.png srcset="/p/computer_programming_1-08/computer_programming_1-08-04_hu92da0828b2a348267cfe3ac686741655_34474_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-04_hu92da0828b2a348267cfe3ac686741655_34474_1024x0_resize_box_2.png 1024w" width=1376 height=525 loading=lazy></a></figure></li><li>int8_t<figure style=flex-grow:262;flex-basis:629px><a href=/p/computer_programming_1-08/computer_programming_1-08-05.png data-size=1376x525><img src=/p/computer_programming_1-08/computer_programming_1-08-05.png srcset="/p/computer_programming_1-08/computer_programming_1-08-05_hub90ffe0d9cbc8b522addb56c1c004a1c_34140_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-05_hub90ffe0d9cbc8b522addb56c1c004a1c_34140_1024x0_resize_box_2.png 1024w" width=1376 height=525 loading=lazy></a></figure></li><li><code>ptr++</code><ul><li>移動的大小是根據指標的型別</li><li>這在要讀取每一byte的詳細資料時非常好用</li></ul></li><li>事實上，<code>array[n] = *(ptr + n)</code></li></ul><h3 id=endian-issue>Endian Issue</h3><p><figure style=flex-grow:235;flex-basis:566px><a href=/p/computer_programming_1-08/computer_programming_1-08-06.png data-size=868x368><img src=/p/computer_programming_1-08/computer_programming_1-08-06.png srcset="/p/computer_programming_1-08/computer_programming_1-08-06_hu7477f6d92b9b5dc7fc8ef441486939e3_22341_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-06_hu7477f6d92b9b5dc7fc8ef441486939e3_22341_1024x0_resize_box_2.png 1024w" width=868 height=368 loading=lazy></a></figure></p><h3 id=函式指標>函式指標</h3><ul><li>指標不過是一個記憶體位址。</li><li>當我們宣告某種類型的指標時，這意味著電腦將將訪問記憶體並根據給定的類型解釋存儲在該位址的值。</li><li>您是否知道函式也存儲在記憶體中？</li><li>使用函式指標時，返回的型別和參數應該要和實際的定義相同。<ul><li>Really??為什麼在編譯時不會產生errors?</li><li>這是個檢查definition的好習慣。</li></ul></li><li>回呼函式 (Callback function)</li><li>你可以用陣列來儲存函式指標
<code>void (*f[3])(int32_t) = {f1, f2, f3};</code></li></ul><hr><ul><li>使用了函式指標的例子<ul><li>Menu Driven</li><li>Driver<div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln>1</span><span class=k>struct</span> <span class=n>file_operations</span> <span class=n>scull_fops</span> <span class=o>=</span> <span class=p>{</span>
<span class=ln>2</span>    <span class=p>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>THIS_MODULE</span> <span class=p>,</span>
<span class=ln>3</span>    <span class=p>.</span><span class=n>llseek</span> <span class=o>=</span> <span class=n>scull_llseek</span> <span class=p>,</span>
<span class=ln>4</span>    <span class=p>.</span><span class=n>read</span> <span class=o>=</span> <span class=n>scull_read</span> <span class=p>,</span>
<span class=ln>5</span>    <span class=p>.</span><span class=n>write</span> <span class=o>=</span> <span class=n>scull_write</span> <span class=p>,</span>
<span class=ln>6</span>    <span class=p>.</span><span class=n>ioctl</span> <span class=o>=</span> <span class=n>scull_ioctl</span> <span class=p>,</span>
<span class=ln>7</span>    <span class=p>.</span><span class=n>open</span> <span class=o>=</span> <span class=n>scull_open</span> <span class=p>,</span>
<span class=ln>8</span>    <span class=p>.</span><span class=n>release</span> <span class=o>=</span> <span class=n>scull_release</span> <span class=p>,</span>
<span class=ln>9</span><span class=p>};</span>
</code></pre></div></li><li>Firewall</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln>1</span><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>hook_func</span><span class=p>(</span>
<span class=ln>2</span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>nf_hook_ops</span> <span class=o>*</span><span class=n>ops</span> <span class=p>,</span>
<span class=ln>3</span>    <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span> <span class=p>,</span>
<span class=ln>4</span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>in</span> <span class=p>,</span>
<span class=ln>5</span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>out</span> <span class=p>,</span>
<span class=ln>6</span>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>okfn</span><span class=p>)(</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=p>)</span>
<span class=ln>7</span><span class=p>)</span>
</code></pre></div></li></ul><h3 id=記憶體管理>記憶體管理</h3><ul><li>記憶體管理<ul><li>分配記憶體當你宣告一個變數</li><li>垃圾回收 ( GC )</li></ul></li><li>為什麼許多現代的程式語言不支援記憶體管理<ul><li>軟體工程師是人類</li><li>人是不可被信任的</li></ul></li><li>然而，如果軟體工程師知道他們在做什麼，那麼他們可以更有效率的管理記憶體</li><li>如果不考慮記憶體，請使用陣列</li><li>如果你想陣列的大小可以被動態的改變，那麼去讀 C++ 並學習如何使用 container</li></ul><hr><h4 id=malloc>malloc</h4><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln>1</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=ln>2</span><span class=cp></span><span class=n>ptr</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=n>size</span><span class=p>);</span>
</code></pre></div><ul><li><code>malloc()</code> 分配 size bytes 並回傳一個指向所分配的記憶體的指標</li><li>記憶體沒有初始化</li><li>若要初始化，請使用 <code>memset</code></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln>1</span><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=ln>2</span><span class=cp></span><span class=n>memset</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=n>size</span><span class=p>);</span>
</code></pre></div><h4 id=calloc>calloc</h4><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln>1</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=ln>2</span><span class=cp></span><span class=n>ptr</span> <span class=o>=</span> <span class=n>calloc</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</code></pre></div><ul><li>在現代的 C 中，你應該使用 <code>calloc</code></li><li>第一個參數：多少個區塊你想去分配?</li><li>第二個參數：每個區塊的大小。</li><li>記憶體被初始化成 <code>0</code></li></ul><h4 id=free>free</h4><p><figure style=flex-grow:191;flex-basis:460px><a href=/p/computer_programming_1-08/computer_programming_1-08-07.png data-size=600x313><img src=/p/computer_programming_1-08/computer_programming_1-08-07.png srcset="/p/computer_programming_1-08/computer_programming_1-08-07_hu4225d066f38677261377ab43a001df66_249554_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-07_hu4225d066f38677261377ab43a001df66_249554_1024x0_resize_box_2.png 1024w" width=600 height=313 loading=lazy></a></figure></p><ul><li><code>free(ptr)</code>：釋放 <code>ptr</code> 指向的記憶體空間，該記憶體空間必須是由之前使用 <code>malloc()、calloc()、realloc()</code> 所回傳的。</li><li>此外，若已經 <code>free(ptr)</code>，再次使用會發生未定義行為。</li></ul><h3 id=double-pointer>Double Pointer</h3><p><figure style=flex-grow:109;flex-basis:263px><a href=/p/computer_programming_1-08/computer_programming_1-08-08.png data-size=751x683><img src=/p/computer_programming_1-08/computer_programming_1-08-08.png srcset="/p/computer_programming_1-08/computer_programming_1-08-08_hu6578b51f70e0abcf77c88775e521c8ab_200051_480x0_resize_box_2.png 480w, /p/computer_programming_1-08/computer_programming_1-08-08_hu6578b51f70e0abcf77c88775e521c8ab_200051_1024x0_resize_box_2.png 1024w" width=751 height=683 loading=lazy></a></figure></p><ul><li>使用場景：<ul><li>在函式中分配記憶體</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln> 1</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=ln> 2</span><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span><span class=ln> 3</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=ln> 4</span><span class=cp></span><span class=kt>void</span> <span class=nf>table</span><span class=p>(</span><span class=n>int32_t</span> <span class=o>**</span><span class=n>pp</span><span class=p>,</span> <span class=n>int32_t</span> <span class=n>n</span><span class=p>){</span>
<span class=ln> 5</span>    <span class=o>*</span><span class=n>pp</span> <span class=o>=</span> <span class=p>(</span><span class=n>int32_t</span> <span class=o>*</span><span class=p>)</span><span class=n>calloc</span><span class=p>(</span><span class=n>n</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>int32_t</span><span class=p>));</span>
<span class=ln> 6</span>    <span class=k>for</span><span class=p>(</span><span class=n>int32_t</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>){</span>
<span class=ln> 7</span>        <span class=k>for</span><span class=p>(</span><span class=n>int32_t</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>){</span>
<span class=ln> 8</span>            <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>pp</span> <span class=o>+</span> <span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span> <span class=o>+</span> <span class=p>(</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>j</span><span class=p>;</span>
<span class=ln> 9</span>        <span class=p>}</span>
<span class=ln>10</span>    <span class=p>}</span>
<span class=ln>11</span><span class=p>}</span>
<span class=ln>12</span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
<span class=ln>13</span>    <span class=n>int32_t</span> <span class=n>number</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln>14</span>    <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>number</span><span class=p>);</span>
<span class=ln>15</span>    <span class=n>int32_t</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=ln>16</span>    <span class=n>table</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ptr</span><span class=p>,</span> <span class=n>number</span><span class=p>);</span>
<span class=ln>17</span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln>18</span><span class=p>}</span>
</code></pre></div><ul><li>分配一個二維陣列</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=ln> 1</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=ln> 2</span><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span><span class=ln> 3</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=ln> 4</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
<span class=ln> 5</span>    <span class=n>size_t</span>  <span class=n>size_row</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>size_column</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln> 6</span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Please enter two integers for row and column: &#34;</span><span class=p>);</span>
<span class=ln> 7</span>    <span class=n>scanf</span><span class=p>(</span> <span class=s>&#34;%lu %lu&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size_row</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>size_column</span> <span class=p>);</span>
<span class=ln> 8</span>    <span class=n>int32_t</span> <span class=o>**</span><span class=n>ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=ln> 9</span>    <span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=n>int32_t</span> <span class=o>**</span><span class=p>)</span><span class=n>calloc</span><span class=p>(</span> <span class=k>sizeof</span><span class=p>(</span> <span class=n>int32_t</span> <span class=o>*</span> <span class=p>),</span> <span class=n>size_row</span> <span class=p>);</span>
<span class=ln>10</span>    <span class=k>for</span><span class=p>(</span> <span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size_row</span> <span class=p>;</span> <span class=n>i</span><span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
<span class=ln>11</span>        <span class=o>*</span><span class=p>(</span> <span class=n>ptr</span> <span class=o>+</span> <span class=n>i</span> <span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=n>int32_t</span> <span class=o>*</span><span class=p>)</span><span class=n>calloc</span><span class=p>(</span> <span class=k>sizeof</span><span class=p>(</span> <span class=n>int32_t</span> <span class=p>),</span> <span class=n>size_column</span> <span class=p>);</span>
<span class=ln>12</span>        <span class=k>for</span><span class=p>(</span> <span class=n>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>size_column</span> <span class=p>;</span> <span class=n>j</span><span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
<span class=ln>13</span>            <span class=o>*</span><span class=p>(</span> <span class=o>*</span><span class=p>(</span> <span class=n>ptr</span> <span class=o>+</span> <span class=n>i</span> <span class=p>)</span> <span class=o>+</span> <span class=n>j</span> <span class=p>)</span> <span class=o>=</span> <span class=p>(</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>)</span> <span class=o>*</span> <span class=p>(</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>);</span>
<span class=ln>14</span>        <span class=p>}</span>
<span class=ln>15</span>    <span class=p>}</span>
<span class=ln>16</span>    <span class=k>for</span><span class=p>(</span> <span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size_row</span> <span class=p>;</span> <span class=n>i</span><span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
<span class=ln>17</span>        <span class=k>for</span><span class=p>(</span> <span class=n>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>size_column</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span> <span class=p>)</span> <span class=p>{</span>
<span class=ln>18</span>            <span class=n>printf</span><span class=p>(</span> <span class=s>&#34;%4d &#34;</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span> <span class=o>*</span><span class=p>(</span> <span class=n>ptr</span> <span class=o>+</span> <span class=n>i</span> <span class=p>)</span> <span class=o>+</span> <span class=n>j</span> <span class=p>)</span> <span class=p>);</span>
<span class=ln>19</span>        <span class=p>}</span>
<span class=ln>20</span>        <span class=n>printf</span><span class=p>(</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span> <span class=p>);</span>
<span class=ln>21</span>    <span class=p>}</span>
<span class=ln>22</span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=ln>23</span><span class=p>}</span>
</code></pre></div></li></ul><hr><h3 id=小工具>小工具</h3><h4 id=cdecl>cdecl</h4><ul><li>安裝：<code>sudo apt install cdecl</code></li><li>使用：<code>cdecl</code> -> <code>explain int ***a;</code></li></ul><h4 id=資源查看>資源查看</h4><ul><li>top / htop</li><li>vmstat ( 較輕量化 )<ul><li><code>vmstat -n 1</code> ( <code>-n 1</code> 為一秒輸出一次 )</li></ul></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/c/>C</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=StackLaTeX()></script><script>function StackLaTeX(){renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:true},{left:"$",right:"$",display:false},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true}]});}</script></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/computer_programming_1-07/><div class=article-details><h2 class=article-title>程式設計(一)-07：Array</h2></div></a></article><article><a href=/p/computer_programming_1-05/><div class=article-details><h2 class=article-title>程式設計(一)-05：Function</h2></div></a></article><article><a href=/p/computer_programming_1-04/><div class=article-details><h2 class=article-title>程式設計(一)-04：Loop</h2></div></a></article><article><a href=/p/computer_programming_1-03/><div class=article-details><h2 class=article-title>程式設計(一)-03：Condition Control</h2></div></a></article><article><a href=/p/computer_programming_1-02/><div class=article-details><h2 class=article-title>程式設計(一)-02：Arithmetic</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2021 小十的部落格</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.0.1>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><script src=/js/copy-to-clipboard.js></script></body></html>