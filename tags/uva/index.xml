<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>UVA on 小十的部落格</title><link>https://blog.smallten.tk/tags/uva/</link><description>Recent content in UVA on 小十的部落格</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 18 Aug 2021 16:02:47 +0800</lastBuildDate><atom:link href="https://blog.smallten.tk/tags/uva/index.xml" rel="self" type="application/rss+xml"/><item><title>StarCoder2021暑訓：Week06</title><link>https://blog.smallten.tk/p/star_coder-07/</link><pubDate>Wed, 18 Aug 2021 16:02:47 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-07/</guid><description>主題 最短路徑 最短路徑模板 Dijkstra’s 不能有負邊 int vn; // vertex num struct Edge { int w, idx; bool operator &amp;lt; (const Edge &amp;amp;r) const { return w &amp;gt; r.w; } }; vector&amp;lt;Edge&amp;gt; adj[maxv]; void dijkstra(int s) { vector&amp;lt;bool&amp;gt; vis(vn, false); vector&amp;lt;int&amp;gt; dist(vn, INF); dist[s] = 0; priority_queue&amp;lt;Edge&amp;gt; pq; pq.emplace(0, s); while(!pq.empty()) { int u = pq.top().idx; pq.pop(); if(vis[u]) continue; vis[u] = true; for(auto v : adj[u]) { if(dist[v.</description></item><item><title>StarCoder2021暑訓：Week05</title><link>https://blog.smallten.tk/p/star_coder-06/</link><pubDate>Tue, 10 Aug 2021 23:50:17 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-06/</guid><description>主題 最小生成樹 MST 模板 Kruskal&amp;rsquo;s Algorithm 時間複雜度 O(ElogE) struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;r) const { return w &amp;lt; r.w; } }; int vn, en; // vertex num, edge num vector&amp;lt;edge&amp;gt; ve; vector&amp;lt;int&amp;gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = x; } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a !</description></item><item><title>StarCoder2021暑訓：Week04</title><link>https://blog.smallten.tk/p/star_coder-05/</link><pubDate>Fri, 06 Aug 2021 10:42:11 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-05/</guid><description>主題 動態規劃 經典背包模板 0/1 背包 &amp;amp; 無限背包 const int N = 100, W = 100000; int cost[N], weight[N], c[W + 1]; void knapsack(int n, int w) { memset(c, 0, sizeof(c)); for (int i = 0; i &amp;lt; n; ++i) for (int j = w; j - weight[i] &amp;gt;= 0; --j) // 0/1 背包 // for (int j = weight[i]; j &amp;lt;= w; ++j) 無限背包 c[j] = max(c[j], c[j - weight[i]] + cost[i]); cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; } 有限背包 const int N = 100, W = 100000; int cost[N], weight[N], number[N], c[W + 1]; void knapsack(int n, int w) { for (int i = 0; i &amp;lt; n; ++i) { int num = min(number[i], w / weight[i]); for (int k = 1; num &amp;gt; 0; k *= 2) { if (k &amp;gt; num) k = num; num -= k; for (int j = w; j &amp;gt;= weight[i] * k; --j) c[j] = max(c[j], c[j - weight[i] * k] + cost[i] * k); } } cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; } 經典零錢問題模板 int price[5] = {5, 2, 6, 11, 17}; bool c[1000+1]; //int c[1000+1]; void change(int m) { memset(c, false, sizeof(c)); c[0] = true; for (int i = 0; i &amp;lt; 5; ++i) for (int j = price[i]; j &amp;lt;= m; ++j) c[j] ||= c[j-price[i]]; // c[j] += c[j-price[i]]; if (c[m]) cout &amp;lt;&amp;lt; &amp;#34;湊得到&amp;#34;; else cout &amp;lt;&amp;lt; &amp;#34;湊不到&amp;#34;; // cout &amp;lt;&amp;lt; &amp;#34;湊得價位&amp;#34; &amp;lt;&amp;lt; m; // cout &amp;lt;&amp;lt; &amp;#34;湊法總共&amp;#34; &amp;lt;&amp;lt; c[m] &amp;lt;&amp;lt; &amp;#34;種&amp;#34;; } LIS 模板 DP const int N = 100; int s[N], length[N]; int LIS() { for (int i=0; i&amp;lt;N; i++) length[i] = 1; for (int i=0; i&amp;lt;N; i++) for (int j=0; j&amp;lt;i; j++) if (s[j] &amp;lt; s[i]) length[i] = max(length[i], length[j] + 1); int l = 0; for (int i=0; i&amp;lt;N; i++) l = max(l, length[i]); return l; } Robinson-Schensted-Knuth Algorithm 時間複雜度 O(NlogL) ， N 是序列長度， L 是 LIS 長度。 int LIS(vector&amp;lt;int&amp;gt;&amp;amp; s) { if (s.</description></item><item><title>StarCoder2021暑訓：Week03</title><link>https://blog.smallten.tk/p/star_coder-04/</link><pubDate>Wed, 28 Jul 2021 05:48:25 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-04/</guid><description>主題 圖、狀態搜尋、拓樸排序、尤拉路 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用演算法 基本題 UVa 10004 無向圖的兩色著色問題 DFS/BFS 均可 V UVa 10959 求無向無權圖上每一點和一指定點的最短距離 BFS V UVa 572 求二維地圖上的連通塊數量 DFS/BFS 均可 V UVa 441 給定 k 個數，由小到大列出所有包含其中 6 個數的遞增數列 DFS UVa 567 求無向無權圖上指定兩點間的最短距離 BFS (或用後面會學到的 Floyd-Warshall 演算法) V UVa 10926 給有向無環圖，求最大一棵樹的節點數減1 DFS/BFS 均可 SPOJ PT07Z 求數直徑（經典題） DFS/BFS 均可 UVa 10603 倒水問題（給三個水瓶，倒出指定水量） BFS 變型 (帶權最短路) UVa 10305 給定 n 個工作的兩兩先後關係，輸出任一個合法的工作完成順序。 拓樸排序 V UVa 1423 給定一數列中 Sij = a[i]+…+a[j] 的正負號，輸出一組符合正負號關係的數列。(有趣，值得思考！) 拓樸排序 UVa 302 給定一個無向圖和指定起點，列印尤拉路。 尤拉路 UVa 10441 給定一堆字串，問如何將它們頭尾相連串起來。 尤拉路 參考作法 A - Bicoloring #include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓：Week02</title><link>https://blog.smallten.tk/p/star_coder-03/</link><pubDate>Sat, 24 Jul 2021 08:26:57 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-03/</guid><description>主題 STL、併查集 併查集模板 int dsu[MAX_N]; void init(int num) { for(int i = 0; i &amp;lt;= num; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用結構 優先練習 UVa 673 括號匹配與 LIFO 操作 std::stack v UVa 442 括號匹配與 LIFO 操作 std::stack UVa 12100 遍歷和 FIFO 操作 std::queue (加上 std::priority_queue 效率更高) v UVa 245 取出第 n 個以及插入頭端 std::list / std::deque / std::vector UVa 1203 插入與取出最小值 std::priority_queue v UVa 11995 模擬 stack, queue, priority_queue std::stack, std::queue, std::priority_queue v UVa 10583 標準併查集操作 disjoint set v UVa 11987 併查集的變化題(值得思考) disjoint set UVa 1665 判斷連通塊數 disjoint set UVa 230 字串排序與搜尋 std::map / std::set v UVa 1592 字串比較（將字串轉成數值以加快比較） std::map 參考作法 A - Parentheses Balance #include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓：Week01</title><link>https://blog.smallten.tk/p/star_coder-02/</link><pubDate>Thu, 15 Jul 2021 00:07:54 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-02/</guid><description>主題 搜尋、排序、貪心 題目 Virtual Judge 參考作法 A - Flip Sort 題目說明： 給一堆數字，輸出要交換(只能相鄰交換)多少次，才能由小到大排好。 解題思路： Bubble sort 程式碼： #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int n, a[1005]; while(cin &amp;gt;&amp;gt; n) { int ans = 0; for(int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; a[i]; for(int i = 0; i &amp;lt; n; ++i) { for(int j = n - 1; j &amp;gt; i; --j) { if(a[j] &amp;lt; a[j - 1]) { swap(a[j], a[j - 1]); ++ans; } } } cout &amp;lt;&amp;lt; &amp;#34;Minimum exchange operations : &amp;#34; &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } B - Age Sort 題目說明： 給一堆數字，由小到大排序。 解題思路： std::sort() 小心 Presentation error 程式碼： #include &amp;lt;bits/stdc++.</description></item></channel></rss>