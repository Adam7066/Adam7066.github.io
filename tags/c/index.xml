<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on 小十的部落格</title><link>https://blog.smallten.tk/tags/c/</link><description>Recent content in C on 小十的部落格</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 02 Apr 2021 17:58:22 +0800</lastBuildDate><atom:link href="https://blog.smallten.tk/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>程式設計(二)-03：File Processing</title><link>https://blog.smallten.tk/p/computer_programming_2-03/</link><pubDate>Fri, 02 Apr 2021 17:58:22 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-03/</guid><description>File C 將每個檔案視為一個連續的 bytes stream 每個檔案以 end-of-file 為結尾，這是由系統提供而不是文件。 It looks like there is an additional byte appended to the file. However, that additional byte does not exist. Instead, it is a signal raised by your system. int feof(FILE *stream); File Stream Streams 提供了更高級別的介面(interface)讓你存取資料。 fprintf fscanf 事實上，你已經使用過 file stream ! 三種標準流 標準輸入 0 (standard input.) 標準輸出 1 (standard output.) 標準錯誤 2 (standard error.</description></item><item><title>程式設計(二)-02：Structure</title><link>https://blog.smallten.tk/p/computer_programming_2-02/</link><pubDate>Fri, 02 Apr 2021 16:24:46 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-02/</guid><description>Structure Structures 就是將一堆相關的變數整合在一個名字下。 關鍵字：struct 資料型別：struct _name_ 成員：在 struct 的大括號內宣告的變數。 同一個結構體下的成員名稱是唯一的。 1struct _sCard{ 2 uint8_t suit, face; 3}; 初始化 1struct _sCard a_card = {.suit = 1, .face = 2}; 2struct _sCard a_card = {1, 2}; structure member operator -&amp;gt; . structure pointer operator -&amp;gt; -&amp;gt; 1a_card_ptr = &amp;amp;a_card; 2a_card_ptr-&amp;gt;face = 5; 3// Equivalent to 4(*a_card_ptr).face = 5; CPU Alignment CPU 有時候會為了減少從記憶體呼叫變數的次數，而主動將變數的記憶體放在連續的地方。 為了避免 alignment，你可以使用以下兩種方法： __attribute__((packed)) pragma 1#pragma pack(push) 2#pragma pack(1) 3#pragma pack(pop) 1// 法一 2struct st{ 3 .</description></item><item><title>程式設計(二)-01：String</title><link>https://blog.smallten.tk/p/computer_programming_2-01/</link><pubDate>Fri, 02 Apr 2021 14:40:30 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-01/</guid><description>字元 在講字串之前我們先來看什麼是字元。 ASCII American Standard Code for Information Interchange. 電子通訊的字元編碼標準 基於英文字母，ASCII 將 128 個字元編碼成 7 個位元長。 95 個可印字元：A-Z, a-z, 0-9, 標點符號 不可印字元：換行符號 在電腦中我們使用 8-bit 的記憶體儲存字元。 在 C 語言中，使用 char 這個型別。 %c -&amp;gt; 輸出字元 %x or %X -&amp;gt; 印出 hex or HEX 的值。 在以前，許多情況下，有些人使用 unsigned char 作為 one byte 的資料型別，但現今你應該使用的是 uint8_t。 請把 char 留給字串，盡管事實上對電腦來說都是一樣的。 其他編碼：Big5、UTF-8 字串 事實上，字串就是一連串的可印字元。 這樣看起來很像陣列對吧?</description></item><item><title>程式設計(一)-08：Pointer</title><link>https://blog.smallten.tk/p/computer_programming_1-08/</link><pubDate>Wed, 23 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-08/</guid><description>Pointer 許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分 指標是一個變數，其值為記憶體位置 宣告：int32_t *p p 是一個指標 指向的記憶體區塊被視為整數 初始化：int32_t *p = NULL address operator &amp;amp;：返回其變數的記憶體位置 如果想要印出記憶體位置，你可以使用%p indirection operator *：也被稱為dereferencing operator，返回指向對象的值 void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別 傳參數至函式 在C語言中，argument passing 稱為 call-by-value 電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行 這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。 陣列與指標 在大部分的情況下，我們可以把array視為第一個元素的指標 現在你應該明白為什麼陣列的值會在函式中被修改 為了避免模棱兩可(搞混)，我較喜歡&amp;amp;(array[0])而不是array、&amp;amp;array 然而你不能寫出 array = &amp;amp;a int32_t int16_t int8_t ptr++ 移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用 事實上，array[n] = *(ptr + n) Endian Issue</description></item><item><title>程式設計(一)-07：Array</title><link>https://blog.smallten.tk/p/computer_programming_1-07/</link><pubDate>Mon, 07 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-07/</guid><description>Array 陣列是一種可以儲存大量相同型別資料的方法。 連續的記憶體位置。 永遠從0開始 int32_t a[10] -&amp;gt; a[0] ~ a[9] 計數變數 i 的型別可以宣告為 size_t，它是一個無號的整數型別。 初始化 int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0}; 存取陣列元素使用 variable[index] 專業說明：電腦將找到第一個元素的地址，然後根據索引移動記憶體位置以訪問數據。 事實上一維陣列可以處理所有情況，至於多維陣列只是給人類方便閱讀的。 define 是遇處理指令，不是C的詞(statement) 我們可以使用 #define 去做巨集(MACRO) 當開發時MACRO有些像function，然而對電腦而言他們是不同的。 當遇到MACRO，編譯器將簡單的依定義替換掉程式碼。 函式擁有自己的標記。 基本排序 氣泡排序法 1for(int i = 0; i &amp;lt; n; ++i) { 2 for(int j = i; j &amp;lt; n; ++j) { 3 if(a[j] &amp;lt; a[i]) { 4 a[i] = a[i] ^ a[j]; 5 a[j] = a[i] ^ a[j]; 6 a[i] = a[i] ^ a[j]; 7 } 8 } 9} qsort 1#include &amp;lt;stdlib.</description></item><item><title>程式設計(一)-05：Function</title><link>https://blog.smallten.tk/p/computer_programming_1-05/</link><pubDate>Sat, 21 Nov 2020 21:48:47 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-05/</guid><description>Function 函式 double double 是一種浮點數型別，就像是 float 就如同它的名字，它使用的記憶體大小為 float 的兩倍 建議: 當你需要浮點數的話，一律使用 double 到目前為止我們最常使用到的函式為 printf 我們稱這些函式為 C standard functions (C標準函式) 所有的函式都被儲存在libraries中 如果你想要讀書，你需要知道書在哪，然後去圖書館借書 如果你想要使用函式，你需要知道函式在哪，然後include library去使用函式 例如: stdio.h &amp;lt;-&amp;gt; printf 使用 math.h 時，需下編譯參數 -lm 永不重新發明輪子 在開發前請先搜尋 1//原型宣告 2Return-Value-Type Function-Name (parameter-Type-list); 3 4Return-Value-Type Function-Name (parameter-list){ 5 Statements 6} 使用原型宣告並將自訂函式置於main function之後的好處? 不用管function之間的先後順序。 void 沒有型別 在這裡，代表不需要回傳值 標頭檔 (Header Files) 甚麼是header file?</description></item><item><title>程式設計(一)-04：Loop</title><link>https://blog.smallten.tk/p/computer_programming_1-04/</link><pubDate>Sun, 18 Oct 2020 20:33:18 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-04/</guid><description>Loop - `while` - `for` - `do while` While Loop 1while(條件){ 2 執行區塊 3} %.200f 會發生什麼事? -&amp;gt; 精度不夠沒有意義 while(1) -&amp;gt; 無窮迴圈 For Loop 1for(初始化; 條件; 執行後操作){ 2 執行區塊 3} i++ -&amp;gt; Use the current value of i. -&amp;gt; i = i + 1 ++i -&amp;gt; i = i + 1 -&amp;gt; Use the new value of i. {} -&amp;gt; 變數生命週期範圍 %4d ( %# ) -&amp;gt; 給最小的位數去顯示 在 ANSI C, 變數只能被宣告在函式的開頭，而 Modern C 沒有任何限制 Do While Loop 1do{ 2 執行區塊 3}while(條件) 三種不同類型的迴圈毫無疑問的都可以互相轉換 除了 do while 至少會執行一次 大多數來說，如果你知道要執行幾次迴圈的話，會使用 for break：離開當前的區段 continue：跳過剩餘的敘述，直接執行下一次迭代 無窮迴圈不是個好東西?</description></item><item><title>程式設計(一)-03：Condition Control</title><link>https://blog.smallten.tk/p/computer_programming_1-03/</link><pubDate>Thu, 15 Oct 2020 20:53:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-03/</guid><description>Condition Control 簡介 我們想要讓電腦去做基礎的判斷 if switch If 1if (condition1) { 2 statements; 3} 4else if (condition2){ 5 ... 6} 7else { 8 ... 9} 如果條件不是錯誤，那麼將會執行大括號裡的敘述 簡而言之，false 被定義為 0 &amp;gt; -&amp;gt; 大於 &amp;lt; -&amp;gt; 小於 &amp;gt;= -&amp;gt; 大於等於 &amp;lt;= -&amp;gt; 小於等於 == -&amp;gt; 等於 != -&amp;gt; 不等於 &amp;amp;&amp;amp; -&amp;gt; and || -&amp;gt; or Boolean 在 Cpp 裡，有個型別稱為 bool 它只有兩個值：true, false 那麼 bool 使用的記憶體大小為何能?</description></item><item><title>程式設計(一)-02：Arithmetic</title><link>https://blog.smallten.tk/p/computer_programming_1-02/</link><pubDate>Thu, 15 Oct 2020 11:19:09 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-02/</guid><description>Arithmetic 1#include &amp;lt;stdio.h&amp;gt;2int main(){ 3 int a = 1, b = 2, sum = 0; 4 sum = a + b; 5 printf(&amp;#34;%d&amp;#34;, sum); 6 return 0; 7} 變數 每個變數都必須有它的型別 在使用變數前必須先宣告它 在C裡面， = 意思為”指定”，而不是”相等”，指派右邊的數值給左邊的變數 一個好習慣，總是初始化變數 C Spec: C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero.</description></item><item><title>程式設計(一)-01：Your first program</title><link>https://blog.smallten.tk/p/computer_programming_1-01/</link><pubDate>Sun, 04 Oct 2020 11:00:48 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-01/</guid><description>Hello World 1#include &amp;lt;stdio.h&amp;gt;2//Your first code. 3int main(){ 4 printf(&amp;#34;Hello World\n&amp;#34;); 5 return 0; 6} main是每個C程式的進入點，我們稱它為main function(主函式) int 及 return 是C裡面的Keywords int代表這個函式將會回傳一個整數 每個函式都應該有一個回傳值 每個敘述的結尾都應該要有 ; printf 是一個會顯示格式化字串的函式 \n -&amp;gt; 換行 \t -&amp;gt; tab \\ -&amp;gt; \ \&amp;quot; -&amp;gt; “ # 的那一行是C的預處理器並且不需要;結尾 stdio.h -&amp;gt; standard input / output header(標準輸出/輸入標頭檔) 註解 -&amp;gt; 是給開發者看的 //Your code -&amp;gt; 單行 /*Your code*/ -&amp;gt; 多行 使用編譯器將程式碼編譯成組合語言，再由組譯器組議成機械碼或可執行的二進制檔 IDE -&amp;gt; Integrated Development Environment，不是編譯器 gcc是最受歡迎的C編譯器之一(不完全對!</description></item></channel></rss>