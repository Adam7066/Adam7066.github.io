<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 小十的部落格</title><link>https://blog.smallten.tk/post/</link><description>Recent content in Posts on 小十的部落格</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 18 Dec 2020 01:16:06 +0800</lastBuildDate><atom:link href="https://blog.smallten.tk/post/index.xml" rel="self" type="application/rss+xml"/><item><title>First Hugo Blog</title><link>https://blog.smallten.tk/p/first-hugo-blog/</link><pubDate>Fri, 18 Dec 2020 01:16:06 +0800</pubDate><guid>https://blog.smallten.tk/p/first-hugo-blog/</guid><description>第一個 Hugo Blog  由於秉持著「人生總折騰」的道理，我來轉移 Blog 了(誤///)，好啦，其實是單純希望有個穩定且又能全天候供應的 Blog 而已，由於我的隊友兩人分別使用了 Hexo 及 Hugo ，因此一開始讓我有點難抉擇，但最終我還是選擇了 Hugo 。
 至於第二個選擇的難關就是主題了，挑了好久都沒看到順眼的，差點就要聽吳文元說的沒有喜歡的就自己寫呀(怕///)，最終還是挑到了一個稍微滿意的主題 Stack。
 至於架設的過程到目前為止還算是蠻順利的，希望之後也不會遇到什麼大坑。</description></item><item><title>演算法-01：蓄水池抽樣法</title><link>https://blog.smallten.tk/p/algorithm-01/</link><pubDate>Tue, 08 Dec 2020 16:02:25 +0800</pubDate><guid>https://blog.smallten.tk/p/algorithm-01/</guid><description>蓄水池抽樣法 (Reservoir Sampling) 從 N 個樣本中，隨機抽取 K 個樣本，其中 N 非常大(不能將所有數據都放進記憶體或是一個未知數)，而每個被抽出來的機率要相等。 定理 該算法保證每個元素以 \( k \over n \) 的機率被選入蓄水池中。
證明 第 i 個元素進入蓄水池的機率為 \( k \over i \)，蓄水池內每個元素被替換的機率為\( 1 \over k \) 因此在第 i 輪第 j 個元素被替換的機率為 \( {k \over i}\times{1 \over k} = {1 \over i} \)，接下來用 M.I. (數學歸納法)來證明，當 n 次循環結束時每個元素進入蓄水池的機率為 \( k \over n \) 假設在 (i-1) 次迭代後，任意一個元素進入 蓄水池的概率為 \( k \over i-1 \)。由上面的結論，在第 i 次迭代時，該元素被替換的概率為 \( 1 \over i \)， 那麼其不被替換的概率則為 \( 1 - {1 \over i} = {i - 1 \over i} \) 故在第 i 次迭代後，該元素在蓄水池內的概率為 \( {k \over i-1} \times {i-1 \over i} = {k \over i} \)，歸納結束。 因此當循環結束時，每個元素進入蓄水池的概率為 \( k \over n \)，命題得證。 例題 Leetcode 382.</description></item><item><title>程式設計(一)-07：Array</title><link>https://blog.smallten.tk/p/computer_programming_1-07/</link><pubDate>Mon, 07 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-07/</guid><description>Array 陣列是一種可以儲存大量相同型別資料的方法。 連續的記憶體位置。 永遠從0開始 int32_t a[10] -&amp;gt; a[0] ~ a[9] 計數變數 i 的型別可以宣告為 size_t，它是一個無號的整數型別。 初始化 int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0}; 存取陣列元素使用 variable[index] 專業說明：電腦將找到第一個元素的地址，然後根據索引移動記憶體位置以訪問數據。 事實上一維陣列可以處理所有情況，至於多維陣列只是給人類方便閱讀的。 define 是遇處理指令，不是C的詞(statement) 我們可以使用 #define 去做巨集(MACRO) 當開發時NACRO有些像function，然而對電腦而言他們是不同的。 當遇到MACRO，編譯器將簡單的依定義替換掉程式碼。 函式擁有自己的標記。 基本排序 氣泡排序法 for(int i = 0; i &amp;lt; n; ++i) { for(int j = i; j &amp;lt; n; ++i) { if(a[j] &amp;lt; a[i]) { a[i] = a[i] ^ a[j]; a[j] = a[i] ^ a[j]; a[i] = a[i] ^ a[j]; } } } qsort #include &amp;lt;stdlib.</description></item><item><title>程式設計(一)-06：Makefile</title><link>https://blog.smallten.tk/p/computer_programming_1-06/</link><pubDate>Wed, 02 Dec 2020 21:45:51 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-06/</guid><description>Makefile for 程設一 CC = gcc CFLAGS = -Wall -Wextra -O2 -std=c11 LDFLAGS = -lm TARGETS = main01 main02 main01_OBJ = main01.o func01.o main02_OBJ = main02.o func02.o .PHONY = all clean all: $(TARGETS) .SECONDEXPANSION: $(TARGETS): $$($$@_OBJ) $(CC) $^ -o $@ $(LDFLAGS) %.o: $@.c clean: -$(RM) $(TARGETS) $(foreach targ,$(TARGETS),$(foreach obj, $($(targ)_OBJ), $(obj)))</description></item><item><title>程式設計(一)-05：Function</title><link>https://blog.smallten.tk/p/computer_programming_1-05/</link><pubDate>Sat, 21 Nov 2020 21:48:47 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-05/</guid><description>Function 函式 double double 是一種浮點數型別，就像是 float 就如同它的名字，它使用的記憶體大小為 float 的兩倍 建議: 當你需要浮點數的話，一律使用 double 到目前為止我們最常使用到的函式為 printf 我們稱這些函式為 C standard functions (C標準函式) 所有的函式都被儲存在libraries中 如果你想要讀書，你需要知道書在哪，然後去圖書館借書 如果你想要使用函式，你需要知道函式在哪，然後include library去使用函式 例如: stdio.h &amp;lt;-&amp;gt; printf 使用 math.h 時，需下編譯參數 -lm 永不重新發明輪子 在開發前請先搜尋 //原型宣告 Return-Value-Type Function-Name (parameter-Type-list); Return-Value-Type Function-Name (parameter-list){ Statements } 使用原型宣告並將自訂函式置於main function之後的好處? 不用管function之間的先後順序。 void 沒有型別 在這裡，代表不需要回傳值 標頭檔 (Header Files) 甚麼是header file?</description></item><item><title>程式設計(一)-04：Loop</title><link>https://blog.smallten.tk/p/computer_programming_1-04/</link><pubDate>Sun, 18 Oct 2020 20:33:18 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-04/</guid><description>Loop - `while` - `for` - `do while` While Loop while(條件){ 執行區塊 } %.200f 會發生什麼事? -&amp;gt; 精度不夠沒有意義 while(1) -&amp;gt; 無窮迴圈 For Loop for(初始化; 條件; 執行後操作){ 執行區塊 } i++ -&amp;gt; Use the current value of i. -&amp;gt; i = i + 1 ++i -&amp;gt; i = i + 1 -&amp;gt; Use the new value of i. {} -&amp;gt; 變數生命週期範圍 %4d ( %# ) -&amp;gt; 給最小的位數去顯示 在 ANSI C, 變數只能被宣告在函式的開頭，而 Modern C 沒有任何限制 Do While Loop do{ 執行區塊 }while(條件) 三種不同類型的迴圈毫無疑問的都可以互相轉換 除了 do while 至少會執行一次 大多數來說，如果你知道要執行幾次迴圈的話，會使用 for break：離開當前的區段 continue：跳過剩餘的敘述，直接執行下一次迭代 無窮迴圈不是個好東西?</description></item><item><title>程式設計(一)-03：Condition Control</title><link>https://blog.smallten.tk/p/computer_programming_1-03/</link><pubDate>Thu, 15 Oct 2020 20:53:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-03/</guid><description>Condition Control 簡介 我們想要讓電腦去做基礎的判斷 if switch If if (condition1) { statements; } else if (condition2){ ... } else { ... } 如果條件不是錯誤，那麼將會執行大括號裡的敘述 簡而言之，false 被定義為 0 &amp;gt; -&amp;gt; 大於 &amp;lt; -&amp;gt; 小於 &amp;gt;= -&amp;gt; 大於等於 &amp;lt;= -&amp;gt; 小於等於 == -&amp;gt; 等於 != -&amp;gt; 不等於 &amp;amp;&amp;amp; -&amp;gt; and || -&amp;gt; or Boolean 在 Cpp 裡，有個型別稱為 bool 它只有兩個值：true, false 那麼 bool 使用的記憶體大小為何能?</description></item><item><title>程式設計(一)-02：Arithmetic</title><link>https://blog.smallten.tk/p/computer_programming_1-02/</link><pubDate>Thu, 15 Oct 2020 11:19:09 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-02/</guid><description>Arithmetic #include &amp;lt;stdio.h&amp;gt;int main(){ int a = 1, b = 2, sum = 0; sum = a + b; printf(&amp;#34;%d&amp;#34;, sum); return 0; } 變數 每個變數都必須有它的型別 在使用變數前必須先宣告它 在C裡面， = 意思為”指定”，而不是”相等”，指派右邊的數值給左邊的變數 一個好習慣，總是初始化變數 C Spec: C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero. In C99: a == (a / b) * b + a % b printf 是一個函式去印出格式化字串 %d -&amp;gt; 有號十進位整數 %f -&amp;gt; 十進位浮點數 %u -&amp;gt; 無號十進位整數 當然不只這些 小技巧 a += b -&amp;gt; a = a + b a -= b -&amp;gt; a = a - b a *= b -&amp;gt; a = a * b a /= b -&amp;gt; a = a / b a %= b -&amp;gt; a = a % b 查看記憶體使用大小： sizeof()，回傳單位為 byte ( printf(&amp;quot;%lu&amp;quot;, sizeof()); ) #include &amp;lt;stdint.</description></item><item><title>Python-04：多線程-ts下載並合併成mp4</title><link>https://blog.smallten.tk/p/python-04/</link><pubDate>Sun, 04 Oct 2020 16:36:35 +0800</pubDate><guid>https://blog.smallten.tk/p/python-04/</guid><description>簡介  這篇將帶你下載m3u8檔並分析出ts的檔案，再透過多線程來加速下載，之後再由FFmpeg合併成mp4。
Python 下載m3u8 m3u8Url = &amp;#39;https://.../index.m3u8&amp;#39; def downloadM3u8(url): r = requests.get(url) with open(&amp;#39;./index.m3u8&amp;#39;, &amp;#39;wb&amp;#39;) as f: f.write(r.content) 分析m3u8 這部份請依照你所取得的m3u8檔進行分析，並將完整的ts檔的url放進tsList即可。 tsList = [] tsCnt = 0 def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(&amp;#39;/&amp;#39;, 1)[0] + &amp;#39;/&amp;#39; with open(&amp;#39;./index.m3u8&amp;#39;, &amp;#39;r&amp;#39;) as f: text = f.read() textList = text.split(&amp;#39;\n&amp;#39;) while textList[-1] != &amp;#39;#EXT-X-ENDLIST&amp;#39;: textList.pop(-1) for i in textList: if i[0] != &amp;#39;#&amp;#39;: tsList.append(tempUrl + i) global tsCnt tsCnt = len(tsList) 下載ts檔 q = queue.</description></item><item><title>Python-03：m3u8影片下載</title><link>https://blog.smallten.tk/p/python-03/</link><pubDate>Sun, 04 Oct 2020 11:07:24 +0800</pubDate><guid>https://blog.smallten.tk/p/python-03/</guid><description>簡介 現今你時常能在影音媒體網站看到 .m3u8 的檔案，以及許多 .ts 的分段媒體，本篇將教你如何簡單的下載成 .mp4 檔。 這篇並不詳加敘述 HLS 之類的觀念，若有興趣深入了解請自行查找資料。 FFmpeg FFmpeg官網 下載安裝完後，若為 windows 用戶請將 %ffmpeg%\bin 的路徑加入環境變數中，並於terminal中執行 ffmpeg -version 來查看是否成功加入。 下載檔案，直接在 terminal 輸入 ffmpeg -i m3u8URL -c copy filname.mp4，即可完成下載。(下面將提供Python的寫法) Python # -*- coding: UTF-8 -*- import ffmpeg_streaming from ffmpeg_streaming import Formats url = &amp;#39;https://.../index.m3u8&amp;#39; filename = &amp;#39;test.mp4&amp;#39; def ffmpeg_download(input_path, output_path): video = ffmpeg_streaming.input(input_path) stream = video.stream2file(Formats.h264()) stream.output(output_path) if __name__ == &amp;#34;__main__&amp;#34;: ffmpeg_download(url, &amp;#39;./&amp;#39; + filename) 下一篇將教你如何直接從 m3u8 裡讀取目錄，並使用多線程下載 ts 並合併成 mp4</description></item><item><title>程式設計(一)-01：Your first program</title><link>https://blog.smallten.tk/p/computer_programming_1-01/</link><pubDate>Sun, 04 Oct 2020 11:00:48 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-01/</guid><description>Hello World #include &amp;lt;stdio.h&amp;gt;//Your first code. int main(){ printf(&amp;#34;Hello World\n&amp;#34;); return 0; } main是每個C程式的進入點，我們稱它為main function(主函式) int 及 return 是C裡面的Keywords int代表這個函式將會回傳一個整數 每個函式都應該有一個回傳值 每個敘述的結尾都應該要有 ; printf 是一個會顯示格式化字串的函式 \n -&amp;gt; 換行 \t -&amp;gt; tab \\ -&amp;gt; \ \&amp;quot; -&amp;gt; “ # 的那一行是C的預處理器並且不需要;結尾 stdio.h -&amp;gt; standard input / output header(標準輸出/輸入標頭檔) 註解 -&amp;gt; 是給開發者看的 //Your code -&amp;gt; 單行 /*Your code*/ -&amp;gt; 多行 使用編譯器將程式碼編譯成組合語言，再由組譯器組議成機械碼或可執行的二進制檔 IDE -&amp;gt; Integrated Development Environment，不是編譯器 gcc是最受歡迎的C編譯器之一(不完全對!</description></item><item><title>Python-02：多線程-加速圖片下載</title><link>https://blog.smallten.tk/p/python-02/</link><pubDate>Mon, 03 Aug 2020 00:56:43 +0800</pubDate><guid>https://blog.smallten.tk/p/python-02/</guid><description>簡介 接續上一篇Python-01：爬蟲-圖片下載的內容，這篇文章將帶領大家使用多線程來加速圖片的下載 教學開始 首先我們先看個簡單的多線程範例 import time, threading # 子執行緒的工作函數 def job(): for i in range(5): print(&amp;#34;Child thread:&amp;#34;, i) time.sleep(1) # 建立一個子執行緒 t = threading.Thread(target = job) # 執行該子執行緒 t.start() # 主執行緒繼續執行自己的工作 for i in range(3): print(&amp;#34;Main thread:&amp;#34;, i) time.sleep(1) # 等待 t 這個子執行緒結束 t.join() print(&amp;#34;Done.&amp;#34;) import time, threading # 子執行緒的工作函數 def job(num): print(&amp;#34;Thread&amp;#34;, num) time.sleep(1) # 建立 5 個子執行緒 threads = [] for i in range(5): threads.</description></item><item><title>Python-01：爬蟲-圖片下載</title><link>https://blog.smallten.tk/p/python-01/</link><pubDate>Mon, 03 Aug 2020 00:39:24 +0800</pubDate><guid>https://blog.smallten.tk/p/python-01/</guid><description>簡介 這一篇將帶領大家透過Python的爬蟲自動化的下載圖片 安裝 打開終端機，安裝下列套件 pip install requests pip install BeautifulSoup4 pip install lxml pip install selenium 至 Chrome Driver 下載當前電腦中Chrome所對應版本的Driver 教學開始 首先因為這次的主題為圖片下載，因此我們找了一個擁有大量圖片的漫畫網頁來進行教學。 由於這個網頁的圖片是由JavaScript加載的，因此一開始我們使用Selenium來開啟網頁 from selenium import webdriver url = &amp;#39;https://www.ohmanhua.com/13621/1/1.html&amp;#39; #使用crx插件 chop = webdriver.ChromeOptions() chop.add_extension(&amp;#39;Adblock-Plus_v3.8.4.crx&amp;#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) 當然若不想顯示瀏覽器的視窗可以使用headless模式 chop.add_argument(&amp;#39;--headless&amp;#39;) #規避google bug chop.add_argument(&amp;#39;--disable-gpu&amp;#39;) 接下來使用BeautifulSoup4來分析頁面，並取得圖片網址，和共幾張圖片 img_count = int(soup.find(&amp;#39;select&amp;#39;, {&amp;#39;class&amp;#39;: &amp;#39;mh_select&amp;#39;}).find_all(&amp;#39;option&amp;#39;)[-1].get(&amp;#39;value&amp;#39;)) img_url = soup.find_all(&amp;#39;div&amp;#39;, {&amp;#39;class&amp;#39;: &amp;#39;mh_comicpic&amp;#39;})[0].find(&amp;#39;img&amp;#39;).get(&amp;#39;src&amp;#39;) if img_url[0] == &amp;#39;/&amp;#39;: img_url = &amp;#39;https:&amp;#39; + img_url m = len(img_url.</description></item><item><title>簡易氣象站-02</title><link>https://blog.smallten.tk/p/weather-02/</link><pubDate>Sun, 12 Jul 2020 09:31:38 +0800</pubDate><guid>https://blog.smallten.tk/p/weather-02/</guid><description>簡介 這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作在Raspberry pi用Python讀取Arduino Serial的數值，並且製作一個簡易的UI實時顯示出數值。 硬體 上一小節的成品 Raspberry pi * 1 教學開始 打開Raspberry pi的Terminal，並輸入 ls /dev/tty* 將Arduino的Usb接上Raspberry pi 再次於Terminal中輸入 ls /dev/tty*，比較兩次的差異，即可知Arduino使用的序列埠為何(例如此時為/ dev/ttyACM0，請依照情況自行修改) 於Terminal中輸入 python3 -m pip install pyserial 將以下程式碼建立成一個python檔，再以python3執行即可 # -*- coding: UTF-8 -*- import serial import tkinter as tk def getData(): ser = serial.Serial(&amp;#39;/dev/ttyACM0&amp;#39;, 9600, timeout=1) ser.flush() while True: flag = False if ser.in_waiting&amp;gt;0: arduinoData = ser.readline().decode(encoding=&amp;#39;utf-8&amp;#39;, errors=&amp;#39;ignore&amp;#39;).rstrip().split(&amp;#39;;&amp;#39;) if len(arduinoData)!=4 or arduinoData==&amp;#39;&amp;#39;: continue for i in range(0,3): if arduinoData[i]==&amp;#39;0&amp;#39;: flag = True break if flag: continue else: temperature_value[&amp;#39;text&amp;#39;] = arduinoData[0] + &amp;#39; 度C&amp;#39; humidity_value[&amp;#39;text&amp;#39;] = arduinoData[1] + &amp;#39; %&amp;#39; pmat25_value[&amp;#39;text&amp;#39;] = arduinoData[2] + &amp;#39; ug/m^3&amp;#39; wind_value[&amp;#39;text&amp;#39;] = arduinoData[3] + &amp;#39; 級&amp;#39; break window.</description></item><item><title>簡易氣象站-01</title><link>https://blog.smallten.tk/p/weather-01/</link><pubDate>Sun, 12 Jul 2020 09:02:34 +0800</pubDate><guid>https://blog.smallten.tk/p/weather-01/</guid><description>簡介 這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作由Arduino抓取感測器數值的部分。 硬體 Arduino Uno R3 * 1 攀藤 G5 PMS5003 * 1 DFrobot 三杯式風速感測器 * 1 教學開始 連結電路
Uno程式碼 #include &amp;lt;SoftwareSerial.h&amp;gt;#define windPin A0 SoftwareSerial pmsSerial(2, 3); long pmValue=0; long pmcf25=0; long pmat25=0; unsigned int temperature = 0; unsigned int humandity = 0; void retrievepm25(){ int count = 0; unsigned char c; unsigned char high; while (pmsSerial.available()) { c = pmsSerial.read(); if((count==0 &amp;amp;&amp;amp; c!</description></item><item><title>Arduino-05：HC-05 AT命令</title><link>https://blog.smallten.tk/p/arduino-05/</link><pubDate>Sun, 10 May 2020 21:56:45 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-05/</guid><description>簡介 這篇內容將教大家透過Arduino的序列埠設定HC-05的AT命令 硬體 Arduino Uno * 1 HC-05藍芽模組 * 1 教學 腳位連接 Arduino HC-05 5V VCC GND GND 8 TX 9 RX 程式碼 #include &amp;lt;SoftwareSerial.h&amp;gt; SoftwareSerial BT(8, 9); char val; void setup() { Serial.begin(9600); BT.begin(38400); } void loop() { if(Serial.available()){ val = Serial.read(); BT.print(val); } if(BT.available()){ val = BT.read(); Serial.print(val); } } 連接腳位，並上傳程式碼，最後給HC-05供電前，先按住上面的按鈕，再提供電源，燈號將變成約兩秒一閃，及表示進入了AT命令模式 接下來打開序列埠監控視窗，將設定調成&amp;quot;9600 baud&amp;quot;和&amp;quot;NL與CR&amp;quot;，最後依需求輸入以下命令即可 AT -&amp;gt; 顯示OK表示連接成功 查看韌體版本 -&amp;gt; AT+VERSION 查看名稱 -&amp;gt; AT+NAME?</description></item><item><title>Arduino-04：藍芽遙控車</title><link>https://blog.smallten.tk/p/arduino-04/</link><pubDate>Sun, 03 May 2020 16:29:01 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-04/</guid><description>簡介 這篇內容將帶領大家製作藍芽的遙控車，並且用Blynk的Joystick操控它 硬體 Arduino nano * 1 L298N 馬達控制板 * 1 HC-05 藍芽模組 * 1 二輪直流馬達遙控車 * 1 下載 至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 教學開始 先上傳程式碼至Nano板中 依照下方圖示連接腳位，並且設定Blynk App內的物件 連接腳位
設定Blynk 創建3個元件，分別為Button、Bluetooth、Joystick，並且依下圖進行設置 nano程式碼 #include &amp;lt;BlynkSimpleSerialBLE.h&amp;gt;#define BLYNK_USE_DIRECT_CONNECT char auth[] = &amp;#34;Blynk Auth&amp;#34;; int d[2] = {0}; int car[2][2] = { {5, 6}, {11, 10} }; //in 1,2,4,3 int en[2] = {3, 9}; void Controller(); void Move(int, int, int, int, int, int); BLYNK_WRITE(V0){ for(int i=0; i&amp;lt;2; ++i){ d[i] = param[i].</description></item><item><title>Arduino-03：跑馬燈</title><link>https://blog.smallten.tk/p/arduino-03/</link><pubDate>Thu, 09 Apr 2020 14:50:56 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-03/</guid><description>簡介 這篇內容將帶領大家製作點陣跑馬燈，並且用Blynk來操控它 硬體 WeMos D1R2 * 1 MAX7219 8*8LED點陣模組 * 2 下載 至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 maxmatrix－下載並加入函式庫 教學開始 連接腳位 MAX7219 D1R2 VCC 5V GND GND DIN MOSI/D7 CS SS/D8 CLK SCK/D5 若要串聯多塊MAX7219的話，請將下一塊的DIN接至上一塊的DOUT連接腳位 設定Blynk 請照下圖拉出三個物件，並設定其相關參數 D1R2程式碼 #include &amp;lt;MaxMatrix.h&amp;gt;#include &amp;lt;avr/pgmspace.</description></item><item><title>Arduino-02：UNOJOY</title><link>https://blog.smallten.tk/p/arduino-02/</link><pubDate>Thu, 09 Apr 2020 08:16:57 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-02/</guid><description>簡介 這篇內容將帶領大家把Arduino手把變成電腦手把 所需硬體 Arduino Uno R3 * 1 JoyStick 雙軸按鍵搖桿模組 * 1 下載檔案 FLIP － 請下載包含JRE的檔案(Java Runtime Environment included) UnoJoy － 將Uno變成電腦手把 x360ce － 將手把模擬成xbox 360的手把 教學開始 將下載好的FLIP安裝至電腦 確定電腦已安裝Arduino IDE，並已連接Uno板至電腦，可在裝置管理員查看狀態（如下圖） 打開剛剛下載的UnoJoy資料夾下的檔案，並將它上傳進Uno板中 UnoJoy-master\UnoJoy\UnoJoyArduinoSample\UnoJoyArduinoSample.ino 關閉Arduino IDE，進入DFU Mode，進入方式：用導線同時接觸下圖框起處的兩根針腳 確認已進入 DFU Mode，如下圖 若找不到驅動可手動新增驅動，選擇資料夾為 C:\Program Files (x86)\Atmel\Flip 3.4.7\usb 打開UnoJoy資料夾，啟動TurnIntoAJoystick的批次檔，檔案路徑 UnoJoy-master\UnoJoy\TurnIntoAJoystick.bat，執行成功結果如下圖 至此已完成將Uno變成電腦搖桿，之後插上Uno板皆為UnoJoy Joystick，可在以下路徑查看 控制台\硬體和音效\裝置和印表機 將搖桿的vrx和vry分別連接至Uno板的A0和A1，在 控制台\硬體和音效\裝置和印表機 裡的UnoJoy Joystick圖示上右鍵-&amp;gt;遊戲控制器-&amp;gt;內容，可查看搖桿狀態，如下圖 最後進入起動x360ce，新建立一個搖桿的設定檔，並選取模擬的位置，點選[Record]，依圖示移動搖桿方向即設定完成 補充 如何將UnoJoy Joystick變回一般的Arduino Uno板 連接UnoJoy Joystick，並進入DFU Mode 打開UnoJoy資料夾，啟動TurnIntoAnArduino的批次檔，檔案路徑 UnoJoy-master\UnoJoy\TurnIntoAnArduino.</description></item><item><title>Arduino-01：安裝IDE</title><link>https://blog.smallten.tk/p/arduino-01/</link><pubDate>Thu, 09 Apr 2020 08:08:43 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-01/</guid><description>官方IDE 此IDE由官方提供，可在此查看官網 下載－官方載點 VSCode + PlatformIO 先下載 VSCode 再安裝 PlatformIO 的插件</description></item></channel></rss>