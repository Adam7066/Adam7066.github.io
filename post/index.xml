<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 小十的部落格</title><link>https://blog.smallten.tk/post/</link><description>Recent content in Posts on 小十的部落格</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Oct 2021 09:15:29 +0800</lastBuildDate><atom:link href="https://blog.smallten.tk/post/index.xml" rel="self" type="application/rss+xml"/><item><title>2021 NCPC 初賽</title><link>https://blog.smallten.tk/p/experience-02/</link><pubDate>Mon, 04 Oct 2021 09:15:29 +0800</pubDate><guid>https://blog.smallten.tk/p/experience-02/</guid><description>競賽簡介 NCPC 初賽日期：2021/10/02 成績 校內：7 / 12 全體：26 / 166 心得文
這段時間真的有點忙過頭了
安排 CTF 讀書會的課表（嘿嘿，還去跟 L紀 教授要到了一堂課，希望到時他不會有突發的事情，而是能正常的出席講課），也跟學長一起參加了社團幹部培訓的研習。 協助以前的高中辦理了學科能力競賽的校內初賽，不只從報名簡章到表單，還有競賽的平台以及題目，這裡要特別的感謝一起陪我瘋狂的朋朋 蘇子權，但不得不說，學弟們還得多多加油呀，有機會、時間的話再回去辦研習課程吧！ 我要小小的抱怨一下，學校的選課系統 到底要多久才有機會看到它更新？(有時間去弄那一點都不友善的手機版，不如去重構整個系統。) 不要再人工分流了，很智障。 好好做防 Bot 不行嗎？用那讓人很無言的驗證碼設計，整個傻眼。（打英文還會比打數字的多打幾個字） 系統分發的部份，到底為什麼要那麼久才公佈，又不是用上古年代的電腦，有內幕嗎？（求八卦 二階選課以前是不是直接搶課的呀，教程一階生，最高能選 6 學分，但用志願分發的，但志願只能填到 6 學分，這樣根本分不到呀，傻眼～～ 最重要的是，我第一個選課，比我晚搶課的同學都一一搶到（他們在不同的 server 上，就智障的人工分流問題），我卻只能看你寫登記中，然後慢慢等，直到最後跟我說滿額，是想怎樣啦 😡😡 ，但感謝身旁的朋朋們願意跟我一起去修早八的課程（把大學念到變高中）。 我真的變學分孤兒了😭😭 終於搶到疫苗了，但週日回臺南，禮拜一打疫苗，禮拜三一退燒就又重回北部，週六又打 NCPC 的初賽，整個瘋了～～ 終於要來認真打該有的心得文了，這次的競賽我們隊伍終於好不容易組成了（文元原本因為身心狀態問題沒有要打了），但到比賽的前一天，我們的子權朋朋卻腸胃炎(尷尬)，而文元本來就是被我們抓來一起玩的而已(畢竟他依然得吃葡萄口味的曼陀珠？)，而我前一晚也想到一堆不想去想的東西，也沒睡到特別好&amp;hellip;唉，整個發芬（文元語，咦？
好啦，雖然這次又跟 NCPC 的決賽擦身而過，我是不是真的有萬年老二的命呀？（初賽校內取到第六名），但是這一次的競賽是真的打的非常的開心（賽前測機部份、沒有印表機以及點心除外），水題我依舊是穩穩的 1 try 就解掉費時也不長，其中有一題文元提出模運算，我想到如何搭配前綴和使用，就 AC 了，撒花（但有些隊伍有寫過一樣的題目了，所以非常的早就解出來了 QAQ)，有一題我的想法是對的了，但子權刻後半的部份時一個迴圈寫錯了，最後也有除錯除出來，棒棒的～～（這次有看的所有題目都有好好的解出來呢！）
整體來說，這次競賽讓我享受到了不只有緊張的氣氛，還有團隊解出題時的愉悅，所以雖然沒有進決賽一樣很可惜，但我們志在參與嘛（弱者的發言😭😭），不久後的 TOPC 也得繼續加油呢！</description></item><item><title>StarCoder2021暑訓：Week06</title><link>https://blog.smallten.tk/p/star_coder-07/</link><pubDate>Wed, 18 Aug 2021 16:02:47 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-07/</guid><description>主題 最短路徑 最短路徑模板 Dijkstra’s 不能有負邊 int vn; // vertex num struct Edge { int w, idx; bool operator &amp;lt; (const Edge &amp;amp;r) const { return w &amp;gt; r.w; } }; vector&amp;lt;Edge&amp;gt; adj[maxv]; void dijkstra(int s) { vector&amp;lt;bool&amp;gt; vis(vn, false); vector&amp;lt;int&amp;gt; dist(vn, INF); dist[s] = 0; priority_queue&amp;lt;Edge&amp;gt; pq; pq.emplace(0, s); while(!pq.empty()) { int u = pq.top().idx; pq.pop(); if(vis[u]) continue; vis[u] = true; for(auto v : adj[u]) { if(dist[v.</description></item><item><title>Arch Linux-04：基本軟體安裝</title><link>https://blog.smallten.tk/p/arch_linux-04/</link><pubDate>Wed, 11 Aug 2021 22:18:09 +0800</pubDate><guid>https://blog.smallten.tk/p/arch_linux-04/</guid><description>前言  有了桌面環境，軟體也不可以缺少吧，因此這裡會紀錄一下用到的軟體的安裝方式
教學開始 Yay Yay 的 Github pacman -S --needed base-devel git go git clone https://aur.archlinux.org/yay.git cd yay makepkg -si 中文輸入法 中文輸入法 Wiki 這邊我選擇了之前在 Ubuntu 用習慣的 ibus (IBus (简体中文) Wiki) 安裝注音輸入法：pacman -S ibus ibus-chewing vim /etc/environment GTK_IM_MODULE=ibus QT_IM_MODULE=ibus XMODIFIERS=@im=ibus vim ~/.xprofile export CTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -drxR 重新啟動 Oh My Zsh Oh My Zsh 的 官網、Github 安裝 zsh：pacman -S zsh 看系統是否裝了 zsh：cat /etc/shells 切換 Shell 為 zsh：chsh -s /bin/zsh 安裝 Git 以及 Curl：pacman -S git curl 安裝 oh-my-zsh：sh -c &amp;quot;$(curl -fsSL https://raw.</description></item><item><title>Arch Linux-03：KDE</title><link>https://blog.smallten.tk/p/arch_linux-03/</link><pubDate>Wed, 11 Aug 2021 21:55:25 +0800</pubDate><guid>https://blog.smallten.tk/p/arch_linux-03/</guid><description>前言  在安裝完了系統，也設定了基本配置後，想當然爾，該來安裝一個桌面環境了吧，因此接下來將告訴你怎麼安裝 KDE。
教學開始 基本安裝 安裝 KDE Arch Linux 的 meta package 與 package group 安裝 Plasma：pacman -S plasma-meta 安裝 KDE applications：pacman -S kde-applications 安裝顯示管理器 這邊我們將使用 SDDM：pacman -S sddm 設定自動啟動：systemctl enable sddm.service 安裝終端模擬器 這邊我們使用 konsole：pacman -S konsole 喜歡 kitty 的也可安裝：pacman -S kitty 安裝文件管理器 這邊我們使用 Dolphin：pacman -S dolphin 一些基本軟體 中文字體：pacman -S adobe-source-han-sans-tw-fonts 重新啟動：reboot KDE 美化 切換系統語言 系統設定 -&amp;gt; 區域設定 -&amp;gt; 語言 -&amp;gt; 增加語言&amp;hellip; -&amp;gt; 繁體中文 -&amp;gt; 設為預設 -&amp;gt; 套用 Formats -&amp;gt; 區域 -&amp;gt; 選擇 台灣 - 繁體中文 (zh_TW) 調整顯示設定 系統設定 -&amp;gt; 顯示與螢幕 -&amp;gt; 顯示設定 -&amp;gt; 全域縮放比例 -&amp;gt; 125% 組合器 -&amp;gt; 縮放方式：平滑 成像後端介面：OpenGL 3.</description></item><item><title>Arch Linux-02：基本設置</title><link>https://blog.smallten.tk/p/arch_linux-02/</link><pubDate>Wed, 11 Aug 2021 17:26:15 +0800</pubDate><guid>https://blog.smallten.tk/p/arch_linux-02/</guid><description>前言  在 Arch Linux-01：系統安裝 中，已經介紹了如何完整的安裝一個基礎的 Arch Linux 系統，而這部分將去介紹一些基本的設定或是驅動的安裝。
教學開始 新增使用者 由於不應該一直使用 root 帳號，因此我們來新增一個使用者吧。 新增使用者：useradd -m &amp;lt;user&amp;gt; ( &amp;lt;user&amp;gt; 為你要新增的用戶名稱，請自行更改 ) 設置密碼：passwd &amp;lt;user&amp;gt; Sudo Sudo Wiki 安裝：pacman -S sudo 將使用者加入：usermod -aG wheel &amp;lt;user&amp;gt; 使用 visudo 由於預設使用 vi，但我們之前是用安裝 vim，因此臨時的更改它吧：EDITOR=vim visudo 進去後，找到 %wheel ALL=(ALL) ALL 這行，然後消掉註解並且儲存離開。 Xorg Xorg Wiki 安裝 ：pacman -S xorg-server 驅動安裝 查看顯卡類型：lspci -v | grep -A1 -e VGA -e 3D 安裝對應驅動，請依照情況自行更改 以下為我的筆電的安裝方式 (參考至此文章) 開啟 multilib 倉庫：vim /etc/pacman.</description></item><item><title>Arch Linux-01：系統安裝</title><link>https://blog.smallten.tk/p/arch_linux-01/</link><pubDate>Wed, 11 Aug 2021 13:50:32 +0800</pubDate><guid>https://blog.smallten.tk/p/arch_linux-01/</guid><description>前言  在被吳文元朋朋洗腦、推坑、直銷 Arch Linux 的各種好之後，我終於也入坑了，而這一系列將紀錄整個的安裝過程，避免未來再踩一次坑。
安裝設備 筆電：Zenbook 14 UX433FN 顯卡： GPU0 Intel UHD 620 GPU1 Nvidia MX150 開始安裝 完整官方導覽：Installation guide 前置作業 製作開機碟 到 Arch Linux Download 下載映像檔 (.iso) NCHC、NCTU 使用 Rufus 寫入隨身碟 壓縮磁碟區 由於我要在一塊已有 Windows 10 的硬碟上安裝 Arch linux，因此得來切磁區。
在 Windows 10 中開啟硬碟管理員 以壓縮磁碟區的方式創造出未分配的空間。 安裝系統 插上隨身碟，並以隨身碟開機 檢查硬碟、分配磁區 由於新手上路，這邊我們就分配單一磁區給 / 就好。 至於其他像是 [SWAP] 之類的，有需要就自行處理。</description></item><item><title>StarCoder2021暑訓：Week05</title><link>https://blog.smallten.tk/p/star_coder-06/</link><pubDate>Tue, 10 Aug 2021 23:50:17 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-06/</guid><description>主題 最小生成樹 MST 模板 Kruskal&amp;rsquo;s Algorithm 時間複雜度 O(ElogE) struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;r) const { return w &amp;lt; r.w; } }; int vn, en; // vertex num, edge num vector&amp;lt;edge&amp;gt; ve; vector&amp;lt;int&amp;gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a !</description></item><item><title>StarCoder2021暑訓：Week04</title><link>https://blog.smallten.tk/p/star_coder-05/</link><pubDate>Fri, 06 Aug 2021 10:42:11 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-05/</guid><description>主題 動態規劃 經典背包模板 0/1 背包 &amp;amp; 無限背包 const int N = 100, W = 100000; int cost[N], weight[N], c[W + 1]; void knapsack(int n, int w) { memset(c, 0, sizeof(c)); for (int i = 0; i &amp;lt; n; ++i) for (int j = w; j - weight[i] &amp;gt;= 0; --j) // 0/1 背包 // for (int j = weight[i]; j &amp;lt;= w; ++j) 無限背包 c[j] = max(c[j], c[j - weight[i]] + cost[i]); cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; } 有限背包 const int N = 100, W = 100000; int cost[N], weight[N], number[N], c[W + 1]; void knapsack(int n, int w) { for (int i = 0; i &amp;lt; n; ++i) { int num = min(number[i], w / weight[i]); for (int k = 1; num &amp;gt; 0; k *= 2) { if (k &amp;gt; num) k = num; num -= k; for (int j = w; j &amp;gt;= weight[i] * k; --j) c[j] = max(c[j], c[j - weight[i] * k] + cost[i] * k); } } cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; } 經典零錢問題模板 int price[5] = {5, 2, 6, 11, 17}; bool c[1000+1]; //int c[1000+1]; void change(int m) { memset(c, false, sizeof(c)); c[0] = true; for (int i = 0; i &amp;lt; 5; ++i) for (int j = price[i]; j &amp;lt;= m; ++j) c[j] ||= c[j-price[i]]; // c[j] += c[j-price[i]]; if (c[m]) cout &amp;lt;&amp;lt; &amp;#34;湊得到&amp;#34;; else cout &amp;lt;&amp;lt; &amp;#34;湊不到&amp;#34;; // cout &amp;lt;&amp;lt; &amp;#34;湊得價位&amp;#34; &amp;lt;&amp;lt; m; // cout &amp;lt;&amp;lt; &amp;#34;湊法總共&amp;#34; &amp;lt;&amp;lt; c[m] &amp;lt;&amp;lt; &amp;#34;種&amp;#34;; } LIS 模板 DP const int N = 100; int s[N], length[N]; int LIS() { for (int i=0; i&amp;lt;N; i++) length[i] = 1; for (int i=0; i&amp;lt;N; i++) for (int j=0; j&amp;lt;i; j++) if (s[j] &amp;lt; s[i]) length[i] = max(length[i], length[j] + 1); int l = 0; for (int i=0; i&amp;lt;N; i++) l = max(l, length[i]); return l; } Robinson-Schensted-Knuth Algorithm 時間複雜度 O(NlogL) ， N 是序列長度， L 是 LIS 長度。 int LIS(vector&amp;lt;int&amp;gt;&amp;amp; s) { if (s.</description></item><item><title>StarCoder2021暑訓：Week03</title><link>https://blog.smallten.tk/p/star_coder-04/</link><pubDate>Wed, 28 Jul 2021 05:48:25 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-04/</guid><description>主題 圖、狀態搜尋、拓樸排序、尤拉路 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用演算法 基本題 UVa 10004 無向圖的兩色著色問題 DFS/BFS 均可 V UVa 10959 求無向無權圖上每一點和一指定點的最短距離 BFS V UVa 572 求二維地圖上的連通塊數量 DFS/BFS 均可 V UVa 441 給定 k 個數，由小到大列出所有包含其中 6 個數的遞增數列 DFS UVa 567 求無向無權圖上指定兩點間的最短距離 BFS (或用後面會學到的 Floyd-Warshall 演算法) V UVa 10926 給有向無環圖，求最大一棵樹的節點數減1 DFS/BFS 均可 SPOJ PT07Z 求數直徑（經典題） DFS/BFS 均可 UVa 10603 倒水問題（給三個水瓶，倒出指定水量） BFS 變型 (帶權最短路) UVa 10305 給定 n 個工作的兩兩先後關係，輸出任一個合法的工作完成順序。 拓樸排序 V UVa 1423 給定一數列中 Sij = a[i]+…+a[j] 的正負號，輸出一組符合正負號關係的數列。(有趣，值得思考！) 拓樸排序 UVa 302 給定一個無向圖和指定起點，列印尤拉路。 尤拉路 UVa 10441 給定一堆字串，問如何將它們頭尾相連串起來。 尤拉路 參考作法 A - Bicoloring #include &amp;lt;bits/stdc++.</description></item><item><title>PlayStation Vita-03：NoPayStation Browser</title><link>https://blog.smallten.tk/p/psv-03/</link><pubDate>Mon, 26 Jul 2021 11:50:17 +0800</pubDate><guid>https://blog.smallten.tk/p/psv-03/</guid><description>下載 NPS Clients，並放到一個資料夾中。 下載 pkg2Zip，並將 pkg2zip.exe 放到同一個資料夾中。 執行 NPS_Browser.exe。 複製以下連結： Games PSV tsv http://nopaystation.com/tsv/PSV_GAMES.tsv PSM tsv http://nopaystation.com/tsv/PSM_GAMES.tsv PSX tsv http://nopaystation.com/tsv/PSX_GAMES.tsv PSP tsv http://nopaystation.com/tsv/PSP_GAMES.tsv PS3 tsv http://nopaystation.com/tsv/PS3_GAMES.tsv DLCs: PSV tsv http://nopaystation.com/tsv/PSV_DLCS.tsv PSP tsv http://nopaystation.com/tsv/PSP_DLCS.tsv PS3 tsv http://nopaystation.com/tsv/PS3_DLCS.tsv Themes: PSV tsv http://nopaystation.com/tsv/PSV_THEMES.tsv 設定 Download and unpack dir: 檔案下載後的位置。 設定 Any pkg dec tool: 路徑為 pkg2Zip.exe 的位置。 設定 Your pkg dec params: -x {pkgFile} &amp;quot;{zRifKey}&amp;quot;。 設定 HMAC key for updates: E5E278AA1EE34082A088279C83F9BBC806821C52F2AB5D2B4ABD995450355114。 設定 CompPack URL: https://gitlab.</description></item><item><title>PlayStation Vita-02：NoNpDrm</title><link>https://blog.smallten.tk/p/psv-02/</link><pubDate>Mon, 26 Jul 2021 11:46:32 +0800</pubDate><guid>https://blog.smallten.tk/p/psv-02/</guid><description> 在 PSV 執行 Vita Shell，然後按一下 Select 按鈕，最後以 USB 連接 PC。 下載 NoNpDrm，並將 nonpdrm.skprx 放進 tai 資料夾中。 回到 PSV 的 Vita Shell 中，並到達 ux0:tai/，選擇 config.txt。 找到並移到 *KERNEL 那行，按一下三角形按鈕，選 Insert empty line。 選擇下方新增的空白行，並輸入 ux0:tai/nonpdrm.skprx，然後儲存離開。 到設定中的 HENkaku 設置，選擇 重載 taiHEN config.txt。 重新啟動 PSV。</description></item><item><title>PlayStation Vita-01：H-encore 2</title><link>https://blog.smallten.tk/p/psv-01/</link><pubDate>Mon, 26 Jul 2021 11:04:05 +0800</pubDate><guid>https://blog.smallten.tk/p/psv-01/</guid><description> 下載 Qcma 並安裝到電腦上。 PSV 以 USB 的方式連接到 PC。 下載 Final h-encore，然後將其解壓縮，最後執行它。 點擊 Let&amp;rsquo;s Go ，然後等到 100% 完成。 回到 PSV 的檔案管理 (Content Manager)，然後選擇複製內容(Copy Content) PC to PSV，之後 Applications &amp;gt; PS Vita，最後選 h-encore 2 再按 複製(Copy) &amp;gt; OK。 拔掉 USB，執行 PSV 桌面上的 h-encore 2。 PSV 記得要連網，然後選 Install HENkaku &amp;gt; Download VitaShell &amp;gt; Exit 到設定確認系統資訊，確認成功後，再去設定 HENkaku。 之後若有重開機的話，得重新進入 h-encore 2 再離開即可。</description></item><item><title>StarCoder2021暑訓：Week02</title><link>https://blog.smallten.tk/p/star_coder-03/</link><pubDate>Sat, 24 Jul 2021 08:26:57 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-03/</guid><description>主題 STL、併查集 併查集模板 int dsu[MAX_N]; void init(int num) { for(int i = 0; i &amp;lt;= num; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用結構 優先練習 UVa 673 括號匹配與 LIFO 操作 std::stack v UVa 442 括號匹配與 LIFO 操作 std::stack UVa 12100 遍歷和 FIFO 操作 std::queue (加上 std::priority_queue 效率更高) v UVa 245 取出第 n 個以及插入頭端 std::list / std::deque / std::vector UVa 1203 插入與取出最小值 std::priority_queue v UVa 11995 模擬 stack, queue, priority_queue std::stack, std::queue, std::priority_queue v UVa 10583 標準併查集操作 disjoint set v UVa 11987 併查集的變化題(值得思考) disjoint set UVa 1665 判斷連通塊數 disjoint set UVa 230 字串排序與搜尋 std::map / std::set v UVa 1592 字串比較（將字串轉成數值以加快比較） std::map 參考作法 A - Parentheses Balance #include &amp;lt;bits/stdc++.</description></item><item><title>2021 R2S CTF</title><link>https://blog.smallten.tk/p/experience-01/</link><pubDate>Mon, 19 Jul 2021 14:03:54 +0800</pubDate><guid>https://blog.smallten.tk/p/experience-01/</guid><description>前情提要  一開始時，學長們在 Messenger 的群組裡問有沒有人要參加這場新手向的 CTF 競賽，我是沒有選擇參加的 (因為我從來沒有深入的去玩、學習這方面的東東，可以算是個純正的小萌新~~)，然而到最後因為人數的關係學長們組成了兩隊，然後還能再多 2 個人，因此我也加入想說去見見世面也好。(其中還得感謝學長們的鼓勵，以及願意帶我這個什麼都不會的新手)😆😆
競賽簡介 R2S CTF 競賽網站 Online Qualification : 7/16 - 18 Flag 樣式：R2S{} 成績 All: 7 / 81 Offical Only: 4 / 43 解題紀錄 以下是我解的題目，其他題目我無能為力，就只能看有沒有學長寫題解了(顆顆 Welcome Welcome to R2S CTF o((&amp;gt;ω&amp;lt; ))o 在 R2S Discord 群組中的 challenge-announcement 頻道中，有黑黑的訊息要點開就能到 Flag 了。 一開始覺得很酷，事後知道了這叫暴雷標籤 ||暴雷訊息||。 Forensics Headache 這題依照 CRC32 找出圖片的長寬，並用 hex editor 把 png 的 header 改成正確的就行了。 Crypto Base1024 這題將那堆 emoji 解碼後就得到 Flag 了。 ecoji、ecoji 線上工具 BiGGG_RSA 一開始不知道怎麼分解 N，對於 Factordb 來說也太大了，解不出來。之後到了這個 primefac-fork，再寫個簡單的程式就解決了。 Seeeeed 也是 RSA 相關題。 Misc Time Traveler nc time-traveler.</description></item><item><title>StarCoder2021暑訓：Week01</title><link>https://blog.smallten.tk/p/star_coder-02/</link><pubDate>Thu, 15 Jul 2021 00:07:54 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-02/</guid><description>主題 搜尋、排序、貪心 題目 Virtual Judge 參考作法 A - Flip Sort 題目說明： 給一堆數字，輸出要交換(只能相鄰交換)多少次，才能由小到大排好。 解題思路： Bubble sort 程式碼： #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int n, a[1005]; while(cin &amp;gt;&amp;gt; n) { int ans = 0; for(int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; a[i]; for(int i = 0; i &amp;lt; n; ++i) { for(int j = n - 1; j &amp;gt; i; --j) { if(a[j] &amp;lt; a[j - 1]) { swap(a[j], a[j - 1]); ++ans; } } } cout &amp;lt;&amp;lt; &amp;#34;Minimum exchange operations : &amp;#34; &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } B - Age Sort 題目說明： 給一堆數字，由小到大排序。 解題思路： std::sort() 小心 Presentation error 程式碼： #include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓</title><link>https://blog.smallten.tk/p/star_coder-01/</link><pubDate>Wed, 14 Jul 2021 22:52:11 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-01/</guid><description>簡介 週次 主題 題目 一 搜尋、排序、貪心 Link 二 STL、併查集 Link 三 圖、狀態搜尋、拓樸排序、尤拉路 Link 四 動態規劃 Link 五 最小生成樹 Link 六 最短路徑 Link 學習資源 第一週 - 搜尋、排序、貪心 線上教材 教材 說明 師大碼賽客：排序/貪心/二分搜 子緯學長的教學講義（詳盡的新手入門） 北一女培訓：排序 六種排序法的程式與簡介 建中培訓 (第4/6/7節) 4.排序STL/6.貪心/7.二分搜 台大資訊之芽：貪心 貪心法與理論/Huffman Tree 成大競程培訓 (單元5/6) 5.</description></item><item><title>程式設計(二)-08：Linux List</title><link>https://blog.smallten.tk/p/computer_programming_2-08/</link><pubDate>Tue, 13 Jul 2021 22:25:50 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-08/</guid><description>linuxlist.h #pragma once struct list_head { struct list_head *next, *prev; }; #define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) } #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) /* * Insert a new entry between two known consecutive entries. * * This is only for internal list manipulation where we know * the prev/next entries already! */ static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next) { next-&amp;gt;prev = new; new-&amp;gt;next = next; new-&amp;gt;prev = prev; prev-&amp;gt;next = new; } /** * list_add - add a new entry * @new: new entry to be added * @head: list head to add it after * * Insert a new entry after the specified head.</description></item><item><title>程式設計(二)-07：Some Tricks</title><link>https://blog.smallten.tk/p/computer_programming_2-07/</link><pubDate>Tue, 13 Jul 2021 21:39:10 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-07/</guid><description>Predefined Macros Standard Predefined Macros #include &amp;lt;stdio.h&amp;gt;int main() { printf(&amp;#34;line: %d \n&amp;#34;, __LINE__); printf(&amp;#34;file: %s \n&amp;#34;, __FILE__); printf(&amp;#34;function: %s \n&amp;#34;, __FUNCTION__); // gcc printf(&amp;#34;function: %s \n&amp;#34;, __func__); // C99 printf(&amp;#34;time: %s \n&amp;#34;, __TIME__); printf(&amp;#34;date: %s \n&amp;#34;, __DATE__); printf(&amp;#34;STDC: %d \n&amp;#34;, __STDC__); printf(&amp;#34;STDC_VERSION: %ld \n&amp;#34;, __STDC_VERSION__); printf(&amp;#34;TIMESTAMP: %s \n&amp;#34;, __TIMESTAMP__); return 0; } 我們可以怎麼使用這些 Macros ? fprintf(stderr, &amp;quot;Internal␣error: at %s, line %d. ver %s %s&amp;quot;, __FILE__, __LINE__, __DATE__, __TIME__); Define when Compiling gcc -D__DEBUG__ debug.</description></item><item><title>程式設計(二)-06：Macro</title><link>https://blog.smallten.tk/p/computer_programming_2-06/</link><pubDate>Tue, 13 Jul 2021 20:47:06 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-06/</guid><description>Preprocessor 預處理器 在編譯器將您的源代碼編譯為組語前，還有一個稱為預處理的附加階段。 Objective: Produce a source code file with preprocessing commands properly sorted out. Preprocessor commands are known as Directives. Preprocessor provides certain features, which are called preprocessor directives. Preprocessor directive 以 # 為開頭。(例如：#include &amp;lt;stdio.h&amp;gt;) Preprocessor directives 可以被放在程式中的任何地方。但建議放在開頭，並且每個必須獨立一行。 #include &amp;lt;stdio.h&amp;gt;#define MACRO_DEMO 123 int main() { printf(&amp;#34;demo:␣%d\n&amp;#34;, MACRO_DEMO); return 0; } 以 gcc -E main.c 查看預處理後的狀態。 Macro 巨集 #define is known as macro expansion.</description></item><item><title>程式設計(二)-05：Variable Length Arguments List</title><link>https://blog.smallten.tk/p/computer_programming_2-05/</link><pubDate>Mon, 12 Jul 2021 21:57:26 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-05/</guid><description>Program Argument argc, argv #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;int main(int argc, char *argv[]) { printf(&amp;#34;argc: %d\n&amp;#34;, argc); for(int32_t i = 0 ; i &amp;lt; argc ; i++) printf(&amp;#34;argv[%d]: %s\n&amp;#34;, i, argv[i]); return 0; } 誰呼叫了 main 函式? 誰提供了 argc 和 argv 到 main 函式? Is main() the actual starting entry point? No! Actually, the process start from _start which is defined in crt1.o. 等等&amp;hellip; 我並沒有使用 crt1.o 呀! 實際上是有的。請查看 gcc -v $ nm /usr/lib/x86_64-linux-gnu/crt1.</description></item><item><title>程式設計(二)-04：File Processing-02</title><link>https://blog.smallten.tk/p/computer_programming_2-04/</link><pubDate>Sat, 08 May 2021 17:23:11 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-04/</guid><description>如何顯示 BMP 檔 ? 有很多 libraries 可以幫助您做到這一點。實際上，您應該使用它們而不是從頭開始開發。 如何在螢幕上顯示圖像？ 您必須至少學習一個 GUI 庫，例如 Gtk、Qt 等。 我的建議：Qt。但是，這是一個 C++ 框架。 了解如何使用 GUI 平台提供的功能顯示圖像。 GTK GTK（以前稱為 GTK+、GIMP ToolKit）是一個免費的開源跨平台的部件工具箱 (widget toolkit)，用於創建圖形用戶界面（GUIs）。 GTK 是用 C 語言所編寫的物件導向的部件工具箱。它使用 GObject（即 GLib 物件系統）進行物件導向。 因此，不要告訴我 C 不能物件導向。 安裝：sudo apt install libgtk-3-dev SDL Simple DirectMedia Layer SDL是跨平台的軟件開發庫，為計算機多媒體硬件組件提供硬件抽象層。 視頻 聲音的 輸入設備 光盤 螺紋 共享對象加載 聯網 計時器 3D圖形 軟體開發者可以使用它來編寫高性能的電腦遊戲和其他多媒體應用程式。 SDL 架構 / 範例 SDL Object SDL_Window：包含有關 Window 本身的所有信息的結構：大小、位置、全螢幕、邊框等。 SDL_Renderer：處理所有渲染的結構。它與 SDL_Window 綁定在一起，因此只能在該 SDL_Window 中呈現。 SDL_Textures 和 SDL_Surface：SDL_Renderer 渲染SDL_Texture(存儲一個元素的像素資訊)。這是 SDL_Surface 的新版本，他們幾乎相同。 重要的區別是 SDL_Surface 使用軟件渲染（通過CPU），而 SDL_Texture 使用硬件渲染（通過GPU）。 安裝：sudo apt-get install libsdl2-dev libsdl2-image-dev Makefile CFLAGS := `sdl2-config --libs --cflags` -ggdb3 -O0 --std=c99 -Wall -lSDL2_image -lm all: example.</description></item><item><title>程式設計(二)-03：File Processing-01</title><link>https://blog.smallten.tk/p/computer_programming_2-03/</link><pubDate>Fri, 02 Apr 2021 17:58:22 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-03/</guid><description>File C 將每個檔案視為一個連續的 bytes stream 每個檔案以 end-of-file 為結尾，這是由系統提供而不是文件。 It looks like there is an additional byte appended to the file. However, that additional byte does not exist. Instead, it is a signal raised by your system. int feof(FILE *stream); File Stream Streams 提供了更高級別的介面(interface)讓你存取資料。 fprintf fscanf 事實上，你已經使用過 file stream ! 三種標準流 標準輸入 0 (standard input.) 標準輸出 1 (standard output.) 標準錯誤 2 (standard error.</description></item><item><title>程式設計(二)-02：Structure</title><link>https://blog.smallten.tk/p/computer_programming_2-02/</link><pubDate>Fri, 02 Apr 2021 16:24:46 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-02/</guid><description>Structure Structures 就是將一堆相關的變數整合在一個名字下。 關鍵字：struct 資料型別：struct _name_ 成員：在 struct 的大括號內宣告的變數。 同一個結構體下的成員名稱是唯一的。 struct _sCard{ uint8_t suit, face; }; 初始化 struct _sCard a_card = {.suit = 1, .face = 2}; struct _sCard a_card = {1, 2}; structure member operator -&amp;gt; . structure pointer operator -&amp;gt; -&amp;gt; a_card_ptr = &amp;amp;a_card; a_card_ptr-&amp;gt;face = 5; // Equivalent to (*a_card_ptr).face = 5; CPU Alignment CPU 有時候會為了減少從記憶體呼叫變數的次數，而主動將變數的記憶體放在連續的地方。 為了避免 alignment，你可以使用以下兩種方法： __attribute__((packed)) pragma #pragma pack(push) #pragma pack(1) #pragma pack(pop) // 法一 struct st{ .</description></item><item><title>程式設計(二)-01：String</title><link>https://blog.smallten.tk/p/computer_programming_2-01/</link><pubDate>Fri, 02 Apr 2021 14:40:30 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_2-01/</guid><description>字元 在講字串之前我們先來看什麼是字元。 ASCII American Standard Code for Information Interchange. 電子通訊的字元編碼標準 基於英文字母，ASCII 將 128 個字元編碼成 7 個位元長。 95 個可印字元：A-Z, a-z, 0-9, 標點符號 不可印字元：換行符號 在電腦中我們使用 8-bit 的記憶體儲存字元。 在 C 語言中，使用 char 這個型別。 %c -&amp;gt; 輸出字元 %x or %X -&amp;gt; 印出 hex or HEX 的值。 在以前，許多情況下，有些人使用 unsigned char 作為 one byte 的資料型別，但現今你應該使用的是 uint8_t。 請把 char 留給字串，盡管事實上對電腦來說都是一樣的。 其他編碼：Big5、UTF-8 字串 事實上，字串就是一連串的可印字元。 這樣看起來很像陣列對吧?</description></item><item><title>Hugo-02：優化 Blog</title><link>https://blog.smallten.tk/p/hugo-02/</link><pubDate>Sun, 07 Feb 2021 04:06:17 +0800</pubDate><guid>https://blog.smallten.tk/p/hugo-02/</guid><description>簡介 這部份是紀錄我修改的主題內容，並將 codeblocks 區塊美化，以及支援 KaTex 和 Google Analytics 教學開始 我使用的主題為 Stack 主題內容修改 找到 assets/scss/variables.scss，並修改 --link-background-color: 90, 240, 250; //189, 195, 199; --code-text-color: #ef3982; //rgba(255, 255, 255, 0.9); Codeblocks 區塊美化 到 static/css/ 下建立 copy-to-clipboard.css，內容如下 .highlight { position: relative; } .highlight .ln { -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; } .highlight-copy-btn { position: absolute; top: 7px; right: 7px; border: 0; border-radius: 4px; padding: 1px; font-size: 0.</description></item><item><title>Hugo-01：建立一個Hugo Blog</title><link>https://blog.smallten.tk/p/hugo-01/</link><pubDate>Sun, 07 Feb 2021 03:22:22 +0800</pubDate><guid>https://blog.smallten.tk/p/hugo-01/</guid><description>簡介 這篇內容將快速帶你建立一個 Hugo Blog 並將其部屬到 GitHub 上 相關連結 Hugo - Hugo 官網 Hugo Themes - 選擇自己喜歡的主題 Hugo Releases - 下載 Hugo 並安裝進電腦 教學開始 建立 Hugo Blog 安裝 Hugo 這裡以 Ubuntu 為示範 先至 Hugo Releases 下載自己所需的版本 $ dpkg -i hugo_extended_0.79.0_Linux-64bit.deb # 記得依照檔案自行更改 創建一個 Hugo Site 這裡創建一個名為 blog $ cd ~ $ hugo new site blog # 可自行修改名稱 新增主題 這裡我選擇了 Stack 這個主題 $ cd ~/blog/ $ git init $ git submodule add https://github.</description></item><item><title>程式設計(一)-08：Pointer</title><link>https://blog.smallten.tk/p/computer_programming_1-08/</link><pubDate>Wed, 23 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-08/</guid><description>Pointer 許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分 指標是一個變數，其值為記憶體位置 宣告：int32_t *p p 是一個指標 指向的記憶體區塊被視為整數 初始化：int32_t *p = NULL address operator &amp;amp;：返回其變數的記憶體位置 如果想要印出記憶體位置，你可以使用%p indirection operator *：也被稱為dereferencing operator，返回指向對象的值 void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別 傳參數至函式 在C語言中，argument passing 稱為 call-by-value 電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行 這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。 陣列與指標 在大部分的情況下，我們可以把array視為第一個元素的指標 現在你應該明白為什麼陣列的值會在函式中被修改 為了避免模棱兩可(搞混)，我較喜歡&amp;amp;(array[0])而不是array、&amp;amp;array 然而你不能寫出 array = &amp;amp;a int32_t int16_t int8_t ptr++ 移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用 事實上，array[n] = *(ptr + n) Endian Issue</description></item><item><title>First Hugo Blog</title><link>https://blog.smallten.tk/p/first-hugo-blog/</link><pubDate>Fri, 18 Dec 2020 01:16:06 +0800</pubDate><guid>https://blog.smallten.tk/p/first-hugo-blog/</guid><description>第一個 Hugo Blog  由於秉持著「人生總折騰」的道理，我來轉移 Blog 了(誤///)，好啦，其實是單純希望有個穩定且又能全天候供應的 Blog 而已，由於我的隊友兩人分別使用了 Hexo 及 Hugo ，因此一開始讓我有點難抉擇，但最終我還是選擇了 Hugo 。
 至於第二個選擇的難關就是主題了，挑了好久都沒看到順眼的，差點就要聽吳文元說的沒有喜歡的就自己寫呀(怕///)，最終還是挑到了一個稍微滿意的主題 Stack。
 至於架設的過程到目前為止還算是蠻順利的，希望之後也不會遇到什麼大坑。</description></item><item><title>演算法-01：蓄水池抽樣法</title><link>https://blog.smallten.tk/p/algorithm-01/</link><pubDate>Tue, 08 Dec 2020 16:02:25 +0800</pubDate><guid>https://blog.smallten.tk/p/algorithm-01/</guid><description>蓄水池抽樣法 (Reservoir Sampling) 從 N 個樣本中，隨機抽取 K 個樣本，其中 N 非常大(不能將所有數據都放進記憶體或是一個未知數)，而每個被抽出來的機率要相等。 定理 該算法保證每個元素以 \( k \over n \) 的機率被選入蓄水池中。
證明 第 i 個元素進入蓄水池的機率為 \( k \over i \)，蓄水池內每個元素被替換的機率為\( 1 \over k \) 因此在第 i 輪第 j 個元素被替換的機率為 \( {k \over i}\times{1 \over k} = {1 \over i} \)，接下來用 M.I. (數學歸納法)來證明，當 n 次循環結束時每個元素進入蓄水池的機率為 \( k \over n \) 假設在 (i-1) 次迭代後，任意一個元素進入 蓄水池的概率為 \( k \over i-1 \)。由上面的結論，在第 i 次迭代時，該元素被替換的概率為 \( 1 \over i \)， 那麼其不被替換的概率則為 \( 1 - {1 \over i} = {i - 1 \over i} \) 故在第 i 次迭代後，該元素在蓄水池內的概率為 \( {k \over i-1} \times {i-1 \over i} = {k \over i} \)，歸納結束。 因此當循環結束時，每個元素進入蓄水池的概率為 \( k \over n \)，命題得證。 例題 Leetcode 382.</description></item><item><title>程式設計(一)-07：Array</title><link>https://blog.smallten.tk/p/computer_programming_1-07/</link><pubDate>Mon, 07 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-07/</guid><description>Array 陣列是一種可以儲存大量相同型別資料的方法。 連續的記憶體位置。 永遠從0開始 int32_t a[10] -&amp;gt; a[0] ~ a[9] 計數變數 i 的型別可以宣告為 size_t，它是一個無號的整數型別。 初始化 int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0}; 存取陣列元素使用 variable[index] 專業說明：電腦將找到第一個元素的地址，然後根據索引移動記憶體位置以訪問數據。 事實上一維陣列可以處理所有情況，至於多維陣列只是給人類方便閱讀的。 define 是遇處理指令，不是C的詞(statement) 我們可以使用 #define 去做巨集(MACRO) 當開發時MACRO有些像function，然而對電腦而言他們是不同的。 當遇到MACRO，編譯器將簡單的依定義替換掉程式碼。 函式擁有自己的標記。 基本排序 氣泡排序法 for(int i = 0; i &amp;lt; n; ++i) { for(int j = i; j &amp;lt; n; ++j) { if(a[j] &amp;lt; a[i]) { a[i] = a[i] ^ a[j]; a[j] = a[i] ^ a[j]; a[i] = a[i] ^ a[j]; } } } qsort #include &amp;lt;stdlib.</description></item><item><title>程式設計(一)-06：Makefile</title><link>https://blog.smallten.tk/p/computer_programming_1-06/</link><pubDate>Wed, 02 Dec 2020 21:45:51 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-06/</guid><description>Makefile for 程設一 CC = gcc CFLAGS = -Wall -Wextra -O2 -std=c11 LDFLAGS = -lm TARGETS = main01 main02 main01_OBJ = main01.o func01.o main02_OBJ = main02.o func02.o .PHONY = all clean all: $(TARGETS) .SECONDEXPANSION: $(TARGETS): $$($$@_OBJ) $(CC) $^ -o $@ $(LDFLAGS) %.o: $@.c clean: -$(RM) $(TARGETS) $(foreach targ,$(TARGETS),$(foreach obj, $($(targ)_OBJ), $(obj)))</description></item><item><title>程式設計(一)-05：Function</title><link>https://blog.smallten.tk/p/computer_programming_1-05/</link><pubDate>Sat, 21 Nov 2020 21:48:47 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-05/</guid><description>Function 函式 double double 是一種浮點數型別，就像是 float 就如同它的名字，它使用的記憶體大小為 float 的兩倍 建議: 當你需要浮點數的話，一律使用 double 到目前為止我們最常使用到的函式為 printf 我們稱這些函式為 C standard functions (C標準函式) 所有的函式都被儲存在libraries中 如果你想要讀書，你需要知道書在哪，然後去圖書館借書 如果你想要使用函式，你需要知道函式在哪，然後include library去使用函式 例如: stdio.h &amp;lt;-&amp;gt; printf 使用 math.h 時，需下編譯參數 -lm 永不重新發明輪子 在開發前請先搜尋 //原型宣告 Return-Value-Type Function-Name (parameter-Type-list); Return-Value-Type Function-Name (parameter-list){ Statements } 使用原型宣告並將自訂函式置於main function之後的好處? 不用管function之間的先後順序。 void 沒有型別 在這裡，代表不需要回傳值 標頭檔 (Header Files) 甚麼是header file?</description></item><item><title>程式設計(一)-04：Loop</title><link>https://blog.smallten.tk/p/computer_programming_1-04/</link><pubDate>Sun, 18 Oct 2020 20:33:18 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-04/</guid><description>Loop - `while` - `for` - `do while` While Loop while(條件){ 執行區塊 } %.200f 會發生什麼事? -&amp;gt; 精度不夠沒有意義 while(1) -&amp;gt; 無窮迴圈 For Loop for(初始化; 條件; 執行後操作){ 執行區塊 } i++ -&amp;gt; Use the current value of i. -&amp;gt; i = i + 1 ++i -&amp;gt; i = i + 1 -&amp;gt; Use the new value of i. {} -&amp;gt; 變數生命週期範圍 %4d ( %# ) -&amp;gt; 給最小的位數去顯示 在 ANSI C, 變數只能被宣告在函式的開頭，而 Modern C 沒有任何限制 Do While Loop do{ 執行區塊 }while(條件) 三種不同類型的迴圈毫無疑問的都可以互相轉換 除了 do while 至少會執行一次 大多數來說，如果你知道要執行幾次迴圈的話，會使用 for break：離開當前的區段 continue：跳過剩餘的敘述，直接執行下一次迭代 無窮迴圈不是個好東西?</description></item><item><title>程式設計(一)-03：Condition Control</title><link>https://blog.smallten.tk/p/computer_programming_1-03/</link><pubDate>Thu, 15 Oct 2020 20:53:14 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-03/</guid><description>Condition Control 簡介 我們想要讓電腦去做基礎的判斷 if switch If if (condition1) { statements; } else if (condition2){ ... } else { ... } 如果條件不是錯誤，那麼將會執行大括號裡的敘述 簡而言之，false 被定義為 0 &amp;gt; -&amp;gt; 大於 &amp;lt; -&amp;gt; 小於 &amp;gt;= -&amp;gt; 大於等於 &amp;lt;= -&amp;gt; 小於等於 == -&amp;gt; 等於 != -&amp;gt; 不等於 &amp;amp;&amp;amp; -&amp;gt; and || -&amp;gt; or Boolean 在 Cpp 裡，有個型別稱為 bool 它只有兩個值：true, false 那麼 bool 使用的記憶體大小為何能?</description></item><item><title>程式設計(一)-02：Arithmetic</title><link>https://blog.smallten.tk/p/computer_programming_1-02/</link><pubDate>Thu, 15 Oct 2020 11:19:09 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-02/</guid><description>Arithmetic #include &amp;lt;stdio.h&amp;gt;int main(){ int a = 1, b = 2, sum = 0; sum = a + b; printf(&amp;#34;%d&amp;#34;, sum); return 0; } 變數 每個變數都必須有它的型別 在使用變數前必須先宣告它 在C裡面， = 意思為”指定”，而不是”相等”，指派右邊的數值給左邊的變數 一個好習慣，總是初始化變數 C Spec: C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero. In C99: a == (a / b) * b + a % b printf 是一個函式去印出格式化字串 %d -&amp;gt; 有號十進位整數 %f -&amp;gt; 十進位浮點數 %u -&amp;gt; 無號十進位整數 當然不只這些 小技巧 a += b -&amp;gt; a = a + b a -= b -&amp;gt; a = a - b a *= b -&amp;gt; a = a * b a /= b -&amp;gt; a = a / b a %= b -&amp;gt; a = a % b 查看記憶體使用大小： sizeof()，回傳單位為 byte ( printf(&amp;quot;%lu&amp;quot;, sizeof()); ) #include &amp;lt;stdint.</description></item><item><title>Python-04：多線程-ts下載並合併成mp4</title><link>https://blog.smallten.tk/p/python-04/</link><pubDate>Sun, 04 Oct 2020 16:36:35 +0800</pubDate><guid>https://blog.smallten.tk/p/python-04/</guid><description>簡介  這篇將帶你下載m3u8檔並分析出ts的檔案，再透過多線程來加速下載，之後再由FFmpeg合併成mp4。
Python 下載m3u8 m3u8Url = &amp;#39;https://.../index.m3u8&amp;#39; def downloadM3u8(url): r = requests.get(url) with open(&amp;#39;./index.m3u8&amp;#39;, &amp;#39;wb&amp;#39;) as f: f.write(r.content) 分析m3u8 這部份請依照你所取得的m3u8檔進行分析，並將完整的ts檔的url放進tsList即可。 tsList = [] tsCnt = 0 def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(&amp;#39;/&amp;#39;, 1)[0] + &amp;#39;/&amp;#39; with open(&amp;#39;./index.m3u8&amp;#39;, &amp;#39;r&amp;#39;) as f: text = f.read() textList = text.split(&amp;#39;\n&amp;#39;) while textList[-1] != &amp;#39;#EXT-X-ENDLIST&amp;#39;: textList.pop(-1) for i in textList: if i[0] != &amp;#39;#&amp;#39;: tsList.append(tempUrl + i) global tsCnt tsCnt = len(tsList) 下載ts檔 q = queue.</description></item><item><title>Python-03：m3u8影片下載</title><link>https://blog.smallten.tk/p/python-03/</link><pubDate>Sun, 04 Oct 2020 11:07:24 +0800</pubDate><guid>https://blog.smallten.tk/p/python-03/</guid><description>簡介 現今你時常能在影音媒體網站看到 .m3u8 的檔案，以及許多 .ts 的分段媒體，本篇將教你如何簡單的下載成 .mp4 檔。 這篇並不詳加敘述 HLS 之類的觀念，若有興趣深入了解請自行查找資料。 FFmpeg FFmpeg官網 下載安裝完後，若為 windows 用戶請將 %ffmpeg%\bin 的路徑加入環境變數中，並於terminal中執行 ffmpeg -version 來查看是否成功加入。 下載檔案，直接在 terminal 輸入 ffmpeg -i m3u8URL -c copy filname.mp4，即可完成下載。(下面將提供Python的寫法) Python # -*- coding: UTF-8 -*- import ffmpeg_streaming from ffmpeg_streaming import Formats url = &amp;#39;https://.../index.m3u8&amp;#39; filename = &amp;#39;test.mp4&amp;#39; def ffmpeg_download(input_path, output_path): video = ffmpeg_streaming.input(input_path) stream = video.stream2file(Formats.h264()) stream.output(output_path) if __name__ == &amp;#34;__main__&amp;#34;: ffmpeg_download(url, &amp;#39;./&amp;#39; + filename) 下一篇將教你如何直接從 m3u8 裡讀取目錄，並使用多線程下載 ts 並合併成 mp4</description></item><item><title>程式設計(一)-01：Your first program</title><link>https://blog.smallten.tk/p/computer_programming_1-01/</link><pubDate>Sun, 04 Oct 2020 11:00:48 +0800</pubDate><guid>https://blog.smallten.tk/p/computer_programming_1-01/</guid><description>Hello World #include &amp;lt;stdio.h&amp;gt;//Your first code. int main(){ printf(&amp;#34;Hello World\n&amp;#34;); return 0; } main是每個C程式的進入點，我們稱它為main function(主函式) int 及 return 是C裡面的Keywords int代表這個函式將會回傳一個整數 每個函式都應該有一個回傳值 每個敘述的結尾都應該要有 ; printf 是一個會顯示格式化字串的函式 \n -&amp;gt; 換行 \t -&amp;gt; tab \\ -&amp;gt; \ \&amp;quot; -&amp;gt; “ # 的那一行是C的預處理器並且不需要;結尾 stdio.h -&amp;gt; standard input / output header(標準輸出/輸入標頭檔) 註解 -&amp;gt; 是給開發者看的 //Your code -&amp;gt; 單行 /*Your code*/ -&amp;gt; 多行 使用編譯器將程式碼編譯成組合語言，再由組譯器組議成機械碼或可執行的二進制檔 IDE -&amp;gt; Integrated Development Environment，不是編譯器 gcc是最受歡迎的C編譯器之一(不完全對!</description></item><item><title>Python-02：多線程-加速圖片下載</title><link>https://blog.smallten.tk/p/python-02/</link><pubDate>Mon, 03 Aug 2020 00:56:43 +0800</pubDate><guid>https://blog.smallten.tk/p/python-02/</guid><description>簡介 接續上一篇Python-01：爬蟲-圖片下載的內容，這篇文章將帶領大家使用多線程來加速圖片的下載 教學開始 首先我們先看個簡單的多線程範例 import time, threading # 子執行緒的工作函數 def job(): for i in range(5): print(&amp;#34;Child thread:&amp;#34;, i) time.sleep(1) # 建立一個子執行緒 t = threading.Thread(target = job) # 執行該子執行緒 t.start() # 主執行緒繼續執行自己的工作 for i in range(3): print(&amp;#34;Main thread:&amp;#34;, i) time.sleep(1) # 等待 t 這個子執行緒結束 t.join() print(&amp;#34;Done.&amp;#34;) import time, threading # 子執行緒的工作函數 def job(num): print(&amp;#34;Thread&amp;#34;, num) time.sleep(1) # 建立 5 個子執行緒 threads = [] for i in range(5): threads.</description></item><item><title>Python-01：爬蟲-圖片下載</title><link>https://blog.smallten.tk/p/python-01/</link><pubDate>Mon, 03 Aug 2020 00:39:24 +0800</pubDate><guid>https://blog.smallten.tk/p/python-01/</guid><description>簡介 這一篇將帶領大家透過Python的爬蟲自動化的下載圖片 安裝 打開終端機，安裝下列套件 pip install requests pip install BeautifulSoup4 pip install lxml pip install selenium 至 Chrome Driver 下載當前電腦中Chrome所對應版本的Driver 教學開始 首先因為這次的主題為圖片下載，因此我們找了一個擁有大量圖片的漫畫網頁來進行教學。 由於這個網頁的圖片是由JavaScript加載的，因此一開始我們使用Selenium來開啟網頁 from selenium import webdriver url = &amp;#39;https://www.ohmanhua.com/13621/1/1.html&amp;#39; #使用crx插件 chop = webdriver.ChromeOptions() chop.add_extension(&amp;#39;Adblock-Plus_v3.8.4.crx&amp;#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) 當然若不想顯示瀏覽器的視窗可以使用headless模式 chop.add_argument(&amp;#39;--headless&amp;#39;) #規避google bug chop.add_argument(&amp;#39;--disable-gpu&amp;#39;) 接下來使用BeautifulSoup4來分析頁面，並取得圖片網址，和共幾張圖片 img_count = int(soup.find(&amp;#39;select&amp;#39;, {&amp;#39;class&amp;#39;: &amp;#39;mh_select&amp;#39;}).find_all(&amp;#39;option&amp;#39;)[-1].get(&amp;#39;value&amp;#39;)) img_url = soup.find_all(&amp;#39;div&amp;#39;, {&amp;#39;class&amp;#39;: &amp;#39;mh_comicpic&amp;#39;})[0].find(&amp;#39;img&amp;#39;).get(&amp;#39;src&amp;#39;) if img_url[0] == &amp;#39;/&amp;#39;: img_url = &amp;#39;https:&amp;#39; + img_url m = len(img_url.</description></item><item><title>簡易氣象站-02</title><link>https://blog.smallten.tk/p/weather-02/</link><pubDate>Sun, 12 Jul 2020 09:31:38 +0800</pubDate><guid>https://blog.smallten.tk/p/weather-02/</guid><description>簡介 這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作在Raspberry pi用Python讀取Arduino Serial的數值，並且製作一個簡易的UI實時顯示出數值。 硬體 上一小節的成品 Raspberry pi * 1 教學開始 打開Raspberry pi的Terminal，並輸入 ls /dev/tty* 將Arduino的Usb接上Raspberry pi 再次於Terminal中輸入 ls /dev/tty*，比較兩次的差異，即可知Arduino使用的序列埠為何(例如此時為/ dev/ttyACM0，請依照情況自行修改) 於Terminal中輸入 python3 -m pip install pyserial 將以下程式碼建立成一個python檔，再以python3執行即可 # -*- coding: UTF-8 -*- import serial import tkinter as tk def getData(): ser = serial.Serial(&amp;#39;/dev/ttyACM0&amp;#39;, 9600, timeout=1) ser.flush() while True: flag = False if ser.in_waiting&amp;gt;0: arduinoData = ser.readline().decode(encoding=&amp;#39;utf-8&amp;#39;, errors=&amp;#39;ignore&amp;#39;).rstrip().split(&amp;#39;;&amp;#39;) if len(arduinoData)!=4 or arduinoData==&amp;#39;&amp;#39;: continue for i in range(0,3): if arduinoData[i]==&amp;#39;0&amp;#39;: flag = True break if flag: continue else: temperature_value[&amp;#39;text&amp;#39;] = arduinoData[0] + &amp;#39; 度C&amp;#39; humidity_value[&amp;#39;text&amp;#39;] = arduinoData[1] + &amp;#39; %&amp;#39; pmat25_value[&amp;#39;text&amp;#39;] = arduinoData[2] + &amp;#39; ug/m^3&amp;#39; wind_value[&amp;#39;text&amp;#39;] = arduinoData[3] + &amp;#39; 級&amp;#39; break window.</description></item><item><title>簡易氣象站-01</title><link>https://blog.smallten.tk/p/weather-01/</link><pubDate>Sun, 12 Jul 2020 09:02:34 +0800</pubDate><guid>https://blog.smallten.tk/p/weather-01/</guid><description>簡介 這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作由Arduino抓取感測器數值的部分。 硬體 Arduino Uno R3 * 1 攀藤 G5 PMS5003 * 1 DFrobot 三杯式風速感測器 * 1 教學開始 連結電路
Uno程式碼 #include &amp;lt;SoftwareSerial.h&amp;gt;#define windPin A0 SoftwareSerial pmsSerial(2, 3); long pmValue=0; long pmcf25=0; long pmat25=0; unsigned int temperature = 0; unsigned int humandity = 0; void retrievepm25(){ int count = 0; unsigned char c; unsigned char high; while (pmsSerial.available()) { c = pmsSerial.read(); if((count==0 &amp;amp;&amp;amp; c!=0x42) || (count==1 &amp;amp;&amp;amp; c!</description></item><item><title>Arduino-05：HC-05 AT命令</title><link>https://blog.smallten.tk/p/arduino-05/</link><pubDate>Sun, 10 May 2020 21:56:45 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-05/</guid><description>簡介 這篇內容將教大家透過Arduino的序列埠設定HC-05的AT命令 硬體 Arduino Uno * 1 HC-05藍芽模組 * 1 教學 腳位連接 Arduino HC-05 5V VCC GND GND 8 TX 9 RX 程式碼 #include &amp;lt;SoftwareSerial.h&amp;gt; SoftwareSerial BT(8, 9); char val; void setup() { Serial.begin(9600); BT.begin(38400); } void loop() { if(Serial.available()){ val = Serial.read(); BT.print(val); } if(BT.available()){ val = BT.read(); Serial.print(val); } } 連接腳位，並上傳程式碼，最後給HC-05供電前，先按住上面的按鈕，再提供電源，燈號將變成約兩秒一閃，及表示進入了AT命令模式 接下來打開序列埠監控視窗，將設定調成&amp;quot;9600 baud&amp;quot;和&amp;quot;NL與CR&amp;quot;，最後依需求輸入以下命令即可 AT -&amp;gt; 顯示OK表示連接成功 查看韌體版本 -&amp;gt; AT+VERSION 查看名稱 -&amp;gt; AT+NAME?</description></item><item><title>Arduino-04：藍芽遙控車</title><link>https://blog.smallten.tk/p/arduino-04/</link><pubDate>Sun, 03 May 2020 16:29:01 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-04/</guid><description>簡介 這篇內容將帶領大家製作藍芽的遙控車，並且用Blynk的Joystick操控它 硬體 Arduino nano * 1 L298N 馬達控制板 * 1 HC-05 藍芽模組 * 1 二輪直流馬達遙控車 * 1 下載 至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 教學開始 先上傳程式碼至Nano板中 依照下方圖示連接腳位，並且設定Blynk App內的物件 連接腳位
設定Blynk 創建3個元件，分別為Button、Bluetooth、Joystick，並且依下圖進行設置 nano程式碼 #include &amp;lt;BlynkSimpleSerialBLE.h&amp;gt;#define BLYNK_USE_DIRECT_CONNECT char auth[] = &amp;#34;Blynk Auth&amp;#34;; int d[2] = {0}; int car[2][2] = { {5, 6}, {11, 10} }; //in 1,2,4,3 int en[2] = {3, 9}; void Controller(); void Move(int, int, int, int, int, int); BLYNK_WRITE(V0){ for(int i=0; i&amp;lt;2; ++i){ d[i] = param[i].</description></item><item><title>Arduino-03：跑馬燈</title><link>https://blog.smallten.tk/p/arduino-03/</link><pubDate>Thu, 09 Apr 2020 14:50:56 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-03/</guid><description>簡介 這篇內容將帶領大家製作點陣跑馬燈，並且用Blynk來操控它 硬體 WeMos D1R2 * 1 MAX7219 8*8LED點陣模組 * 2 下載 至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 maxmatrix－下載並加入函式庫 教學開始 連接腳位 MAX7219 D1R2 VCC 5V GND GND DIN MOSI/D7 CS SS/D8 CLK SCK/D5 若要串聯多塊MAX7219的話，請將下一塊的DIN接至上一塊的DOUT連接腳位 設定Blynk 請照下圖拉出三個物件，並設定其相關參數 D1R2程式碼 #include &amp;lt;MaxMatrix.h&amp;gt;#include &amp;lt;avr/pgmspace.h&amp;gt;#include &amp;lt;ESP8266WiFi.h&amp;gt;#include &amp;lt;BlynkSimpleEsp8266.h&amp;gt; char auth[] = &amp;#34;Blynk auth&amp;#34;; char ssid[] = &amp;#34;Wifi ssid&amp;#34;; char pass[] = &amp;#34;Wifi password&amp;#34;; PROGMEM const unsigned char CH[] = { 3, 8, B0000000, B0000000, B0000000, B0000000, B0000000, // space 1, 8, B1011111, B0000000, B0000000, B0000000, B0000000, // !</description></item><item><title>Arduino-02：UNOJOY</title><link>https://blog.smallten.tk/p/arduino-02/</link><pubDate>Thu, 09 Apr 2020 08:16:57 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-02/</guid><description>簡介 這篇內容將帶領大家把Arduino手把變成電腦手把 所需硬體 Arduino Uno R3 * 1 JoyStick 雙軸按鍵搖桿模組 * 1 下載檔案 FLIP － 請下載包含JRE的檔案(Java Runtime Environment included) UnoJoy － 將Uno變成電腦手把 x360ce － 將手把模擬成xbox 360的手把 教學開始 將下載好的FLIP安裝至電腦 確定電腦已安裝Arduino IDE，並已連接Uno板至電腦，可在裝置管理員查看狀態（如下圖） 打開剛剛下載的UnoJoy資料夾下的檔案，並將它上傳進Uno板中 UnoJoy-master\UnoJoy\UnoJoyArduinoSample\UnoJoyArduinoSample.ino 關閉Arduino IDE，進入DFU Mode，進入方式：用導線同時接觸下圖框起處的兩根針腳 確認已進入 DFU Mode，如下圖 若找不到驅動可手動新增驅動，選擇資料夾為 C:\Program Files (x86)\Atmel\Flip 3.4.7\usb 打開UnoJoy資料夾，啟動TurnIntoAJoystick的批次檔，檔案路徑 UnoJoy-master\UnoJoy\TurnIntoAJoystick.bat，執行成功結果如下圖 至此已完成將Uno變成電腦搖桿，之後插上Uno板皆為UnoJoy Joystick，可在以下路徑查看 控制台\硬體和音效\裝置和印表機 將搖桿的vrx和vry分別連接至Uno板的A0和A1，在 控制台\硬體和音效\裝置和印表機 裡的UnoJoy Joystick圖示上右鍵-&amp;gt;遊戲控制器-&amp;gt;內容，可查看搖桿狀態，如下圖 最後進入起動x360ce，新建立一個搖桿的設定檔，並選取模擬的位置，點選[Record]，依圖示移動搖桿方向即設定完成 補充 如何將UnoJoy Joystick變回一般的Arduino Uno板 連接UnoJoy Joystick，並進入DFU Mode 打開UnoJoy資料夾，啟動TurnIntoAnArduino的批次檔，檔案路徑 UnoJoy-master\UnoJoy\TurnIntoAnArduino.</description></item><item><title>Arduino-01：安裝IDE</title><link>https://blog.smallten.tk/p/arduino-01/</link><pubDate>Thu, 09 Apr 2020 08:08:43 +0800</pubDate><guid>https://blog.smallten.tk/p/arduino-01/</guid><description>官方IDE 此IDE由官方提供，可在此查看官網 下載－官方載點 VSCode + PlatformIO 先下載 VSCode 再安裝 PlatformIO 的插件</description></item></channel></rss>