<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 小十的部落格</title><link>https://blog.smallten.me/post/</link><description>Recent content in Posts on 小十的部落格</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 07 Mar 2022 23:10:59 +0800</lastBuildDate><atom:link href="https://blog.smallten.me/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Reverse-01：Qiling framework</title><link>https://blog.smallten.me/p/ctf-01/</link><pubDate>Mon, 07 Mar 2022 23:10:59 +0800</pubDate><guid>https://blog.smallten.me/p/ctf-01/</guid><description>簡介 活動：2022/03/07 CTF 讀書會 講師：asef18766 陳兆閔 相關資源 Qiling rootfs Qiling hijack Qiling hook Lab1 相關檔案 crackme Lab1 解題過程 先 file 以及 執行 看看 丟 ghidra 後，可以發現在 lucky 裡面有那張 ascii art ，而且其中第 24 行 if(local_18 != 0x48763) 是我們第一個要繞過得部份。 1 2 3 4 5 6 7 8 9 10 11 from qiling import * from qiling.os.mapper import QlFsMappedObject class Fake_urandom(QlFsMappedObject): def read(self, size): return 0x48763.</description></item><item><title>2021 ICPC 亞洲區 臺北站</title><link>https://blog.smallten.me/p/experience-05/</link><pubDate>Tue, 30 Nov 2021 21:13:26 +0800</pubDate><guid>https://blog.smallten.me/p/experience-05/</guid><description>競賽簡介 ICPC 2021 日期：2021/11/27 ~ 2021/11/29 地點：國立台北商業大學 成績 解題數：3 校內：6 / 8 全體：68 / 103 心得 第一天  因為這一次又是在台北商業大學比賽，所以算是比較熟門熟路了，然後第一天是中午左右才開幕，因此我們就相約去吃了麥，善導寺捷運站旁這間麥當當還蠻大間的呢~~而這段期間有那個振興優惠的套餐，再配合甜心卡的威力，我們就獲得了一堆的薯條，😂😂。
 吃飽後當然就是去賽場報到 $\rArr$ 領衣服 $\rArr$ 換衣服 $\rArr$ 拍照 $\rArr$ 上樓進會場 $\rArr$ 開幕 $\rArr$ 講解規則及注意事項&amp;hellip;，之後就是測機，然後放東西給檢查，離場。
補充： 這一次我們名單的海報終於沒在地板上了，顆顆 然後今年的衣服跟去年幾乎一樣呀，傻眼眼 第一天當然是給餐盒呀，然後給一些餅乾在測機時吃~~ 第二天  這一天一早就要集合比賽，所以蠻早就得出門了，累呀（攤&amp;hellip;，早餐不外乎就是跑去吃永和豆漿呀，真的還算不錯，買一籠湯包還送奶茶，（但湯包份量不大，還得加點就是了）。之後跟 壯壯權 在北商裡等 文元 出現，而後就是去報到，領行李牌 $\rArr$ 放行李 $\rArr$ 進考場，然後在主考官說開始動前，都不能動桌面上的任何東西，我的小十呀!!!
 這裡有個小插曲，就是我突然發現我們桌上沒看到我們這組的 CodeBook ，竟然是因為頁碼的問題被收走全部，還好有發現，加上有爭取，所以還是有拿回其中一份，雖然比賽都沒用到就是了，😄😄
 這次比賽的情況來說，整隊的解題氛圍還算蠻不錯了，我水題開的也依然又快又穩，但最後輸在第三題的時間花了有點久，我們的銅牌呀😢😢，然後其中卡住的一題竟然是 數位 DP ，這真的沒有想到呀，還有一題是分析的時候太複雜化了，實際上沒那麼多情況要考慮呀，攤~~
 比賽後拍拍照，我們就相約走去北車吃了小火鍋，算是自行舉辦的晚宴??之後在同學的陪同下，第一次從北車搭公車回公館去（平常都是搭捷運）
補充： 這次因為疫情，比賽時候也沒有後面的餐點了，我的蛋糕、水果呀&amp;hellip; 比賽結束也沒有晚宴了，像去年露天流水席也還能接受嘛，到底為什麼要拿掉啦，🤬🤬 少了這麼多東西，報名費也沒變少呀!</description></item><item><title>九份、金瓜石二日遊</title><link>https://blog.smallten.me/p/experience-04/</link><pubDate>Mon, 22 Nov 2021 23:01:49 +0800</pubDate><guid>https://blog.smallten.me/p/experience-04/</guid><description>前情提要  由於資工營變成了淨灘活動，然後地點又在基隆的海邊，想說既然都到那麼偏僻的地方了，又剛好跟朋友都有抽到國旅券，那麼就乾脆一起去玩一下吧！
活動簡介 時間：2021/11/20 ~ 2021/11/21 地點：九份、金瓜石 心得 第一天  淨灘後我們就搭著計程車前往瑞芳火車站，到達地點之後，我們在 壯壯權 的帶領下，去吃了許多的小吃，我吃了煎餃（還不錯吃，外皮相當的酥脆），而他們去吃牛肉湯麵，之後又去買了超大杯的飲料，而我點了仙草鮮奶茶（仙草茶 + 鮮奶的概念）&amp;hellip;之後就走去搭公車前往九份的民宿了，但在這途中還看到了一間建築奇妙的圖書館（新北市立圖書館瑞芳分館），他的一樓是一個空曠的區域，而不直接是門口&amp;hellip;
 民宿的部分我們是住在 琚九屋民宿，原因不外乎就是當初訂的時候看起來還不錯，然後也不到太貴，外加當日還有空房&amp;hellip;等因素，而實際的情況我個人是覺得也還蠻不錯的就是了。
 放完行李之後，我們去逛了一下老街，還配著漂亮的夜景，吃著芋圓冰，之後回程逛逛時，還買了草仔粿吃，之後便回民宿休息了，畢竟淨灘後大家也都蠻累的了。（雖然，半夜還跟饅頭頭去 7-11 買了宵夜來吃，哈哈）
第二天  一早起床後，去找 壯壯權 時，才發現他竟然已經叫了外送的早餐吃了，還說這裡山上都沒有店家，還是從山下叫上來的，😂😂，之後退完房間，我們去老街找早午餐吃，途中 饅頭頭（大胖胖） 還買了一份油蔥粿吃，吃飽喝足且看完風景後，我們就出發前往 黃金博物館，這裡我們除了逛逛外，還買了淘金體驗券，玩了一把金沙呢！
 離開博物館之後，在 壯壯權 的帶領下，去吃了份蠻不錯的炒飯後，還去爬了一下山路，途中經過了 壯壯權 的母校（監獄）時雨高中，還經過了 祈堂老街 ，最終到了 金瓜石勸濟堂 搭公車回去瑞芳火車站，而搭台鐵回到北車後，饅頭頭 又不受控的轉了扭蛋，哈哈。
後記  隔天禮拜一的下午竟然要考 資料結構 的期中考，我們完全的裸考，哈哈，還好考完的結果沒有爆掉，可喜可賀呀！😄😄
 最後依然要感謝這群願意陪我瘋、陪我玩的朋朋們。
照片牆</description></item><item><title>初階服務學習 - 淨灘</title><link>https://blog.smallten.me/p/experience-03/</link><pubDate>Sun, 21 Nov 2021 23:01:49 +0800</pubDate><guid>https://blog.smallten.me/p/experience-03/</guid><description>前情提要  因為在 5 月時疫情大爆發，然後臺灣也隨之進入了三級警戒的情況，所以暑假的資工營就因此而被取消舉辦了。
 後來為了讓我們弄到一半的初階服務學習課程能繼續完成並拿到學分，因此最後變成了淨灘的活動。
活動簡介 第一次淨灘 時間：2021/10/24 (日) 地點：基隆大武崙澳底沙灘 第二次淨灘 時間：2021/11/20 (六) 地點：基隆和平島公園 心得 第一次淨灘  因為地點在基隆海邊的緣故，所以就得特別的早就起床，然而一早起床後，就看到外面下著暴雨，因此心情就有那麼一點不美麗&amp;hellip;當然也就少不了抱怨就是了。
 然後輾轉了公車以及捷運，來到了臺北車站吃早餐，先去陪同學去全家買了輕便雨衣，然後我也順便買了杯咖啡，後來去便去麥當當吃了早餐，可惜地點不方便的緣故，就沒吃我最愛的鬆餅了 😢😢
 接著我們便搭火車前往基隆火車站，到站後因為人生地不熟的緣故，還在雨中找了公車站牌找了好一陣子，之後又因為不確定公車的方向與班次，還去問了遊客服務中心，好在於服務中心的人員熱情的協助之下，我們順利的抵達了活動地點。
 只是因為時間還有些早的緣故，我們便在旁邊的熱炒店吃了一下午餐，雖然我大部分的海產類都沒有很愛吃就是了，顆顆；後來因為沙灘大部分的垃圾都已被處理過了的緣故，所以我們就用手撿了剩餘細小的塑膠碎片，這部分當下是真的有被震撼到就是了。
 淨灘結束後的回程，我們先是爬了好一段山路才到公車站牌，其中看到了小小的瀑布或噴泉??(好啦，其實是下大雨然後山壁的流水而已啦)途中也看到了路邊有著大大小小的落石，感覺蠻危險的(怕///)，之後到了公車站牌，我們便去看路線的方向，而當我們看半天時，有一位好心的大媽就直接告訴我們是在對面，然後到了對面，又準備看路線圖時，有一位大爺，直接告訴我們來的這班車就是了，因此我們也順利的回到了北車，之後還順路逛了一下地下街才回學校。
 補充：這一整天穿著一雙濕球鞋，還好回去沒有得香港腳，但也踩了濕濕的襪子走了不少的路，回去腳底整個痛爆 😢😢
第二次淨灘  這一次也是跟上一次差不多的過程前往了基隆的和平島公園，唯一的不同就是沒有一早就下雨，這點對心情的影響真的蠻大的 😄😄。之後在等待集合的過程中，在附近走走逛逛，還看到了超大艘的貨輪出海，嘿嘿。
 然後，這次淨灘地過程還蠻歡樂的，但也撿了不少保麗龍、浮標、以及寶特瓶之類的物品，而且還撿到了不知誰用過的假 X (算是一種玩具?)，這些東西真的不要再亂丟了呀，唉&amp;hellip;
 結束的時候也剛好開始下雨，便在雨中拍了一下附近美麗的風景後，我們就用手機叫計程車前往下一個行程了&amp;hellip;詳情可以查看 九份、金瓜石二日遊
後記  其實說實話一開始準備幾乎都完成的資工營被取消變成淨灘活動時，心裡是有那麼一點不開心的，但是後來在經歷淨灘以及相關的課程後，我是覺得蠻棒的，畢竟不只對我們周遭的環境盡了一部分的心力外，也學習到了不少環保的相關知識。
 最後也要感謝這一次陪我一起行動的 饅頭頭 和 壯壯權，以及途中給予我們許多幫助的人們，再次感謝還好有你們!!</description></item><item><title>2021 NCPC 初賽</title><link>https://blog.smallten.me/p/experience-02/</link><pubDate>Mon, 04 Oct 2021 09:15:29 +0800</pubDate><guid>https://blog.smallten.me/p/experience-02/</guid><description>競賽簡介 NCPC 初賽日期：2021/10/02 成績 校內：7 / 12 全體：26 / 166 心得文 這段時間真的有點忙過頭了
安排 CTF 讀書會的課表（嘿嘿，還去跟 L紀 教授要到了一堂課，希望到時他不會有突發的事情，而是能正常的出席講課），也跟學長一起參加了社團幹部培訓的研習。 協助以前的高中辦理了學科能力競賽的校內初賽，不只從報名簡章到表單，還有競賽的平台以及題目，這裡要特別的感謝一起陪我瘋狂的朋朋 蘇子權，但不得不說，學弟們還得多多加油呀，有機會、時間的話再回去辦研習課程吧！ 我要小小的抱怨一下，學校的選課系統 到底要多久才有機會看到它更新？(有時間去弄那一點都不友善的手機版，不如去重構整個系統。) 不要再人工分流了，很智障。 好好做防 Bot 不行嗎？用那讓人很無言的驗證碼設計，整個傻眼。（打英文還會比打數字的多打幾個字） 系統分發的部份，到底為什麼要那麼久才公佈，又不是用上古年代的電腦，有內幕嗎？（求八卦 二階選課以前是不是直接搶課的呀，教程一階生，最高能選 6 學分，但用志願分發的，但志願只能填到 6 學分，這樣根本分不到呀，傻眼～～ 最重要的是，我第一個選課，比我晚搶課的同學都一一搶到（他們在不同的 server 上，就智障的人工分流問題），我卻只能看你寫登記中，然後慢慢等，直到最後跟我說滿額，是想怎樣啦 😡😡 ，但感謝身旁的朋朋們願意跟我一起去修早八的課程（把大學念到變高中）。 我真的變學分孤兒了😭😭 終於搶到疫苗了，但週日回臺南，禮拜一打疫苗，禮拜三一退燒就又重回北部，週六又打 NCPC 的初賽，整個瘋了～～ 終於要來認真打該有的心得文了，這次的競賽我們隊伍終於好不容易組成了（文元原本因為身心狀態問題沒有要打了），但到比賽的前一天，我們的子權朋朋卻腸胃炎(尷尬)，而文元本來就是被我們抓來一起玩的而已(畢竟他依然得吃葡萄口味的曼陀珠？)，而我前一晚也想到一堆不想去想的東西，也沒睡到特別好&amp;hellip;唉，整個發芬（文元語，咦？
好啦，雖然這次又跟 NCPC 的決賽擦身而過，我是不是真的有萬年老二的命呀？（初賽校內取到第六名），但是這一次的競賽是真的打的非常的開心（賽前測機部份、沒有印表機以及點心除外），水題我依舊是穩穩的 1 try 就解掉費時也不長，其中有一題文元提出模運算，我想到如何搭配前綴和使用，就 AC 了，撒花（但有些隊伍有寫過一樣的題目了，所以非常的早就解出來了 QAQ)，有一題我的想法是對的了，但子權刻後半的部份時一個迴圈寫錯了，最後也有除錯除出來，棒棒的～～（這次有看的所有題目都有好好的解出來呢！）
整體來說，這次競賽讓我享受到了不只有緊張的氣氛，還有團隊解出題時的愉悅，所以雖然沒有進決賽一樣很可惜，但我們志在參與嘛（弱者的發言😭😭），不久後的 TOPC 也得繼續加油呢！</description></item><item><title>StarCoder2021暑訓：Week06</title><link>https://blog.smallten.me/p/star_coder-07/</link><pubDate>Wed, 18 Aug 2021 16:02:47 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-07/</guid><description>主題 最短路徑 最短路徑模板 Dijkstra’s 不能有負邊 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int vn; // vertex num struct Edge { int w, idx; bool operator &amp;lt; (const Edge &amp;amp;r) const { return w &amp;gt; r.w; } }; vector&amp;lt;Edge&amp;gt; adj[maxv]; void dijkstra(int s) { vector&amp;lt;bool&amp;gt; vis(vn, false); vector&amp;lt;int&amp;gt; dist(vn, INF); dist[s] = 0; priority_queue&amp;lt;Edge&amp;gt; pq; pq.</description></item><item><title>Arch Linux-04：基本軟體安裝</title><link>https://blog.smallten.me/p/arch_linux-04/</link><pubDate>Wed, 11 Aug 2021 22:18:09 +0800</pubDate><guid>https://blog.smallten.me/p/arch_linux-04/</guid><description>前言  有了桌面環境，軟體也不可以缺少吧，因此這裡會紀錄一下用到的軟體的安裝方式
教學開始 Yay Yay 的 Github 1 2 3 4 pacman -S --needed base-devel git go git clone https://aur.archlinux.org/yay.git cd yay makepkg -si 中文輸入法 中文輸入法 Wiki 這邊我選擇了之前在 Ubuntu 用習慣的 ibus (IBus (简体中文) Wiki) 安裝注音輸入法：pacman -S ibus ibus-chewing vim /etc/environment 1 2 3 GTK_IM_MODULE=ibus QT_IM_MODULE=ibus XMODIFIERS=@im=ibus vim ~/.xprofile 1 2 3 4 export CTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -drxR 重新啟動 Oh My Zsh Oh My Zsh 的 官網、Github 安裝 zsh：pacman -S zsh 看系統是否裝了 zsh：cat /etc/shells 切換 Shell 為 zsh：chsh -s /bin/zsh 安裝 Git 以及 Curl：pacman -S git curl 安裝 oh-my-zsh：sh -c &amp;quot;$(curl -fsSL https://raw.</description></item><item><title>Arch Linux-03：KDE</title><link>https://blog.smallten.me/p/arch_linux-03/</link><pubDate>Wed, 11 Aug 2021 21:55:25 +0800</pubDate><guid>https://blog.smallten.me/p/arch_linux-03/</guid><description>前言  在安裝完了系統，也設定了基本配置後，想當然爾，該來安裝一個桌面環境了吧，因此接下來將告訴你怎麼安裝 KDE。
教學開始 基本安裝 安裝 KDE Arch Linux 的 meta package 與 package group 安裝 Plasma：pacman -S plasma-meta 安裝 KDE applications：pacman -S kde-applications 安裝顯示管理器 這邊我們將使用 SDDM：pacman -S sddm 設定自動啟動：systemctl enable sddm.service 安裝終端模擬器 這邊我們使用 konsole：pacman -S konsole 喜歡 kitty 的也可安裝：pacman -S kitty 安裝文件管理器 這邊我們使用 Dolphin：pacman -S dolphin 一些基本軟體 中文字體：pacman -S adobe-source-han-sans-tw-fonts 重新啟動：reboot KDE 美化 切換系統語言 系統設定 -&amp;gt; 區域設定 -&amp;gt; 語言 -&amp;gt; 增加語言&amp;hellip; -&amp;gt; 繁體中文 -&amp;gt; 設為預設 -&amp;gt; 套用 Formats -&amp;gt; 區域 -&amp;gt; 選擇 台灣 - 繁體中文 (zh_TW) 調整顯示設定 系統設定 -&amp;gt; 顯示與螢幕 -&amp;gt; 顯示設定 -&amp;gt; 全域縮放比例 -&amp;gt; 125% 組合器 -&amp;gt; 縮放方式：平滑 成像後端介面：OpenGL 3.</description></item><item><title>Arch Linux-02：基本設置</title><link>https://blog.smallten.me/p/arch_linux-02/</link><pubDate>Wed, 11 Aug 2021 17:26:15 +0800</pubDate><guid>https://blog.smallten.me/p/arch_linux-02/</guid><description>前言  在 Arch Linux-01：系統安裝 中，已經介紹了如何完整的安裝一個基礎的 Arch Linux 系統，而這部分將去介紹一些基本的設定或是驅動的安裝。
教學開始 新增使用者 由於不應該一直使用 root 帳號，因此我們來新增一個使用者吧。 新增使用者：useradd -m &amp;lt;user&amp;gt; ( &amp;lt;user&amp;gt; 為你要新增的用戶名稱，請自行更改 ) 設置密碼：passwd &amp;lt;user&amp;gt; Sudo Sudo Wiki 安裝：pacman -S sudo 將使用者加入：usermod -aG wheel &amp;lt;user&amp;gt; 使用 visudo 由於預設使用 vi，但我們之前是用安裝 vim，因此臨時的更改它吧：EDITOR=vim visudo 進去後，找到 %wheel ALL=(ALL) ALL 這行，然後消掉註解並且儲存離開。 Xorg Xorg Wiki 安裝 ：pacman -S xorg-server 驅動安裝 查看顯卡類型：lspci -v | grep -A1 -e VGA -e 3D 安裝對應驅動，請依照情況自行更改 以下為我的筆電的安裝方式 (參考至此文章) 開啟 multilib 倉庫：vim /etc/pacman.</description></item><item><title>Arch Linux-01：系統安裝</title><link>https://blog.smallten.me/p/arch_linux-01/</link><pubDate>Wed, 11 Aug 2021 13:50:32 +0800</pubDate><guid>https://blog.smallten.me/p/arch_linux-01/</guid><description>前言  在被吳文元朋朋洗腦、推坑、直銷 Arch Linux 的各種好之後，我終於也入坑了，而這一系列將紀錄整個的安裝過程，避免未來再踩一次坑。
安裝設備 筆電：Zenbook 14 UX433FN 顯卡： GPU0 Intel UHD 620 GPU1 Nvidia MX150 開始安裝 完整官方導覽：Installation guide 前置作業 製作開機碟 到 Arch Linux Download 下載映像檔 (.iso) NCHC、NCTU 使用 Rufus 寫入隨身碟 壓縮磁碟區 由於我要在一塊已有 Windows 10 的硬碟上安裝 Arch linux，因此得來切磁區。
在 Windows 10 中開啟硬碟管理員 以壓縮磁碟區的方式創造出未分配的空間。 安裝系統 插上隨身碟，並以隨身碟開機 檢查硬碟、分配磁區 由於新手上路，這邊我們就分配單一磁區給 / 就好。 至於其他像是 [SWAP] 之類的，有需要就自行處理。</description></item><item><title>StarCoder2021暑訓：Week05</title><link>https://blog.smallten.me/p/star_coder-06/</link><pubDate>Tue, 10 Aug 2021 23:50:17 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-06/</guid><description>主題 最小生成樹 MST 模板 Kruskal&amp;rsquo;s Algorithm 時間複雜度 O(ElogE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;r) const { return w &amp;lt; r.w; } }; int vn, en; // vertex num, edge num vector&amp;lt;edge&amp;gt; ve; vector&amp;lt;int&amp;gt; dsu; int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } bool Union(int x, int y) { int a = Find(x), b = Find(y); if(a !</description></item><item><title>StarCoder2021暑訓：Week04</title><link>https://blog.smallten.me/p/star_coder-05/</link><pubDate>Fri, 06 Aug 2021 10:42:11 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-05/</guid><description>主題 動態規劃 經典背包模板 0/1 背包 &amp;amp; 無限背包 1 2 3 4 5 6 7 8 9 10 const int N = 100, W = 100000; int cost[N], weight[N], c[W + 1]; void knapsack(int n, int w) { memset(c, 0, sizeof(c)); for (int i = 0; i &amp;lt; n; ++i) for (int j = w; j - weight[i] &amp;gt;= 0; --j) // 0/1 背包 // for (int j = weight[i]; j &amp;lt;= w; ++j) 無限背包 c[j] = max(c[j], c[j - weight[i]] + cost[i]); cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; } 有限背包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const int N = 100, W = 100000; int cost[N], weight[N], number[N], c[W + 1]; void knapsack(int n, int w) { for (int i = 0; i &amp;lt; n; ++i) { int num = min(number[i], w / weight[i]); for (int k = 1; num &amp;gt; 0; k *= 2) { if (k &amp;gt; num) k = num; num -= k; for (int j = w; j &amp;gt;= weight[i] * k; --j) c[j] = max(c[j], c[j - weight[i] * k] + cost[i] * k); } } cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; } 經典零錢問題模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int price[5] = {5, 2, 6, 11, 17}; bool c[1000+1]; //int c[1000+1]; void change(int m) { memset(c, false, sizeof(c)); c[0] = true; for (int i = 0; i &amp;lt; 5; ++i) for (int j = price[i]; j &amp;lt;= m; ++j) c[j] ||= c[j-price[i]]; // c[j] += c[j-price[i]]; if (c[m]) cout &amp;lt;&amp;lt; &amp;#34;湊得到&amp;#34;; else cout &amp;lt;&amp;lt; &amp;#34;湊不到&amp;#34;; // cout &amp;lt;&amp;lt; &amp;#34;湊得價位&amp;#34; &amp;lt;&amp;lt; m; // cout &amp;lt;&amp;lt; &amp;#34;湊法總共&amp;#34; &amp;lt;&amp;lt; c[m] &amp;lt;&amp;lt; &amp;#34;種&amp;#34;; } LIS 模板 DP 1 2 3 4 5 6 7 8 9 10 11 12 const int N = 100; int s[N], length[N]; int LIS() { for (int i=0; i&amp;lt;N; i++) length[i] = 1; for (int i=0; i&amp;lt;N; i++) for (int j=0; j&amp;lt;i; j++) if (s[j] &amp;lt; s[i]) length[i] = max(length[i], length[j] + 1); int l = 0; for (int i=0; i&amp;lt;N; i++) l = max(l, length[i]); return l; } Robinson-Schensted-Knuth Algorithm 時間複雜度 O(NlogL) ， N 是序列長度， L 是 LIS 長度。 1 2 3 4 5 6 7 8 9 10 11 int LIS(vector&amp;lt;int&amp;gt;&amp;amp; s) { if (s.</description></item><item><title>StarCoder2021暑訓：Week03</title><link>https://blog.smallten.me/p/star_coder-04/</link><pubDate>Wed, 28 Jul 2021 05:48:25 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-04/</guid><description>主題 圖、狀態搜尋、拓樸排序、尤拉路 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用演算法 基本題 UVa 10004 無向圖的兩色著色問題 DFS/BFS 均可 V UVa 10959 求無向無權圖上每一點和一指定點的最短距離 BFS V UVa 572 求二維地圖上的連通塊數量 DFS/BFS 均可 V UVa 441 給定 k 個數，由小到大列出所有包含其中 6 個數的遞增數列 DFS UVa 567 求無向無權圖上指定兩點間的最短距離 BFS (或用後面會學到的 Floyd-Warshall 演算法) V UVa 10926 給有向無環圖，求最大一棵樹的節點數減1 DFS/BFS 均可 SPOJ PT07Z 求數直徑（經典題） DFS/BFS 均可 UVa 10603 倒水問題（給三個水瓶，倒出指定水量） BFS 變型 (帶權最短路) UVa 10305 給定 n 個工作的兩兩先後關係，輸出任一個合法的工作完成順序。 拓樸排序 V UVa 1423 給定一數列中 Sij = a[i]+…+a[j] 的正負號，輸出一組符合正負號關係的數列。(有趣，值得思考！) 拓樸排序 UVa 302 給定一個無向圖和指定起點，列印尤拉路。 尤拉路 UVa 10441 給定一堆字串，問如何將它們頭尾相連串起來。 尤拉路 參考作法 A - Bicoloring 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &amp;lt;bits/stdc++.</description></item><item><title>PlayStation Vita-03：NoPayStation Browser</title><link>https://blog.smallten.me/p/psv-03/</link><pubDate>Mon, 26 Jul 2021 11:50:17 +0800</pubDate><guid>https://blog.smallten.me/p/psv-03/</guid><description>下載 NPS Clients，並放到一個資料夾中。 下載 pkg2Zip，並將 pkg2zip.exe 放到同一個資料夾中。 執行 NPS_Browser.exe。 複製以下連結： Games PSV tsv http://nopaystation.com/tsv/PSV_GAMES.tsv PSM tsv http://nopaystation.com/tsv/PSM_GAMES.tsv PSX tsv http://nopaystation.com/tsv/PSX_GAMES.tsv PSP tsv http://nopaystation.com/tsv/PSP_GAMES.tsv PS3 tsv http://nopaystation.com/tsv/PS3_GAMES.tsv DLCs: PSV tsv http://nopaystation.com/tsv/PSV_DLCS.tsv PSP tsv http://nopaystation.com/tsv/PSP_DLCS.tsv PS3 tsv http://nopaystation.com/tsv/PS3_DLCS.tsv Themes: PSV tsv http://nopaystation.com/tsv/PSV_THEMES.tsv 設定 Download and unpack dir: 檔案下載後的位置。 設定 Any pkg dec tool: 路徑為 pkg2Zip.exe 的位置。 設定 Your pkg dec params: -x {pkgFile} &amp;quot;{zRifKey}&amp;quot;。 設定 HMAC key for updates: E5E278AA1EE34082A088279C83F9BBC806821C52F2AB5D2B4ABD995450355114。 設定 CompPack URL: https://gitlab.</description></item><item><title>PlayStation Vita-02：NoNpDrm</title><link>https://blog.smallten.me/p/psv-02/</link><pubDate>Mon, 26 Jul 2021 11:46:32 +0800</pubDate><guid>https://blog.smallten.me/p/psv-02/</guid><description> 在 PSV 執行 Vita Shell，然後按一下 Select 按鈕，最後以 USB 連接 PC。 下載 NoNpDrm，並將 nonpdrm.skprx 放進 tai 資料夾中。 回到 PSV 的 Vita Shell 中，並到達 ux0:tai/，選擇 config.txt。 找到並移到 *KERNEL 那行，按一下三角形按鈕，選 Insert empty line。 選擇下方新增的空白行，並輸入 ux0:tai/nonpdrm.skprx，然後儲存離開。 到設定中的 HENkaku 設置，選擇 重載 taiHEN config.txt。 重新啟動 PSV。</description></item><item><title>PlayStation Vita-01：H-encore 2</title><link>https://blog.smallten.me/p/psv-01/</link><pubDate>Mon, 26 Jul 2021 11:04:05 +0800</pubDate><guid>https://blog.smallten.me/p/psv-01/</guid><description> 下載 Qcma 並安裝到電腦上。 PSV 以 USB 的方式連接到 PC。 下載 Final h-encore，然後將其解壓縮，最後執行它。 點擊 Let&amp;rsquo;s Go ，然後等到 100% 完成。 回到 PSV 的檔案管理 (Content Manager)，然後選擇複製內容(Copy Content) PC to PSV，之後 Applications &amp;gt; PS Vita，最後選 h-encore 2 再按 複製(Copy) &amp;gt; OK。 拔掉 USB，執行 PSV 桌面上的 h-encore 2。 PSV 記得要連網，然後選 Install HENkaku &amp;gt; Download VitaShell &amp;gt; Exit 到設定確認系統資訊，確認成功後，再去設定 HENkaku。 之後若有重開機的話，得重新進入 h-encore 2 再離開即可。</description></item><item><title>StarCoder2021暑訓：Week02</title><link>https://blog.smallten.me/p/star_coder-03/</link><pubDate>Sat, 24 Jul 2021 08:26:57 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-03/</guid><description>主題 STL、併查集 併查集模板 1 2 3 4 5 6 7 8 9 10 11 12 13 int dsu[MAX_N]; void init(int num) { for(int i = 0; i &amp;lt;= num; ++i) dsu[i] = i; } int Find(int x) { if(x == dsu[x]) return x; return dsu[x] = Find(dsu[x]); } void Union(int x, int y) { int a = Find(x), b = Find(y); if(a != b) dsu[a] = b; } 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用結構 優先練習 UVa 673 括號匹配與 LIFO 操作 std::stack v UVa 442 括號匹配與 LIFO 操作 std::stack UVa 12100 遍歷和 FIFO 操作 std::queue (加上 std::priority_queue 效率更高) v UVa 245 取出第 n 個以及插入頭端 std::list / std::deque / std::vector UVa 1203 插入與取出最小值 std::priority_queue v UVa 11995 模擬 stack, queue, priority_queue std::stack, std::queue, std::priority_queue v UVa 10583 標準併查集操作 disjoint set v UVa 11987 併查集的變化題(值得思考) disjoint set UVa 1665 判斷連通塊數 disjoint set UVa 230 字串排序與搜尋 std::map / std::set v UVa 1592 字串比較（將字串轉成數值以加快比較） std::map 參考作法 A - Parentheses Balance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &amp;lt;bits/stdc++.</description></item><item><title>2021 R2S CTF</title><link>https://blog.smallten.me/p/experience-01/</link><pubDate>Mon, 19 Jul 2021 14:03:54 +0800</pubDate><guid>https://blog.smallten.me/p/experience-01/</guid><description>前情提要  一開始時，學長們在 Messenger 的群組裡問有沒有人要參加這場新手向的 CTF 競賽，我是沒有選擇參加的 (因為我從來沒有深入的去玩、學習這方面的東東，可以算是個純正的小萌新~~)，然而到最後因為人數的關係學長們組成了兩隊，然後還能再多 2 個人，因此我也加入想說去見見世面也好。(其中還得感謝學長們的鼓勵，以及願意帶我這個什麼都不會的新手)😆😆
競賽簡介 R2S CTF 競賽網站 Online Qualification : 7/16 - 18 Flag 樣式：R2S{} 成績 All: 7 / 81 Offical Only: 4 / 43 解題紀錄 以下是我解的題目，其他題目我無能為力，就只能看有沒有學長寫題解了(顆顆 Welcome Welcome to R2S CTF o((&amp;gt;ω&amp;lt; ))o 在 R2S Discord 群組中的 challenge-announcement 頻道中，有黑黑的訊息要點開就能到 Flag 了。 一開始覺得很酷，事後知道了這叫暴雷標籤 ||暴雷訊息||。 Forensics Headache 這題依照 CRC32 找出圖片的長寬，並用 hex editor 把 png 的 header 改成正確的就行了。 Crypto Base1024 這題將那堆 emoji 解碼後就得到 Flag 了。 ecoji、ecoji 線上工具 BiGGG_RSA 一開始不知道怎麼分解 N，對於 Factordb 來說也太大了，解不出來。之後到了這個 primefac-fork，再寫個簡單的程式就解決了。 Seeeeed 也是 RSA 相關題。 Misc Time Traveler nc time-traveler.</description></item><item><title>StarCoder2021暑訓：Week01</title><link>https://blog.smallten.me/p/star_coder-02/</link><pubDate>Thu, 15 Jul 2021 00:07:54 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-02/</guid><description>主題 搜尋、排序、貪心 題目 Virtual Judge 參考作法 A - Flip Sort 題目說明： 給一堆數字，輸出要交換(只能相鄰交換)多少次，才能由小到大排好。 解題思路： Bubble sort 程式碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int n, a[1005]; while(cin &amp;gt;&amp;gt; n) { int ans = 0; for(int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; a[i]; for(int i = 0; i &amp;lt; n; ++i) { for(int j = n - 1; j &amp;gt; i; --j) { if(a[j] &amp;lt; a[j - 1]) { swap(a[j], a[j - 1]); ++ans; } } } cout &amp;lt;&amp;lt; &amp;#34;Minimum exchange operations : &amp;#34; &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } return 0; } B - Age Sort 題目說明： 給一堆數字，由小到大排序。 解題思路： std::sort() 小心 Presentation error 程式碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓</title><link>https://blog.smallten.me/p/star_coder-01/</link><pubDate>Wed, 14 Jul 2021 22:52:11 +0800</pubDate><guid>https://blog.smallten.me/p/star_coder-01/</guid><description>簡介 週次 主題 題目 一 搜尋、排序、貪心 Link 二 STL、併查集 Link 三 圖、狀態搜尋、拓樸排序、尤拉路 Link 四 動態規劃 Link 五 最小生成樹 Link 六 最短路徑 Link 學習資源 第一週 - 搜尋、排序、貪心 線上教材 教材 說明 師大碼賽客：排序/貪心/二分搜 子緯學長的教學講義（詳盡的新手入門） 北一女培訓：排序 六種排序法的程式與簡介 建中培訓 (第4/6/7節) 4.排序STL/6.貪心/7.二分搜 台大資訊之芽：貪心 貪心法與理論/Huffman Tree 成大競程培訓 (單元5/6) 5.</description></item><item><title>程式設計(二)-08：Linux List</title><link>https://blog.smallten.me/p/computer_programming_2-08/</link><pubDate>Tue, 13 Jul 2021 22:25:50 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-08/</guid><description>linuxlist.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #pragma once struct list_head { struct list_head *next, *prev; }; #define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) } #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) /* * Insert a new entry between two known consecutive entries.</description></item><item><title>程式設計(二)-07：Some Tricks</title><link>https://blog.smallten.me/p/computer_programming_2-07/</link><pubDate>Tue, 13 Jul 2021 21:39:10 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-07/</guid><description>Predefined Macros Standard Predefined Macros 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &amp;lt;stdio.h&amp;gt;int main() { printf(&amp;#34;line: %d \n&amp;#34;, __LINE__); printf(&amp;#34;file: %s \n&amp;#34;, __FILE__); printf(&amp;#34;function: %s \n&amp;#34;, __FUNCTION__); // gcc printf(&amp;#34;function: %s \n&amp;#34;, __func__); // C99 printf(&amp;#34;time: %s \n&amp;#34;, __TIME__); printf(&amp;#34;date: %s \n&amp;#34;, __DATE__); printf(&amp;#34;STDC: %d \n&amp;#34;, __STDC__); printf(&amp;#34;STDC_VERSION: %ld \n&amp;#34;, __STDC_VERSION__); printf(&amp;#34;TIMESTAMP: %s \n&amp;#34;, __TIMESTAMP__); return 0; } 我們可以怎麼使用這些 Macros ?</description></item><item><title>程式設計(二)-06：Macro</title><link>https://blog.smallten.me/p/computer_programming_2-06/</link><pubDate>Tue, 13 Jul 2021 20:47:06 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-06/</guid><description>Preprocessor 預處理器 在編譯器將您的源代碼編譯為組語前，還有一個稱為預處理的附加階段。 Objective: Produce a source code file with preprocessing commands properly sorted out. Preprocessor commands are known as Directives. Preprocessor provides certain features, which are called preprocessor directives. Preprocessor directive 以 # 為開頭。(例如：#include &amp;lt;stdio.h&amp;gt;) Preprocessor directives 可以被放在程式中的任何地方。但建議放在開頭，並且每個必須獨立一行。 1 2 3 4 5 6 #include &amp;lt;stdio.h&amp;gt;#define MACRO_DEMO 123 int main() { printf(&amp;#34;demo:␣%d\n&amp;#34;, MACRO_DEMO); return 0; } 以 gcc -E main.c 查看預處理後的狀態。 Macro 巨集 #define is known as macro expansion.</description></item><item><title>程式設計(二)-05：Variable Length Arguments List</title><link>https://blog.smallten.me/p/computer_programming_2-05/</link><pubDate>Mon, 12 Jul 2021 21:57:26 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-05/</guid><description>Program Argument argc, argv 1 2 3 4 5 6 7 8 9 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;int main(int argc, char *argv[]) { printf(&amp;#34;argc: %d\n&amp;#34;, argc); for(int32_t i = 0 ; i &amp;lt; argc ; i++) printf(&amp;#34;argv[%d]: %s\n&amp;#34;, i, argv[i]); return 0; } 誰呼叫了 main 函式? 誰提供了 argc 和 argv 到 main 函式? Is main() the actual starting entry point? No! Actually, the process start from _start which is defined in crt1.</description></item><item><title>程式設計(二)-04：File Processing-02</title><link>https://blog.smallten.me/p/computer_programming_2-04/</link><pubDate>Sat, 08 May 2021 17:23:11 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-04/</guid><description>如何顯示 BMP 檔 ? 有很多 libraries 可以幫助您做到這一點。實際上，您應該使用它們而不是從頭開始開發。 如何在螢幕上顯示圖像？ 您必須至少學習一個 GUI 庫，例如 Gtk、Qt 等。 我的建議：Qt。但是，這是一個 C++ 框架。 了解如何使用 GUI 平台提供的功能顯示圖像。 GTK GTK（以前稱為 GTK+、GIMP ToolKit）是一個免費的開源跨平台的部件工具箱 (widget toolkit)，用於創建圖形用戶界面（GUIs）。 GTK 是用 C 語言所編寫的物件導向的部件工具箱。它使用 GObject（即 GLib 物件系統）進行物件導向。 因此，不要告訴我 C 不能物件導向。 安裝：sudo apt install libgtk-3-dev SDL Simple DirectMedia Layer SDL是跨平台的軟件開發庫，為計算機多媒體硬件組件提供硬件抽象層。 視頻 聲音的 輸入設備 光盤 螺紋 共享對象加載 聯網 計時器 3D圖形 軟體開發者可以使用它來編寫高性能的電腦遊戲和其他多媒體應用程式。 SDL 架構 / 範例 SDL Object SDL_Window：包含有關 Window 本身的所有信息的結構：大小、位置、全螢幕、邊框等。 SDL_Renderer：處理所有渲染的結構。它與 SDL_Window 綁定在一起，因此只能在該 SDL_Window 中呈現。 SDL_Textures 和 SDL_Surface：SDL_Renderer 渲染SDL_Texture(存儲一個元素的像素資訊)。這是 SDL_Surface 的新版本，他們幾乎相同。 重要的區別是 SDL_Surface 使用軟件渲染（通過CPU），而 SDL_Texture 使用硬件渲染（通過GPU）。 安裝：sudo apt-get install libsdl2-dev libsdl2-image-dev Makefile 1 2 3 4 5 CFLAGS := `sdl2-config --libs --cflags` -ggdb3 -O0 --std=c99 -Wall -lSDL2_image -lm all: example.</description></item><item><title>程式設計(二)-03：File Processing-01</title><link>https://blog.smallten.me/p/computer_programming_2-03/</link><pubDate>Fri, 02 Apr 2021 17:58:22 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-03/</guid><description>File C 將每個檔案視為一個連續的 bytes stream 每個檔案以 end-of-file 為結尾，這是由系統提供而不是文件。 It looks like there is an additional byte appended to the file. However, that additional byte does not exist. Instead, it is a signal raised by your system. int feof(FILE *stream); File Stream Streams 提供了更高級別的介面(interface)讓你存取資料。 fprintf fscanf 事實上，你已經使用過 file stream ! 三種標準流 標準輸入 0 (standard input.) 標準輸出 1 (standard output.) 標準錯誤 2 (standard error.</description></item><item><title>程式設計(二)-02：Structure</title><link>https://blog.smallten.me/p/computer_programming_2-02/</link><pubDate>Fri, 02 Apr 2021 16:24:46 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-02/</guid><description>Structure Structures 就是將一堆相關的變數整合在一個名字下。 關鍵字：struct 資料型別：struct _name_ 成員：在 struct 的大括號內宣告的變數。 同一個結構體下的成員名稱是唯一的。 1 2 3 struct _sCard{ uint8_t suit, face; }; 初始化 1 2 struct _sCard a_card = {.suit = 1, .face = 2}; struct _sCard a_card = {1, 2}; structure member operator -&amp;gt; . structure pointer operator -&amp;gt; -&amp;gt; 1 2 3 4 a_card_ptr = &amp;amp;a_card; a_card_ptr-&amp;gt;face = 5; // Equivalent to (*a_card_ptr).</description></item><item><title>程式設計(二)-01：String</title><link>https://blog.smallten.me/p/computer_programming_2-01/</link><pubDate>Fri, 02 Apr 2021 14:40:30 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_2-01/</guid><description>字元 在講字串之前我們先來看什麼是字元。 ASCII American Standard Code for Information Interchange. 電子通訊的字元編碼標準 基於英文字母，ASCII 將 128 個字元編碼成 7 個位元長。 95 個可印字元：A-Z, a-z, 0-9, 標點符號 不可印字元：換行符號 在電腦中我們使用 8-bit 的記憶體儲存字元。 在 C 語言中，使用 char 這個型別。 %c -&amp;gt; 輸出字元 %x or %X -&amp;gt; 印出 hex or HEX 的值。 在以前，許多情況下，有些人使用 unsigned char 作為 one byte 的資料型別，但現今你應該使用的是 uint8_t。 請把 char 留給字串，盡管事實上對電腦來說都是一樣的。 其他編碼：Big5、UTF-8 字串 事實上，字串就是一連串的可印字元。 這樣看起來很像陣列對吧?</description></item><item><title>Hugo-02：優化 Blog</title><link>https://blog.smallten.me/p/hugo-02/</link><pubDate>Sun, 07 Feb 2021 04:06:17 +0800</pubDate><guid>https://blog.smallten.me/p/hugo-02/</guid><description>簡介 這部份是紀錄我修改的主題內容，並將 codeblocks 區塊美化，以及支援 KaTex 和 Google Analytics 教學開始 我使用的主題為 Stack 主題內容修改 找到 assets/scss/variables.scss，並修改 1 2 --link-background-color: 90, 240, 250; //189, 195, 199; --code-text-color: #ef3982; //rgba(255, 255, 255, 0.9); Codeblocks 區塊美化 Stack 主題已內建，因此不再需要自己建立!! 只需在 config.yaml 設定即可。
到 static/css/ 下建立 copy-to-clipboard.css，內容如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 .</description></item><item><title>Hugo-01：建立一個Hugo Blog</title><link>https://blog.smallten.me/p/hugo-01/</link><pubDate>Sun, 07 Feb 2021 03:22:22 +0800</pubDate><guid>https://blog.smallten.me/p/hugo-01/</guid><description>簡介 這篇內容將快速帶你建立一個 Hugo Blog 並將其部屬到 GitHub 上 相關連結 Hugo - Hugo 官網 Hugo Themes - 選擇自己喜歡的主題 Hugo Releases - 下載 Hugo 並安裝進電腦 教學開始 建立 Hugo Blog 安裝 Hugo 這裡以 Ubuntu 為示範 先至 Hugo Releases 下載自己所需的版本 1 $ dpkg -i hugo_extended_0.79.0_Linux-64bit.deb # 記得依照檔案自行更改 創建一個 Hugo Site 這裡創建一個名為 blog 1 2 $ cd ~ $ hugo new site blog # 可自行修改名稱 新增主題 這裡我選擇了 Stack 這個主題 1 2 3 $ cd ~/blog/ $ git init $ git submodule add https://github.</description></item><item><title>程式設計(一)-08：Pointer</title><link>https://blog.smallten.me/p/computer_programming_1-08/</link><pubDate>Wed, 23 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-08/</guid><description>Pointer 許多人不喜歡C是因為有「指標」 這可能是C中最困難的一個部分 指標是一個變數，其值為記憶體位置 宣告：int32_t *p p 是一個指標 指向的記憶體區塊被視為整數 初始化：int32_t *p = NULL address operator &amp;amp;：返回其變數的記憶體位置 如果想要印出記憶體位置，你可以使用%p indirection operator *：也被稱為dereferencing operator，返回指向對象的值 void *：是一個通用的指標型別(generic pointer type)，可以不透過explicit cast轉換成任意指標的型別 傳參數至函式 在C語言中，argument passing 稱為 call-by-value 電腦將會分配另一個記憶體區塊 複製輸入的參數到記憶體區塊 函式將會在新的記憶體區塊執行 這就是為什麼修改函式中的變數，並不會修改到原本外部的變數了。 在C++有另一種傳送方式稱為 call-by-reference，這邊我們不多加介紹。 普遍來說，傳址會比傳值更快。 陣列與指標 在大部分的情況下，我們可以把array視為第一個元素的指標 現在你應該明白為什麼陣列的值會在函式中被修改 為了避免模棱兩可(搞混)，我較喜歡&amp;amp;(array[0])而不是array、&amp;amp;array 然而你不能寫出 array = &amp;amp;a int32_t int16_t int8_t ptr++ 移動的大小是根據指標的型別 這在要讀取每一byte的詳細資料時非常好用 事實上，array[n] = *(ptr + n) Endian Issue 函式指標 指標不過是一個記憶體位址。 當我們宣告某種類型的指標時，這意味著電腦將將訪問記憶體並根據給定的類型解釋存儲在該位址的值。 您是否知道函式也存儲在記憶體中？ 使用函式指標時，返回的型別和參數應該要和實際的定義相同。 Really?</description></item><item><title>First Hugo Blog</title><link>https://blog.smallten.me/p/first-hugo-blog/</link><pubDate>Fri, 18 Dec 2020 01:16:06 +0800</pubDate><guid>https://blog.smallten.me/p/first-hugo-blog/</guid><description>第一個 Hugo Blog  由於秉持著「人生總折騰」的道理，我來轉移 Blog 了(誤///)，好啦，其實是單純希望有個穩定且又能全天候供應的 Blog 而已，由於我的隊友兩人分別使用了 Hexo 及 Hugo ，因此一開始讓我有點難抉擇，但最終我還是選擇了 Hugo 。
 至於第二個選擇的難關就是主題了，挑了好久都沒看到順眼的，差點就要聽吳文元說的沒有喜歡的就自己寫呀(怕///)，最終還是挑到了一個稍微滿意的主題 Stack。
 至於架設的過程到目前為止還算是蠻順利的，希望之後也不會遇到什麼大坑。</description></item><item><title>演算法-01：蓄水池抽樣法</title><link>https://blog.smallten.me/p/algorithm-01/</link><pubDate>Tue, 08 Dec 2020 16:02:25 +0800</pubDate><guid>https://blog.smallten.me/p/algorithm-01/</guid><description>蓄水池抽樣法 (Reservoir Sampling) 從 N 個樣本中，隨機抽取 K 個樣本，其中 N 非常大(不能將所有數據都放進記憶體或是一個未知數)，而每個被抽出來的機率要相等。 定理 該算法保證每個元素以 \( k \over n \) 的機率被選入蓄水池中。
證明 第 i 個元素進入蓄水池的機率為 \( k \over i \)，蓄水池內每個元素被替換的機率為\( 1 \over k \) 因此在第 i 輪第 j 個元素被替換的機率為 \( {k \over i}\times{1 \over k} = {1 \over i} \)，接下來用 M.I. (數學歸納法)來證明，當 n 次循環結束時每個元素進入蓄水池的機率為 \( k \over n \) 假設在 (i-1) 次迭代後，任意一個元素進入 蓄水池的概率為 \( k \over i-1 \)。由上面的結論，在第 i 次迭代時，該元素被替換的概率為 \( 1 \over i \)， 那麼其不被替換的概率則為 \( 1 - {1 \over i} = {i - 1 \over i} \) 故在第 i 次迭代後，該元素在蓄水池內的概率為 \( {k \over i-1} \times {i-1 \over i} = {k \over i} \)，歸納結束。 因此當循環結束時，每個元素進入蓄水池的概率為 \( k \over n \)，命題得證。 例題 Leetcode 382.</description></item><item><title>程式設計(一)-07：Array</title><link>https://blog.smallten.me/p/computer_programming_1-07/</link><pubDate>Mon, 07 Dec 2020 19:38:14 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-07/</guid><description>Array 陣列是一種可以儲存大量相同型別資料的方法。 連續的記憶體位置。 永遠從0開始 int32_t a[10] -&amp;gt; a[0] ~ a[9] 計數變數 i 的型別可以宣告為 size_t，它是一個無號的整數型別。 初始化 int32_t a[5] = {0, 0, 0, 0, 0}; int32_t a[5] = {0}; 存取陣列元素使用 variable[index] 專業說明：電腦將找到第一個元素的地址，然後根據索引移動記憶體位置以訪問數據。 事實上一維陣列可以處理所有情況，至於多維陣列只是給人類方便閱讀的。 define 是遇處理指令，不是C的詞(statement) 我們可以使用 #define 去做巨集(MACRO) 當開發時MACRO有些像function，然而對電腦而言他們是不同的。 當遇到MACRO，編譯器將簡單的依定義替換掉程式碼。 函式擁有自己的標記。 基本排序 氣泡排序法 1 2 3 4 5 6 7 8 9 for(int i = 0; i &amp;lt; n; ++i) { for(int j = i; j &amp;lt; n; ++j) { if(a[j] &amp;lt; a[i]) { a[i] = a[i] ^ a[j]; a[j] = a[i] ^ a[j]; a[i] = a[i] ^ a[j]; } } } qsort 1 2 3 4 5 #include &amp;lt;stdlib.</description></item><item><title>程式設計(一)-06：Makefile</title><link>https://blog.smallten.me/p/computer_programming_1-06/</link><pubDate>Wed, 02 Dec 2020 21:45:51 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-06/</guid><description>Makefile for 程設一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CC = gcc CFLAGS = -Wall -Wextra -O2 -std=c11 LDFLAGS = -lm TARGETS = main01 main02 main01_OBJ = main01.o func01.o main02_OBJ = main02.o func02.o .PHONY = all clean all: $(TARGETS) .SECONDEXPANSION: $(TARGETS): $$($$@_OBJ) $(CC) $^ -o $@ $(LDFLAGS) %.o: $@.c clean: -$(RM) $(TARGETS) $(foreach targ,$(TARGETS),$(foreach obj, $($(targ)_OBJ), $(obj)))</description></item><item><title>程式設計(一)-05：Function</title><link>https://blog.smallten.me/p/computer_programming_1-05/</link><pubDate>Sat, 21 Nov 2020 21:48:47 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-05/</guid><description>Function 函式 double double 是一種浮點數型別，就像是 float 就如同它的名字，它使用的記憶體大小為 float 的兩倍 建議: 當你需要浮點數的話，一律使用 double 到目前為止我們最常使用到的函式為 printf 我們稱這些函式為 C standard functions (C標準函式) 所有的函式都被儲存在libraries中 如果你想要讀書，你需要知道書在哪，然後去圖書館借書 如果你想要使用函式，你需要知道函式在哪，然後include library去使用函式 例如: stdio.h &amp;lt;-&amp;gt; printf 使用 math.h 時，需下編譯參數 -lm 永不重新發明輪子 在開發前請先搜尋 1 2 3 4 5 6 //原型宣告 Return-Value-Type Function-Name (parameter-Type-list); Return-Value-Type Function-Name (parameter-list){ Statements } 使用原型宣告並將自訂函式置於main function之後的好處? 不用管function之間的先後順序。 void 沒有型別 在這裡，代表不需要回傳值 標頭檔 (Header Files) 甚麼是header file?</description></item><item><title>程式設計(一)-04：Loop</title><link>https://blog.smallten.me/p/computer_programming_1-04/</link><pubDate>Sun, 18 Oct 2020 20:33:18 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-04/</guid><description>Loop - `while` - `for` - `do while` While Loop 1 2 3 while(條件){ 執行區塊 } %.200f 會發生什麼事? -&amp;gt; 精度不夠沒有意義 while(1) -&amp;gt; 無窮迴圈 For Loop 1 2 3 for(初始化; 條件; 執行後操作){ 執行區塊 } i++ -&amp;gt; Use the current value of i. -&amp;gt; i = i + 1 ++i -&amp;gt; i = i + 1 -&amp;gt; Use the new value of i.</description></item><item><title>程式設計(一)-03：Condition Control</title><link>https://blog.smallten.me/p/computer_programming_1-03/</link><pubDate>Thu, 15 Oct 2020 20:53:14 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-03/</guid><description>Condition Control 簡介 我們想要讓電腦去做基礎的判斷 if switch If 1 2 3 4 5 6 7 8 9 if (condition1) { statements; } else if (condition2){ ... } else { ... } 如果條件不是錯誤，那麼將會執行大括號裡的敘述 簡而言之，false 被定義為 0 &amp;gt; -&amp;gt; 大於 &amp;lt; -&amp;gt; 小於 &amp;gt;= -&amp;gt; 大於等於 &amp;lt;= -&amp;gt; 小於等於 == -&amp;gt; 等於 != -&amp;gt; 不等於 &amp;amp;&amp;amp; -&amp;gt; and || -&amp;gt; or Boolean 在 Cpp 裡，有個型別稱為 bool 它只有兩個值：true, false 那麼 bool 使用的記憶體大小為何能?</description></item><item><title>程式設計(一)-02：Arithmetic</title><link>https://blog.smallten.me/p/computer_programming_1-02/</link><pubDate>Thu, 15 Oct 2020 11:19:09 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-02/</guid><description>Arithmetic 1 2 3 4 5 6 7 #include &amp;lt;stdio.h&amp;gt;int main(){ int a = 1, b = 2, sum = 0; sum = a + b; printf(&amp;#34;%d&amp;#34;, sum); return 0; } 變數 每個變數都必須有它的型別 在使用變數前必須先宣告它 在C裡面， = 意思為”指定”，而不是”相等”，指派右邊的數值給左邊的變數 一個好習慣，總是初始化變數 C Spec: C89:If an object that has static storage duration is not initialized explicitly, it is initialized implicitly. C99: If it has arithmetic type, it is initialized to (positive or unsigned) zero.</description></item><item><title>Python-04：多線程-ts下載並合併成mp4</title><link>https://blog.smallten.me/p/python-04/</link><pubDate>Sun, 04 Oct 2020 16:36:35 +0800</pubDate><guid>https://blog.smallten.me/p/python-04/</guid><description>簡介  這篇將帶你下載m3u8檔並分析出ts的檔案，再透過多線程來加速下載，之後再由FFmpeg合併成mp4。
Python 下載m3u8 1 2 3 4 5 6 m3u8Url = &amp;#39;https://.../index.m3u8&amp;#39; def downloadM3u8(url): r = requests.get(url) with open(&amp;#39;./index.m3u8&amp;#39;, &amp;#39;wb&amp;#39;) as f: f.write(r.content) 分析m3u8 這部份請依照你所取得的m3u8檔進行分析，並將完整的ts檔的url放進tsList即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tsList = [] tsCnt = 0 def analyzeM3u8(): tsList.clear() tempUrl = m3u8Url.rsplit(&amp;#39;/&amp;#39;, 1)[0] + &amp;#39;/&amp;#39; with open(&amp;#39;./index.m3u8&amp;#39;, &amp;#39;r&amp;#39;) as f: text = f.</description></item><item><title>Python-03：m3u8影片下載</title><link>https://blog.smallten.me/p/python-03/</link><pubDate>Sun, 04 Oct 2020 11:07:24 +0800</pubDate><guid>https://blog.smallten.me/p/python-03/</guid><description>簡介 現今你時常能在影音媒體網站看到 .m3u8 的檔案，以及許多 .ts 的分段媒體，本篇將教你如何簡單的下載成 .mp4 檔。 這篇並不詳加敘述 HLS 之類的觀念，若有興趣深入了解請自行查找資料。 FFmpeg FFmpeg官網 下載安裝完後，若為 windows 用戶請將 %ffmpeg%\bin 的路徑加入環境變數中，並於terminal中執行 ffmpeg -version 來查看是否成功加入。 下載檔案，直接在 terminal 輸入 ffmpeg -i m3u8URL -c copy filname.mp4，即可完成下載。(下面將提供Python的寫法) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # -*- coding: UTF-8 -*- import ffmpeg_streaming from ffmpeg_streaming import Formats url = &amp;#39;https://.../index.m3u8&amp;#39; filename = &amp;#39;test.mp4&amp;#39; def ffmpeg_download(input_path, output_path): video = ffmpeg_streaming.</description></item><item><title>程式設計(一)-01：Your first program</title><link>https://blog.smallten.me/p/computer_programming_1-01/</link><pubDate>Sun, 04 Oct 2020 11:00:48 +0800</pubDate><guid>https://blog.smallten.me/p/computer_programming_1-01/</guid><description>Hello World 1 2 3 4 5 6 #include &amp;lt;stdio.h&amp;gt;//Your first code. int main(){ printf(&amp;#34;Hello World\n&amp;#34;); return 0; } main是每個C程式的進入點，我們稱它為main function(主函式) int 及 return 是C裡面的Keywords int代表這個函式將會回傳一個整數 每個函式都應該有一個回傳值 每個敘述的結尾都應該要有 ; printf 是一個會顯示格式化字串的函式 \n -&amp;gt; 換行 \t -&amp;gt; tab \\ -&amp;gt; \ \&amp;quot; -&amp;gt; “ # 的那一行是C的預處理器並且不需要;結尾 stdio.h -&amp;gt; standard input / output header(標準輸出/輸入標頭檔) 註解 -&amp;gt; 是給開發者看的 //Your code -&amp;gt; 單行 /*Your code*/ -&amp;gt; 多行 使用編譯器將程式碼編譯成組合語言，再由組譯器組議成機械碼或可執行的二進制檔 IDE -&amp;gt; Integrated Development Environment，不是編譯器 gcc是最受歡迎的C編譯器之一(不完全對!</description></item><item><title>Python-02：多線程-加速圖片下載</title><link>https://blog.smallten.me/p/python-02/</link><pubDate>Mon, 03 Aug 2020 00:56:43 +0800</pubDate><guid>https://blog.smallten.me/p/python-02/</guid><description>簡介 接續上一篇Python-01：爬蟲-圖片下載的內容，這篇文章將帶領大家使用多線程來加速圖片的下載 教學開始 首先我們先看個簡單的多線程範例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import time, threading # 子執行緒的工作函數 def job(): for i in range(5): print(&amp;#34;Child thread:&amp;#34;, i) time.sleep(1) # 建立一個子執行緒 t = threading.Thread(target = job) # 執行該子執行緒 t.start() # 主執行緒繼續執行自己的工作 for i in range(3): print(&amp;#34;Main thread:&amp;#34;, i) time.sleep(1) # 等待 t 這個子執行緒結束 t.join() print(&amp;#34;Done.&amp;#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time, threading # 子執行緒的工作函數 def job(num): print(&amp;#34;Thread&amp;#34;, num) time.</description></item><item><title>Python-01：爬蟲-圖片下載</title><link>https://blog.smallten.me/p/python-01/</link><pubDate>Mon, 03 Aug 2020 00:39:24 +0800</pubDate><guid>https://blog.smallten.me/p/python-01/</guid><description>簡介 這一篇將帶領大家透過Python的爬蟲自動化的下載圖片 安裝 打開終端機，安裝下列套件 pip install requests pip install BeautifulSoup4 pip install lxml pip install selenium 至 Chrome Driver 下載當前電腦中Chrome所對應版本的Driver 教學開始 首先因為這次的主題為圖片下載，因此我們找了一個擁有大量圖片的漫畫網頁來進行教學。 由於這個網頁的圖片是由JavaScript加載的，因此一開始我們使用Selenium來開啟網頁 1 2 3 4 5 6 7 8 9 from selenium import webdriver url = &amp;#39;https://www.ohmanhua.com/13621/1/1.html&amp;#39; #使用crx插件 chop = webdriver.ChromeOptions() chop.add_extension(&amp;#39;Adblock-Plus_v3.8.4.crx&amp;#39;) browser = webdriver.Chrome(options = chop) browser.implicitly_wait(10) browser.get(url) 當然若不想顯示瀏覽器的視窗可以使用headless模式 1 2 chop.add_argument(&amp;#39;--headless&amp;#39;) #規避google bug chop.</description></item><item><title>簡易氣象站-02</title><link>https://blog.smallten.me/p/weather-02/</link><pubDate>Sun, 12 Jul 2020 09:31:38 +0800</pubDate><guid>https://blog.smallten.me/p/weather-02/</guid><description>簡介 這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作在Raspberry pi用Python讀取Arduino Serial的數值，並且製作一個簡易的UI實時顯示出數值。 硬體 上一小節的成品 Raspberry pi * 1 教學開始 打開Raspberry pi的Terminal，並輸入 ls /dev/tty* 將Arduino的Usb接上Raspberry pi 再次於Terminal中輸入 ls /dev/tty*，比較兩次的差異，即可知Arduino使用的序列埠為何(例如此時為/ dev/ttyACM0，請依照情況自行修改) 於Terminal中輸入 python3 -m pip install pyserial 將以下程式碼建立成一個python檔，再以python3執行即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # -*- coding: UTF-8 -*- import serial import tkinter as tk def getData(): ser = serial.</description></item><item><title>簡易氣象站-01</title><link>https://blog.smallten.me/p/weather-01/</link><pubDate>Sun, 12 Jul 2020 09:02:34 +0800</pubDate><guid>https://blog.smallten.me/p/weather-01/</guid><description>簡介 這系列主題將帶領大家建立一個簡易的氣象觀測站，而這一小節將製作由Arduino抓取感測器數值的部分。 硬體 Arduino Uno R3 * 1 攀藤 G5 PMS5003 * 1 DFrobot 三杯式風速感測器 * 1 教學開始 連結電路 Uno程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include &amp;lt;SoftwareSerial.</description></item><item><title>Arduino-05：HC-05 AT命令</title><link>https://blog.smallten.me/p/arduino-05/</link><pubDate>Sun, 10 May 2020 21:56:45 +0800</pubDate><guid>https://blog.smallten.me/p/arduino-05/</guid><description>簡介 這篇內容將教大家透過Arduino的序列埠設定HC-05的AT命令 硬體 Arduino Uno * 1 HC-05藍芽模組 * 1 教學 腳位連接 Arduino HC-05 5V VCC GND GND 8 TX 9 RX 程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &amp;lt;SoftwareSerial.h&amp;gt; SoftwareSerial BT(8, 9); char val; void setup() { Serial.</description></item><item><title>Arduino-04：藍芽遙控車</title><link>https://blog.smallten.me/p/arduino-04/</link><pubDate>Sun, 03 May 2020 16:29:01 +0800</pubDate><guid>https://blog.smallten.me/p/arduino-04/</guid><description>簡介 這篇內容將帶領大家製作藍芽的遙控車，並且用Blynk的Joystick操控它 硬體 Arduino nano * 1 L298N 馬達控制板 * 1 HC-05 藍芽模組 * 1 二輪直流馬達遙控車 * 1 下載 至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 教學開始 先上傳程式碼至Nano板中 依照下方圖示連接腳位，並且設定Blynk App內的物件 連接腳位 設定Blynk 創建3個元件，分別為Button、Bluetooth、Joystick，並且依下圖進行設置 nano程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include &amp;lt;BlynkSimpleSerialBLE.</description></item><item><title>Arduino-03：跑馬燈</title><link>https://blog.smallten.me/p/arduino-03/</link><pubDate>Thu, 09 Apr 2020 14:50:56 +0800</pubDate><guid>https://blog.smallten.me/p/arduino-03/</guid><description>簡介 這篇內容將帶領大家製作點陣跑馬燈，並且用Blynk來操控它 硬體 WeMos D1R2 * 1 MAX7219 8*8LED點陣模組 * 2 下載 至手機應用商店下載Blynk的App－Blynk官網 下載Blynk函式庫 maxmatrix－下載並加入函式庫 教學開始 連接腳位 MAX7219 D1R2 VCC 5V GND GND DIN MOSI/D7 CS SS/D8 CLK SCK/D5 若要串聯多塊MAX7219的話，請將下一塊的DIN接至上一塊的DOUT連接腳位 設定Blynk 請照下圖拉出三個物件，並設定其相關參數 D1R2程式碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 #include &amp;lt;MaxMatrix.</description></item><item><title>Arduino-02：UNOJOY</title><link>https://blog.smallten.me/p/arduino-02/</link><pubDate>Thu, 09 Apr 2020 08:16:57 +0800</pubDate><guid>https://blog.smallten.me/p/arduino-02/</guid><description>簡介 這篇內容將帶領大家把Arduino手把變成電腦手把 所需硬體 Arduino Uno R3 * 1 JoyStick 雙軸按鍵搖桿模組 * 1 下載檔案 FLIP － 請下載包含JRE的檔案(Java Runtime Environment included) UnoJoy － 將Uno變成電腦手把 x360ce － 將手把模擬成xbox 360的手把 教學開始 將下載好的FLIP安裝至電腦 確定電腦已安裝Arduino IDE，並已連接Uno板至電腦，可在裝置管理員查看狀態（如下圖） 打開剛剛下載的UnoJoy資料夾下的檔案，並將它上傳進Uno板中 UnoJoy-master\UnoJoy\UnoJoyArduinoSample\UnoJoyArduinoSample.ino 關閉Arduino IDE，進入DFU Mode，進入方式：用導線同時接觸下圖框起處的兩根針腳 確認已進入 DFU Mode，如下圖 若找不到驅動可手動新增驅動，選擇資料夾為 C:\Program Files (x86)\Atmel\Flip 3.4.7\usb 打開UnoJoy資料夾，啟動TurnIntoAJoystick的批次檔，檔案路徑 UnoJoy-master\UnoJoy\TurnIntoAJoystick.bat，執行成功結果如下圖 至此已完成將Uno變成電腦搖桿，之後插上Uno板皆為UnoJoy Joystick，可在以下路徑查看 控制台\硬體和音效\裝置和印表機 將搖桿的vrx和vry分別連接至Uno板的A0和A1，在 控制台\硬體和音效\裝置和印表機 裡的UnoJoy Joystick圖示上右鍵-&amp;gt;遊戲控制器-&amp;gt;內容，可查看搖桿狀態，如下圖 最後進入起動x360ce，新建立一個搖桿的設定檔，並選取模擬的位置，點選[Record]，依圖示移動搖桿方向即設定完成 補充 如何將UnoJoy Joystick變回一般的Arduino Uno板 連接UnoJoy Joystick，並進入DFU Mode 打開UnoJoy資料夾，啟動TurnIntoAnArduino的批次檔，檔案路徑 UnoJoy-master\UnoJoy\TurnIntoAnArduino.</description></item><item><title>Arduino-01：安裝IDE</title><link>https://blog.smallten.me/p/arduino-01/</link><pubDate>Thu, 09 Apr 2020 08:08:43 +0800</pubDate><guid>https://blog.smallten.me/p/arduino-01/</guid><description>官方IDE 此IDE由官方提供，可在此查看官網 下載－官方載點 VSCode + PlatformIO 先下載 VSCode 再安裝 PlatformIO 的插件</description></item></channel></rss>