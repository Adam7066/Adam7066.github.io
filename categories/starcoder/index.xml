<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>StarCoder on 小十的部落格</title><link>https://blog.smallten.tk/categories/starcoder/</link><description>Recent content in StarCoder on 小十的部落格</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 10 Aug 2021 23:50:17 +0800</lastBuildDate><atom:link href="https://blog.smallten.tk/categories/starcoder/index.xml" rel="self" type="application/rss+xml"/><item><title>StarCoder2021暑訓：Week05</title><link>https://blog.smallten.tk/p/star_coder-06/</link><pubDate>Tue, 10 Aug 2021 23:50:17 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-06/</guid><description>主題 最小生成樹 MST 模板 Kruskal&amp;rsquo;s Algorithm 時間複雜度 O(ElogE) 1struct edge { 2 int u, v, w; 3 bool operator &amp;lt; (const edge &amp;amp;r) const { 4 return w &amp;lt; r.w; 5 } 6}; 7int vn, en; // vertex num, edge num 8vector&amp;lt;edge&amp;gt; ve; 9vector&amp;lt;int&amp;gt; dsu; 10int Find(int x) { 11 if(x == dsu[x]) return x; 12 return dsu[x] = x; 13} 14bool Union(int x, int y) { 15 int a = Find(x), b = Find(y); 16 if(a !</description></item><item><title>StarCoder2021暑訓：Week04</title><link>https://blog.smallten.tk/p/star_coder-05/</link><pubDate>Fri, 06 Aug 2021 10:42:11 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-05/</guid><description>主題 動態規劃 經典背包模板 0/1 背包 &amp;amp; 無限背包 1const int N = 100, W = 100000; 2int cost[N], weight[N], c[W + 1]; 3void knapsack(int n, int w) { 4 memset(c, 0, sizeof(c)); 5 for (int i = 0; i &amp;lt; n; ++i) 6 for (int j = w; j - weight[i] &amp;gt;= 0; --j) // 0/1 背包 7 // for (int j = weight[i]; j &amp;lt;= w; ++j) 無限背包 8 c[j] = max(c[j], c[j - weight[i]] + cost[i]); 9 cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; 10} 有限背包 1const int N = 100, W = 100000; 2int cost[N], weight[N], number[N], c[W + 1]; 3void knapsack(int n, int w) { 4 for (int i = 0; i &amp;lt; n; ++i) { 5 int num = min(number[i], w / weight[i]); 6 for (int k = 1; num &amp;gt; 0; k *= 2) { 7 if (k &amp;gt; num) k = num; 8 num -= k; 9 for (int j = w; j &amp;gt;= weight[i] * k; --j) 10 c[j] = max(c[j], c[j - weight[i] * k] + cost[i] * k); 11 } 12 } 13 cout &amp;lt;&amp;lt; &amp;#34;最高的價值為&amp;#34; &amp;lt;&amp;lt; c[w]; 14} 經典零錢問題模板 1int price[5] = {5, 2, 6, 11, 17}; 2bool c[1000+1]; //int c[1000+1]; 3void change(int m) { 4 memset(c, false, sizeof(c)); 5 c[0] = true; 6 for (int i = 0; i &amp;lt; 5; ++i) 7 for (int j = price[i]; j &amp;lt;= m; ++j) 8 c[j] ||= c[j-price[i]]; 9 // c[j] += c[j-price[i]]; 10 if (c[m]) cout &amp;lt;&amp;lt; &amp;#34;湊得到&amp;#34;; 11 else cout &amp;lt;&amp;lt; &amp;#34;湊不到&amp;#34;; 12 // cout &amp;lt;&amp;lt; &amp;#34;湊得價位&amp;#34; &amp;lt;&amp;lt; m; 13 // cout &amp;lt;&amp;lt; &amp;#34;湊法總共&amp;#34; &amp;lt;&amp;lt; c[m] &amp;lt;&amp;lt; &amp;#34;種&amp;#34;; 14} LIS 模板 DP 1const int N = 100; 2int s[N], length[N]; 3int LIS() { 4 for (int i=0; i&amp;lt;N; i++) length[i] = 1; 5 for (int i=0; i&amp;lt;N; i++) 6 for (int j=0; j&amp;lt;i; j++) 7 if (s[j] &amp;lt; s[i]) 8 length[i] = max(length[i], length[j] + 1); 9 int l = 0; 10 for (int i=0; i&amp;lt;N; i++) l = max(l, length[i]); 11 return l; 12} Robinson-Schensted-Knuth Algorithm 時間複雜度 O(NlogL) ， N 是序列長度， L 是 LIS 長度。 1int LIS(vector&amp;lt;int&amp;gt;&amp;amp; s) { 2 if (s.</description></item><item><title>StarCoder2021暑訓：Week03</title><link>https://blog.smallten.tk/p/star_coder-04/</link><pubDate>Wed, 28 Jul 2021 05:48:25 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-04/</guid><description>主題 圖、狀態搜尋、拓樸排序、尤拉路 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用演算法 基本題 UVa 10004 無向圖的兩色著色問題 DFS/BFS 均可 V UVa 10959 求無向無權圖上每一點和一指定點的最短距離 BFS V UVa 572 求二維地圖上的連通塊數量 DFS/BFS 均可 V UVa 441 給定 k 個數，由小到大列出所有包含其中 6 個數的遞增數列 DFS UVa 567 求無向無權圖上指定兩點間的最短距離 BFS (或用後面會學到的 Floyd-Warshall 演算法) V UVa 10926 給有向無環圖，求最大一棵樹的節點數減1 DFS/BFS 均可 SPOJ PT07Z 求數直徑（經典題） DFS/BFS 均可 UVa 10603 倒水問題（給三個水瓶，倒出指定水量） BFS 變型 (帶權最短路) UVa 10305 給定 n 個工作的兩兩先後關係，輸出任一個合法的工作完成順序。 拓樸排序 V UVa 1423 給定一數列中 Sij = a[i]+…+a[j] 的正負號，輸出一組符合正負號關係的數列。(有趣，值得思考！) 拓樸排序 UVa 302 給定一個無向圖和指定起點，列印尤拉路。 尤拉路 UVa 10441 給定一堆字串，問如何將它們頭尾相連串起來。 尤拉路 參考作法 A - Bicoloring 1#include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓：Week02</title><link>https://blog.smallten.tk/p/star_coder-03/</link><pubDate>Sat, 24 Jul 2021 08:26:57 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-03/</guid><description>主題 STL、併查集 併查集模板 1int dsu[MAX_N]; 2void init(int num) { 3 for(int i = 0; i &amp;lt;= num; ++i) 4 dsu[i] = i; 5} 6int Find(int x) { 7 if(x == dsu[x]) return x; 8 return dsu[x] = Find(dsu[x]); 9} 10void Union(int x, int y) { 11 int a = Find(x), b = Find(y); 12 if(a != b) dsu[a] = b; 13} 題目 Virtual Judge 題目列表與提示 題目 題目需求 採用結構 優先練習 UVa 673 括號匹配與 LIFO 操作 std::stack v UVa 442 括號匹配與 LIFO 操作 std::stack UVa 12100 遍歷和 FIFO 操作 std::queue (加上 std::priority_queue 效率更高) v UVa 245 取出第 n 個以及插入頭端 std::list / std::deque / std::vector UVa 1203 插入與取出最小值 std::priority_queue v UVa 11995 模擬 stack, queue, priority_queue std::stack, std::queue, std::priority_queue v UVa 10583 標準併查集操作 disjoint set v UVa 11987 併查集的變化題(值得思考) disjoint set UVa 1665 判斷連通塊數 disjoint set UVa 230 字串排序與搜尋 std::map / std::set v UVa 1592 字串比較（將字串轉成數值以加快比較） std::map 參考作法 A - Parentheses Balance 1#include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓：Week01</title><link>https://blog.smallten.tk/p/star_coder-02/</link><pubDate>Thu, 15 Jul 2021 00:07:54 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-02/</guid><description>主題 搜尋、排序、貪心 題目 Virtual Judge 參考作法 A - Flip Sort 題目說明： 給一堆數字，輸出要交換(只能相鄰交換)多少次，才能由小到大排好。 解題思路： Bubble sort 程式碼： 1#include &amp;lt;bits/stdc++.h&amp;gt;2using namespace std; 3int main() { 4 int n, a[1005]; 5 while(cin &amp;gt;&amp;gt; n) { 6 int ans = 0; 7 for(int i = 0; i &amp;lt; n; ++i) cin &amp;gt;&amp;gt; a[i]; 8 for(int i = 0; i &amp;lt; n; ++i) { 9 for(int j = n - 1; j &amp;gt; i; --j) { 10 if(a[j] &amp;lt; a[j - 1]) { 11 swap(a[j], a[j - 1]); 12 ++ans; 13 } 14 } 15 } 16 cout &amp;lt;&amp;lt; &amp;#34;Minimum exchange operations : &amp;#34; &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; 17 } 18 return 0; 19} B - Age Sort 題目說明： 給一堆數字，由小到大排序。 解題思路： std::sort() 小心 Presentation error 程式碼： 1#include &amp;lt;bits/stdc++.</description></item><item><title>StarCoder2021暑訓</title><link>https://blog.smallten.tk/p/star_coder-01/</link><pubDate>Wed, 14 Jul 2021 22:52:11 +0800</pubDate><guid>https://blog.smallten.tk/p/star_coder-01/</guid><description>簡介 週次 主題 題目 一 搜尋、排序、貪心 Link 二 STL、併查集 Link 三 圖、狀態搜尋、拓樸排序、尤拉路 Link 四 動態規劃 Link 五 最小生成樹 Link 六 七 八 學習資源 第一週 - 搜尋、排序、貪心 線上教材 教材 說明 師大碼賽客：排序/貪心/二分搜 子緯學長的教學講義（詳盡的新手入門） 北一女培訓：排序 六種排序法的程式與簡介 建中培訓 (第4/6/7節) 4.</description></item></channel></rss>